/**
 * THIS FILE IS GENERATED BY `yarn generate-integration-docs`.
 *
 * DO NOT EDIT MANUALLY.
 */

import {IntegrationFrontmatter} from '../types';
import databricksLogo from './logos/databricks.svg';

export const logo = databricksLogo;

export const frontmatter: IntegrationFrontmatter = {
  id: 'databricks',
  status: 'published',
  name: 'Databricks',
  title: 'Dagster & Databricks',
  excerpt:
    'The Databricks integration enables you to initiate Databricks jobs directly from Dagster, seamlessly pass parameters to your code, and stream logs and structured messages back into Dagster.',
  partnerlink: 'https://databricks.com/',
  categories: ['Compute'],
  enabledBy: [],
  enables: [],
  tags: ['dagster-supported', 'compute'],
};

export const content =
  'The `dagster-databricks` integration library provides the `PipesDatabricksClient` resource, enabling you to launch Databricks jobs directly from Dagster assets and ops. This integration allows you to pass parameters to Databricks code while Dagster receives real-time events, such as logs, asset checks, and asset materializations, from the initiated jobs. With minimal code changes required on the job side, this integration is both efficient and easy to implement.\n\n### Installation\n\n```bash\npip install dagster-databricks\n```\n\n### Example\n\n\n```python\nimport sys\n\nfrom dagster_databricks import PipesDatabricksClient\nfrom databricks.sdk import WorkspaceClient\nfrom databricks.sdk.service import jobs\n\nimport dagster as dg\n\n\n@dg.asset\ndef databricks_asset(\n    context: dg.AssetExecutionContext, pipes_databricks: PipesDatabricksClient\n):\n    task = jobs.SubmitTask.from_dict(\n        {\n            # The cluster settings below are somewhat arbitrary. Dagster Pipes is\n            # not dependent on a specific spark version, node type, or number of\n            # workers.\n            "new_cluster": {\n                "spark_version": "12.2.x-scala2.12",\n                "node_type_id": "i3.xlarge",\n                "num_workers": 0,\n                "cluster_log_conf": {\n                    "dbfs": {"destination": "dbfs:/cluster-logs-dir-noexist"},\n                },\n            },\n            "libraries": [\n                # Include the latest published version of dagster-pipes on PyPI\n                # in the task environment\n                {"pypi": {"package": "dagster-pipes"}},\n            ],\n            "task_key": "some-key",\n            "spark_python_task": {\n                "python_file": "dbfs:/my_python_script.py",  # location of target code file\n                "source": jobs.Source.WORKSPACE,\n            },\n        }\n    )\n\n    print("This will be forwarded back to Dagster stdout")  # noqa: T201\n    print("This will be forwarded back to Dagster stderr", file=sys.stderr)  # noqa: T201\n\n    extras = {"some_parameter": 100}\n\n    return pipes_databricks.run(\n        task=task,\n        context=context,\n        extras=extras,\n    ).get_materialize_result()\n\n\npipes_databricks_resource = PipesDatabricksClient(\n    client=WorkspaceClient(\n        host="https://<workspace-id>.cloud.databricks.com",\n        token="<token>",\n    )\n)\n\ndefs = dg.Definitions(\n    assets=[databricks_asset], resources={"pipes_databricks": pipes_databricks_resource}\n)\n```\n        \n\n\n```python\nfrom dagster_pipes import (\n    PipesDbfsContextLoader,\n    PipesDbfsMessageWriter,\n    open_dagster_pipes,\n)\n\n# Sets up communication channels and downloads the context data sent from Dagster.\n# Note that while other `context_loader` and `message_writer` settings are\n# possible, it is recommended to use `PipesDbfsContextLoader` and\n# `PipesDbfsMessageWriter` for Databricks.\nwith open_dagster_pipes(\n    context_loader=PipesDbfsContextLoader(),\n    message_writer=PipesDbfsMessageWriter(),\n) as pipes:\n    # Access the `extras` dict passed when launching the job from Dagster.\n    some_parameter_value = pipes.get_extra("some_parameter")\n\n    # Stream log message back to Dagster\n    pipes.log.info(f"Using some_parameter value: {some_parameter_value}")\n\n    # ... your code that computes and persists the asset\n\n    # Stream asset materialization metadata and data version back to Dagster.\n    # This should be called after you\'ve computed and stored the asset value. We\n    # omit the asset key here because there is only one asset in scope, but for\n    # multi-assets you can pass an `asset_key` parameter.\n    pipes.report_asset_materialization(\n        metadata={\n            "some_metric": {"raw_value": some_parameter_value + 1, "type": "int"}\n        },\n        data_version="alpha",\n    )\n```\n        \n\n### About Databricks\n\n**Databricks** is a unified data analytics platform that simplifies and accelerates the process of building big data and AI solutions. It integrates seamlessly with Apache Spark and offers support for various data sources and formats. Databricks provides powerful tools to create, run, and manage data pipelines, making it easier to handle complex data engineering tasks. Its collaborative and scalable environment is ideal for data engineers, scientists, and analysts who need to process and analyze large datasets efficiently.';
