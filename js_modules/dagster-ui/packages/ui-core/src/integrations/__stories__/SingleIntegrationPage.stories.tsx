import {Box, Colors} from '@dagster-io/ui-components';
import {useIntegrationsProvider} from 'shared/integrations/useIntegrationsProvider.oss';

import {SingleIntegrationPage} from '../SingleIntegrationPage';
import {IntegrationConfig} from '../types';

// eslint-disable-next-line import/no-default-export
export default {
  title: 'Integrations/SingleIntegrationPage',
  component: SingleIntegrationPage,
};

export const MarkdownWithBetaAndSections = () => {
  const provider = useIntegrationsProvider();

  const fivetran: IntegrationConfig = {
    frontmatter: {
      id: 'fivetran',
      title: 'Using Dagster with Fivetran',
      name: 'Fivetran',
      description:
        'Orchestrate Fivetran connectors syncs with upstream or downstream dependencies.',
      tags: ['dagster-supported', 'etl'],
      source:
        'https://github.com/dagster-io/dagster/tree/master/python_modules/libraries/dagster-fivetran',
      pypi: 'https://pypi.org/project/dagster-fivetran/',
      partnerlink: 'https://www.fivetran.com/',
      logoFilename: 'fivetran.svg',
      logo: null,
      installationCommand: null,
      isPrivate: false,
    },
    content:
      '\n\n<Beta />\n\nThis guide provides instructions for using Dagster with Fivetran using the `dagster-fivetran` library. Your Fivetran connector tables can be represented as assets in the Dagster asset graph, allowing you to track lineage and dependencies between Fivetran assets and data assets you are already modeling in Dagster. You can also use Dagster to orchestrate Fivetran connectors, allowing you to trigger syncs for these on a cadence or based on upstream data changes.\n\n:::note\n\nYour Fivetran connectors must have been synced at least once to be represented in Dagster.\n\n:::\n\n## What you\'ll learn\n\n- How to represent Fivetran assets in the Dagster asset graph, including lineage to other Dagster assets.\n- How to customize asset definition metadata for these Fivetran assets.\n- How to materialize Fivetran connector tables from Dagster.\n- How to customize how Fivetran connector tables are materialized.\n\n<details>\n  <summary>Prerequisites</summary>\n\n- The `dagster` and `dagster-fivetran` libraries installed in your environment\n- Familiarity with asset definitions and the Dagster asset graph\n- Familiarity with Dagster resources\n- Familiarity with Fivetran concepts, like connectors and connector tables\n- A Fivetran workspace\n- A Fivetran API key and API secret. For more information, see [Getting Started](https://fivetran.com/docs/rest-api/getting-started) in the Fivetran REST API documentation.\n\n</details>\n\n## Set up your environment\n\nTo get started, you\'ll need to install the `dagster` and `dagster-fivetran` Python packages:\n\n```bash\npip install dagster dagster-fivetran\n```\n\n## Represent Fivetran assets in the asset graph\n\nTo load Fivetran assets into the Dagster asset graph, you must first construct a <PyObject section="libraries" module="dagster_fivetran" object="FivetranWorkspace" /> resource, which allows Dagster to communicate with your Fivetran workspace. You\'ll need to supply your account ID, API key and API secret. See [Getting Started](https://fivetran.com/docs/rest-api/getting-started) in the Fivetran REST API documentation for more information on how to create your API key and API secret.\n\nDagster can automatically load all connector tables from your Fivetran workspace as asset specs. Call the <PyObject section="libraries" module="dagster_fivetran" object="load_fivetran_asset_specs" /> function, which returns list of <PyObject section="assets" module="dagster" object="AssetSpec" />s representing your Fivetran assets. You can then include these asset specs in your <PyObject section="definitions" module="dagster" object="Definitions" /> object:\n\n```python\nfrom dagster_fivetran import FivetranWorkspace, load_fivetran_asset_specs\n\nimport dagster as dg\n\nfivetran_workspace = FivetranWorkspace(\n    account_id=dg.EnvVar("FIVETRAN_ACCOUNT_ID"),\n    api_key=dg.EnvVar("FIVETRAN_API_KEY"),\n    api_secret=dg.EnvVar("FIVETRAN_API_SECRET"),\n)\n\nfivetran_specs = load_fivetran_asset_specs(fivetran_workspace)\ndefs = dg.Definitions(assets=fivetran_specs, resources={"fivetran": fivetran_workspace})\n```\n\n### Sync and materialize Fivetran assets\n\nYou can use Dagster to sync Fivetran connectors and materialize Fivetran connector tables. You can use the <PyObject section="libraries" module="dagster_fivetran" object="build_fivetran_assets_definitions" /> factory to create all assets definitions for your Fivetran workspace.\n\n```python\nfrom dagster_fivetran import FivetranWorkspace, build_fivetran_assets_definitions\n\nimport dagster as dg\n\nfivetran_workspace = FivetranWorkspace(\n    account_id=dg.EnvVar("FIVETRAN_ACCOUNT_ID"),\n    api_key=dg.EnvVar("FIVETRAN_API_KEY"),\n    api_secret=dg.EnvVar("FIVETRAN_API_SECRET"),\n)\n\nall_fivetran_assets = build_fivetran_assets_definitions(workspace=fivetran_workspace)\n\ndefs = dg.Definitions(\n    assets=all_fivetran_assets,\n    resources={"fivetran": fivetran_workspace},\n)\n```\n\n### Customize the materialization of Fivetran assets\n\nIf you want to customize the sync of your connectors, you can use the <PyObject section="libraries" module="dagster_fivetran" object="fivetran_assets" /> decorator to do so. This allows you to execute custom code before and after the call to the Fivetran sync.\n\n```python\nfrom dagster_fivetran import FivetranWorkspace, fivetran_assets\n\nimport dagster as dg\n\nfivetran_workspace = FivetranWorkspace(\n    account_id=dg.EnvVar("FIVETRAN_ACCOUNT_ID"),\n    api_key=dg.EnvVar("FIVETRAN_API_KEY"),\n    api_secret=dg.EnvVar("FIVETRAN_API_SECRET"),\n)\n\n\n@fivetran_assets(\n    # Replace with your connector ID\n    connector_id="fivetran_connector_id",\n    name="fivetran_connector_id",\n    group_name="fivetran_connector_id",\n    workspace=fivetran_workspace,\n)\ndef fivetran_connector_assets(\n    context: dg.AssetExecutionContext, fivetran: FivetranWorkspace\n):\n    # Do something before the materialization...\n    yield from fivetran.sync_and_poll(context=context)\n    # Do something after the materialization...\n\n\ndefs = dg.Definitions(\n    assets=[fivetran_connector_assets],\n    resources={"fivetran": fivetran_workspace},\n)\n```\n\n### Customize asset definition metadata for Fivetran assets\n\nBy default, Dagster will generate asset specs for each Fivetran asset and populate default metadata. You can further customize asset properties by passing an instance of the custom <PyObject section="libraries" module="dagster_fivetran" object="DagsterFivetranTranslator" /> to the <PyObject section="libraries" module="dagster_fivetran" object="load_fivetran_asset_specs" /> function.\n\n```python\nfrom dagster_fivetran import (\n    DagsterFivetranTranslator,\n    FivetranConnectorTableProps,\n    FivetranWorkspace,\n    load_fivetran_asset_specs,\n)\n\nimport dagster as dg\n\nfivetran_workspace = FivetranWorkspace(\n    account_id=dg.EnvVar("FIVETRAN_ACCOUNT_ID"),\n    api_key=dg.EnvVar("FIVETRAN_API_KEY"),\n    api_secret=dg.EnvVar("FIVETRAN_API_SECRET"),\n)\n\n\n# A translator class lets us customize properties of the built\n# Fivetran assets, such as the owners or asset key\nclass MyCustomFivetranTranslator(DagsterFivetranTranslator):\n    def get_asset_spec(self, props: FivetranConnectorTableProps) -> dg.AssetSpec:\n        # We create the default asset spec using super()\n        default_spec = super().get_asset_spec(props)\n        # We customize the metadata and asset key prefix for all assets\n        return default_spec.replace_attributes(\n            key=default_spec.key.with_prefix("prefix"),\n        ).merge_attributes(metadata={"custom": "metadata"})\n\n\nfivetran_specs = load_fivetran_asset_specs(\n    fivetran_workspace, dagster_fivetran_translator=MyCustomFivetranTranslator()\n)\n\ndefs = dg.Definitions(assets=fivetran_specs, resources={"fivetran": fivetran_workspace})\n```\n\nNote that `super()` is called in each of the overridden methods to generate the default asset spec. It is best practice to generate the default asset spec before customizing it.\n\nYou can pass an instance of the custom <PyObject section="libraries" module="dagster_fivetran" object="DagsterFivetranTranslator" /> to the <PyObject section="libraries" module="dagster_fivetran" object="fivetran_assets" /> decorator or the <PyObject section="libraries" module="dagster_fivetran" object="build_fivetran_assets_definitions" /> factory.\n\n### Fetching column-level metadata for Fivetran assets\n\nDagster allows you to emit column-level metadata, like [column schema](/guides/build/assets/metadata-and-tags/index.md#standard-metadata-types) and [column lineage](/guides/build/assets/metadata-and-tags/index.md#column-lineage), as [materialization metadata](/guides/build/assets/metadata-and-tags/index.md#runtime-metadata).\n\nWith this metadata, you can view documentation in Dagster for all columns in your Fivetran connector tables.\n\nTo enable this feature, call <PyObject section="libraries" object="fivetran_event_iterator.FivetranEventIterator.fetch_column_metadata" module="dagster_fivetran" displayText="fetch_column_metadata()" /> on the <PyObject section="libraries" object="fivetran_event_iterator.FivetranEventIterator" module="dagster_fivetran" /> returned by the `sync_and_poll()` call on the <PyObject section="libraries" module="dagster_fivetran" object="FivetranWorkspace" /> resource.\n\n```python\nfrom dagster_fivetran import FivetranWorkspace, fivetran_assets\n\nimport dagster as dg\n\nfivetran_workspace = FivetranWorkspace(\n    account_id=dg.EnvVar("FIVETRAN_ACCOUNT_ID"),\n    api_key=dg.EnvVar("FIVETRAN_API_KEY"),\n    api_secret=dg.EnvVar("FIVETRAN_API_SECRET"),\n)\n\n\n@fivetran_assets(\n    # Replace with your connector ID\n    connector_id="fivetran_connector_id",\n    workspace=fivetran_workspace,\n)\ndef fivetran_connector_assets(\n    context: dg.AssetExecutionContext, fivetran: FivetranWorkspace\n):\n    yield from fivetran.sync_and_poll(context=context).fetch_column_metadata()\n\n\ndefs = dg.Definitions(\n    assets=[fivetran_connector_assets],\n    resources={"fivetran": fivetran_workspace},\n)\n```\n\n### Load Fivetran asset for selected connectors\n\nTo select a subset of Fivetran connectors for which your Fivetran assets will be loaded, you can use the <PyObject section="libraries" module="dagster_fivetran" object="ConnectorSelectorFn" /> callback and define your selection conditions.\n\n```python\nfrom dagster_fivetran import FivetranWorkspace, build_fivetran_assets_definitions\n\nimport dagster as dg\n\nfivetran_workspace = FivetranWorkspace(\n    account_id=dg.EnvVar("FIVETRAN_ACCOUNT_ID"),\n    api_key=dg.EnvVar("FIVETRAN_API_KEY"),\n    api_secret=dg.EnvVar("FIVETRAN_API_SECRET"),\n)\n\nall_fivetran_assets = build_fivetran_assets_definitions(\n    workspace=fivetran_workspace,\n    connector_selector_fn=(\n        lambda connector: connector.id in {"some_connector_id", "another_connector_id"}\n    ),\n)\n\ndefs = dg.Definitions(\n    assets=all_fivetran_assets,\n    resources={"fivetran": fivetran_workspace},\n)\n```\n\n### Load Fivetran assets from multiple workspaces\n\nDefinitions from multiple Fivetran workspaces can be combined by instantiating multiple <PyObject section="libraries" module="dagster_fivetran" object="FivetranWorkspace" /> resources and merging their specs. This lets you view all your Fivetran assets in a single asset graph:\n\n```python\nfrom dagster_fivetran import FivetranWorkspace, load_fivetran_asset_specs\n\nimport dagster as dg\n\nsales_fivetran_workspace = FivetranWorkspace(\n    account_id=dg.EnvVar("FIVETRAN_SALES_ACCOUNT_ID"),\n    api_key=dg.EnvVar("FIVETRAN_SALES_API_KEY"),\n    api_secret=dg.EnvVar("FIVETRAN_SALES_API_SECRET"),\n)\nmarketing_fivetran_workspace = FivetranWorkspace(\n    account_id=dg.EnvVar("FIVETRAN_MARKETING_ACCOUNT_ID"),\n    api_key=dg.EnvVar("FIVETRAN_MARKETING_API_KEY"),\n    api_secret=dg.EnvVar("FIVETRAN_MARKETING_API_SECRET"),\n)\n\nsales_fivetran_specs = load_fivetran_asset_specs(sales_fivetran_workspace)\nmarketing_fivetran_specs = load_fivetran_asset_specs(marketing_fivetran_workspace)\n\n# Merge the specs into a single set of definitions\ndefs = dg.Definitions(\n    assets=[*sales_fivetran_specs, *marketing_fivetran_specs],\n    resources={\n        "marketing_fivetran": marketing_fivetran_workspace,\n        "sales_fivetran": sales_fivetran_workspace,\n    },\n)\n```\n\n### Define upstream dependencies\n\nBy default, Dagster does not set upstream dependencies when generating asset specs for your Fivetran assets. You can set upstream dependencies on your Fivetran assets by passing an instance of the custom <PyObject section="libraries" module="dagster_fivetran" object="DagsterFivetranTranslator" /> to the <PyObject section="libraries" module="dagster_fivetran" object="load_fivetran_asset_specs" /> function.\n\n```python\nclass MyCustomFivetranTranslator(DagsterFivetranTranslator):\n    def get_asset_spec(self, props: FivetranConnectorTableProps) -> dg.AssetSpec:\n        # We create the default asset spec using super()\n        default_spec = super().get_asset_spec(props)\n        # We set an upstream dependency for our assets\n        return default_spec.replace_attributes(deps=["my_upstream_asset_key"])\n\n\nfivetran_specs = load_fivetran_asset_specs(\n    fivetran_workspace, dagster_fivetran_translator=MyCustomFivetranTranslator()\n)\n```\n\nNote that `super()` is called in each of the overridden methods to generate the default asset spec. It is best practice to generate the default asset spec before customizing it.\n\nYou can pass an instance of the custom <PyObject section="libraries" module="dagster_fivetran" object="DagsterFivetranTranslator" /> to the <PyObject section="libraries" module="dagster_fivetran" object="fivetran_assets" /> decorator or the <PyObject section="libraries" module="dagster_fivetran" object="build_fivetran_assets_definitions" /> factory.\n\n### Define downstream dependencies\n\nDagster allows you to define assets that are downstream of specific Fivetran tables using their asset keys. The asset key for a Fivetran table can be retrieved using the asset definitions created using the <PyObject section="libraries" module="dagster_fivetran" object="fivetran_assets" /> decorator. The below example defines `my_downstream_asset` as a downstream dependency of `my_fivetran_table`:\n\n```python\n@fivetran_assets(\n    # Replace with your connector ID\n    connector_id="fivetran_connector_id",\n    workspace=fivetran_workspace,\n)\ndef fivetran_connector_assets(\n    context: dg.AssetExecutionContext, fivetran: FivetranWorkspace\n): ...\n\n\nmy_fivetran_table_asset_key = next(\n    iter(\n        [\n            spec.key\n            for spec in fivetran_connector_assets.specs\n            if spec.metadata.get("dagster/table_name")\n            == "my_database.my_schema.my_fivetran_table"\n        ]\n    )\n)\n\n\n@dg.asset(deps=[my_fivetran_table_asset_key])\ndef my_downstream_asset(): ...\n```\n\nIn the downstream asset, you may want direct access to the contents of the Fivetran table. To do so, you can customize the code within your `@asset`-decorated function to load upstream data.\n\n\n### About Fivetran\n\n**Fivetran** ingests data from SaaS applications, databases, and servers. The data is stored and typically used for analytics.',
  };

  return (
    <Box
      style={{
        width: '1300px',
        height: '100%',
        overflowY: 'auto',
        backgroundColor: Colors.backgroundLight(),
      }}
    >
      <SingleIntegrationPage integration={fivetran} provider={provider} />
    </Box>
  );
};

export const MarkdownWithTabs = () => {
  const provider = useIntegrationsProvider();

  const sling: IntegrationConfig = {
    frontmatter: {
      id: 'sling',
      title: 'Dagster & Sling',
      name: 'Sling',
      description:
        'Extract and load data from popular data sources to destinations with Sling through Dagster.',
      tags: ['dagster-supported', 'etl'],
      source:
        'https://github.com/dagster-io/dagster/tree/master/python_modules/libraries/dagster-sling',
      pypi: 'https://pypi.org/project/dagster-sling',
      partnerlink: 'https://slingdata.io/',
      logoFilename: 'sling.png',
      logo: null,
      isPrivate: false,
      installationCommand:
        '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"',
    },
    content:
      'Sling provides an easy-to-use YAML configuration layer for loading data from files, replicating data between databases, exporting custom SQL queries to cloud storage, and much more.\n\n## How it works\n\nThe Dagster integration allows you to derive Dagster assets from a replication configuration file. The typical pattern for building an ELT pipeline with Sling has three steps:\n\n1. Define a Sling [`replication.yaml`](https://docs.slingdata.io/sling-cli/run/configuration/replication) file that specifies the source and target connections, as well as which streams to sync from.\n\n2. Create a <PyObject section="libraries" module="dagster_sling" object="SlingResource" /> and pass a list of <PyObject section="libraries" module="dagster_sling" object="SlingConnectionResource" /> for each connection to the `connection` parameter, ensuring the resource uses the same name given to the connection in the Sling configuration.\n\n3. Use the <PyObject section="libraries" module="dagster_sling" object="sling_assets" decorator /> decorator to define an asset that runs the Sling replication job and yields from the <PyObject section="libraries" module="dagster_sling" object="SlingResource" method="replicate" /> method to run the sync.\n\nWe\'ll walk you through each of these steps in this guide.\n\n## Prerequisites\n\nTo follow the steps in this guide:\n\n- **Familiarize yourself with [Sling\'s replication configuration](https://docs.slingdata.io/sling-cli/run/configuration/replication)**, if you\'ve never worked with Sling before. The replication configuration is a YAML file that specifies the source and target connections, as well as which streams to sync from. The `dagster-sling` integration uses this configuration to build assets for both sources and destinations.\n- **To install the following libraries**:\n\n  ```bash\n  pip install dagster dagster-sling\n  ```\n\n  Refer to the [Dagster installation](/getting-started/installation) guide for more info.\n\n## Step 1: Set up a Sling replication configuration\n\nDagster\'s Sling integration is built around Sling\'s replication configuration. You may provide either a path to an existing `replication.yaml` file or construct a dictionary that represents the configuration in Python. This configuration is passed to the Sling CLI to run the replication job.\n\n<Tabs>\n<TabItem value="replication.yaml">\n\n### replication.yaml\n\nThis example creates a replication configuration in a `replication.yaml` file:\n\n```yaml\n# replication.yaml\n\nsource: MY_POSTGRES\ntarget: MY_SNOWFLAKE\n\ndefaults:\n  mode: full-refresh\n  object: "{stream_schema}_{stream_table}"\n\nstreams:\n  public.accounts:\n  public.users:\n  public.finance_departments:\n    object: "departments"\n```\n\n</TabItem>\n<TabItem value="Python">\n\n### Python\n\nThis example creates a replication configuration using Python:\n\n```python\nreplication_config = {\n    "source": "MY_POSTGRES",\n    "target": "MY_DUCKDB",\n    "defaults": {"mode": "full-refresh", "object": "{stream_schema}_{stream_table}"},\n    "streams": {\n        "public.accounts": None,\n        "public.users": None,\n        "public.finance_departments": {"object": "departments"},\n    },\n}\n```\n\n</TabItem>\n</Tabs>\n\n## Step 2: Create a Sling resource\n\nNext, you\'ll create a <PyObject section="libraries" module="dagster_sling" object="SlingResource" /> object that contains references to the connections specified in the replication configuration:\n\n\n```python\n# pyright: reportCallIssue=none\nfrom dagster_sling import SlingConnectionResource, SlingResource\n\nfrom dagster import EnvVar\n\nsling_resource = SlingResource(\n    connections=[\n        # Using a connection string from an environment variable\n        SlingConnectionResource(\n            name="MY_POSTGRES",\n            type="postgres",\n            connection_string=EnvVar("POSTGRES_CONNECTION_STRING"),\n        ),\n        # Using a hard-coded connection string\n        SlingConnectionResource(\n            name="MY_DUCKDB",\n            type="duckdb",\n            connection_string="duckdb:///var/tmp/duckdb.db",\n        ),\n        # Using a keyword-argument constructor\n        SlingConnectionResource(\n            name="MY_SNOWFLAKE",\n            type="snowflake",\n            host=EnvVar("SNOWFLAKE_HOST"),\n            user=EnvVar("SNOWFLAKE_USER"),\n            role="REPORTING",\n        ),\n    ]\n)\n```\n\n\nA <PyObject section="libraries" module="dagster_sling" object="SlingResource" /> takes a `connections` parameter, where each <PyObject section="libraries" module="dagster_sling" object="SlingConnectionResource" /> represents a connection to a source or target database. You may provide as many connections to the `SlingResource` as needed.\n\nThe `name` parameter in the <PyObject section="libraries" module="dagster_sling" object="SlingConnectionResource" /> should match the `source` and `target` keys in the replication configuration.\n\nYou can pass a connection string or arbitrary keyword arguments to the <PyObject section="libraries" module="dagster_sling" object="SlingConnectionResource" /> to specify the connection details. Refer to [Sling\'s connections reference](https://docs.slingdata.io/connections/database-connections) for the specific connection types and parameters.\n\n## Step 3: Define the Sling assets\n\nNext, define a Sling asset using the <PyObject section="libraries" module="dagster_sling" object="sling_assets" decorator /> decorator. Dagster will read the replication configuration to produce assets.\n\nEach stream will render two assets, one for the source stream and one for the target destination. You can override how assets are named by passing in a custom <PyObject section="libraries" module="dagster_sling" object="DagsterSlingTranslator" /> object.\n\n```python\nfrom dagster_sling import SlingResource, sling_assets\n\nfrom dagster import Definitions, file_relative_path\n\nreplication_config = file_relative_path(__file__, "../sling_replication.yaml")\nsling_resource = SlingResource(connections=[...])  # Add connections here\n\n\n@sling_assets(replication_config=replication_config)\ndef my_assets(context, sling: SlingResource):\n    yield from sling.replicate(context=context)\n    for row in sling.stream_raw_logs():\n        context.log.info(row)\n```\n\n\n## Step 4: Create the Definitions object\n\nThe last step is to include the Sling assets and resource in a <PyObject section="definitions" module="dagster" object="Definitions" /> object. This enables Dagster tools to load everything we\'ve defined:\n\n```python\ndefs = Definitions(\n    assets=[\n        my_assets,\n    ],\n    resources={\n        "sling": sling_resource,\n    },\n)\n```\n\n\nThat\'s it! You should now be able to view your assets in the [Dagster UI](/guides/operate/webserver) and run the replication job.\n\n\n## Examples\n\n### Example 1: Database to database\n\nTo set up a Sling sync between two databases, such as Postgres and Snowflake, you could do something like the following:\n\n\n```python\n# pyright: reportCallIssue=none\n# pyright: reportOptionalMemberAccess=none\n\nfrom dagster_sling import SlingConnectionResource, SlingResource, sling_assets\n\nfrom dagster import EnvVar\n\nsource = SlingConnectionResource(\n    name="MY_PG",\n    type="postgres",\n    host="localhost",\n    port=5432,\n    database="my_database",\n    user="my_user",\n    password=EnvVar("PG_PASS"),\n)\n\ntarget = SlingConnectionResource(\n    name="MY_SF",\n    type="snowflake",\n    host="hostname.snowflake",\n    user="username",\n    database="database",\n    password=EnvVar("SF_PASSWORD"),\n    role="role",\n)\n\nsling = SlingResource(\n    connections=[\n        source,\n        target,\n    ]\n)\nreplication_config = {\n    "SOURCE": "MY_PG",\n    "TARGET": "MY_SF",\n    "defaults": {"mode": "full-refresh", "object": "{stream_schema}_{stream_table}"},\n    "streams": {\n        "public.accounts": None,\n        "public.users": None,\n        "public.finance_departments": {"object": "departments"},\n    },\n}\n\n\n@sling_assets(replication_config=replication_config)\ndef my_assets(context, sling: SlingResource):\n    yield from sling.replicate(context=context)\n```\n\n\n### Example 2: File to database\n\nTo set up a Sling sync between a file in an object store and a database, such as from Amazon S3 to Snowflake, you could do something like the following:\n\n\n```python\nfrom dagster_sling import SlingConnectionResource, SlingResource, sling_assets\n\nfrom dagster import EnvVar\n\ntarget = SlingConnectionResource(\n    name="MY_SF",\n    type="snowflake",\n    host="hostname.snowflake",\n    user="username",\n    database="database",\n    password=EnvVar("SF_PASSWORD"),\n    role="role",\n)\n\nsource = SlingConnectionResource(\n    name="MY_S3",\n    type="s3",\n    bucket="sling-bucket",\n    access_key_id=EnvVar("AWS_ACCESS_KEY_ID"),\n    secret_access_key=EnvVar("AWS_SECRET_ACCESS_KEY"),\n)\n\nsling = SlingResource(connections=[source, target])\n\nreplication_config = {\n    "SOURCE": "MY_S3",\n    "TARGET": "MY_SF",\n    "defaults": {"mode": "full-refresh", "object": "{stream_schema}_{stream_table}"},\n    "streams": {\n        "s3://my-bucket/my_file.parquet": {\n            "object": "marts.my_table",\n            "primary_key": "id",\n        },\n    },\n}\n\n\n@sling_assets(replication_config=replication_config)\ndef my_assets(context, sling: SlingResource):\n    yield from sling.replicate(context=context)\n```\n\n## Advanced usage\n\n### Customize upstream dependencies\n\nBy default, Dagster sets upstream dependencies when generating asset specs for your Sling assets. To do so, Dagster parses information about assets that are upstream of specific Sling assets from the Sling replication configuration itself. You can customize how upstream dependencies are set on your Sling assets by passing an instance of the custom <PyObject section="libraries" module="dagster_sling" object="DagsterSlingTranslator" /> to the <PyObject section="libraries" module="dagster_sling" object="sling_assets" /> decorator.\n\n```python\nclass CustomDagsterSlingTranslator(DagsterSlingTranslator):\n    def get_asset_spec(self, stream_definition: Mapping[str, Any]) -> dg.AssetSpec:\n        """Overrides asset spec to override upstream asset key to be a single source asset."""\n        # We create the default asset spec using super()\n        default_spec = super().get_asset_spec(stream_definition)\n        # We set an upstream dependency for our assets\n        return default_spec.replace_attributes(\n            deps=[dg.AssetKey("common_upstream_sling_dependency")],\n        )\n\n\n@sling_assets(\n    replication_config=replication_config,\n    dagster_sling_translator=CustomDagsterSlingTranslator(),\n)\ndef my_sling_assets(context, sling: SlingResource):\n    yield from sling.replicate(context=context)\n```\n\nNote that `super()` is called in each of the overridden methods to generate the default asset spec. It is best practice to generate the default asset spec before customizing it.\n\n### Define downstream dependencies\n\nDagster allows you to define assets that are downstream of specific Sling streams using their asset keys. The asset key for a Sling stream can be retrieved using the <PyObject section="libraries" module="dagster_sling" object="DagsterSlingTranslator" />. The below example defines `my_downstream_asset` as a downstream dependency of `my_sling_stream`:\n\n```python\nfrom dagster_sling.asset_decorator import get_streams_from_replication\n\n\n@sling_assets(\n    replication_config=replication_config,\n)\ndef my_sling_assets(context, sling: SlingResource):\n    yield from sling.replicate(context=context)\n\n\nmy_sling_stream_asset_key = next(\n    iter(\n        [\n            DagsterSlingTranslator().get_asset_spec(stream_definition=stream)\n            for stream in get_streams_from_replication(replication_config)\n            if stream["name"] == "my_sling_stream"\n        ]\n    )\n)\n\n\n@dg.asset(deps=[my_sling_stream_asset_key])\ndef my_downstream_asset(): ...\n```\n\nIn the downstream asset, you may want direct access to the contents of the Sling asset. To do so, you can customize the code within your `@asset`-decorated function to load upstream data.\n\n## APIs in this guide\n\n| Name                                                                                     | Description                                                                            |\n|------------------------------------------------------------------------------------------| -------------------------------------------------------------------------------------- |\n| <PyObject section="libraries" module="dagster_sling" object="sling_assets" decorator />  | The core Sling asset factory for building syncs                                        |\n| <PyObject section="libraries" module="dagster_sling" object="SlingResource" />           | The Sling resource used for handing credentials to databases and object stores         |\n| <PyObject section="libraries" module="dagster_sling" object="DagsterSlingTranslator" />  | A translator for specifying how to map between Sling and Dagster types                 |\n| <PyObject section="libraries" module="dagster_sling" object="SlingConnectionResource" /> | A Sling connection resource for specifying database and storage connection credentials |\n\n\n### About Sling\n\nSling provides an easy-to-use YAML configuration layer for loading data from files, replicating data between databases, exporting custom SQL queries to cloud storage, and much more.\n\n#### Key Features\n\n- **Data Movement**: Transfer data between different storage systems and databases efficiently\n\n- **Flexible Connectivity**: Support for numerous databases, data warehouses, and file storage systems\n\n- **Transformation Capabilities**: Built-in data transformation features during transfer\n\n- **Multiple Operation Modes**: Support for various replication modes including full-refresh, incremental, and snapshot\n\n- **Production-Ready**: Deployable with monitoring, scheduling, and error handling',
  };

  return (
    <Box
      style={{
        width: '1300px',
        height: '100%',
        overflowY: 'auto',
        backgroundColor: Colors.backgroundLight(),
      }}
    >
      <SingleIntegrationPage integration={sling} provider={provider} />
    </Box>
  );
};
