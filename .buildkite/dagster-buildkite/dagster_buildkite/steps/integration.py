import os
from collections.abc import Callable
from typing import Optional

from buildkite_shared.git import ChangedFiles
from buildkite_shared.python_version import AvailablePythonVersion
from buildkite_shared.step_builders.command_step_builder import BuildkiteQueue
from buildkite_shared.step_builders.step_builder import StepConfiguration, TopLevelStepConfiguration
from dagster_buildkite.defines import (
    GCP_CREDS_FILENAME,
    GCP_CREDS_LOCAL_FILE,
    LATEST_DAGSTER_RELEASE,
)
from dagster_buildkite.steps.packages import (
    PackageSpec,
    PytestExtraCommandsFunction,
    UnsupportedVersionsFunction,
)
from dagster_buildkite.steps.test_project import test_project_depends_fn
from dagster_buildkite.steps.tox import ToxFactor
from dagster_buildkite.utils import (
    connect_sibling_docker_container,
    has_helm_changes,
    library_version_from_core_version,
    network_buildkite_container,
)

SCRIPT_PATH = os.path.dirname(os.path.abspath(__file__))
DAGSTER_CURRENT_BRANCH = "current_branch"
EARLIEST_TESTED_RELEASE = "0.12.8"


def build_integration_steps() -> list[StepConfiguration]:
    steps: list[StepConfiguration] = []

    # Shared dependency of some test suites
    steps += PackageSpec(
        os.path.join("integration_tests", "python_modules", "dagster-k8s-test-infra"),
    ).build_steps()

    # test suites
    steps += build_backcompat_suite_steps()
    steps += build_celery_k8s_suite_steps()
    steps += build_k8s_suite_steps()
    steps += build_daemon_suite_steps()
    steps += build_auto_materialize_perf_suite_steps()
    steps += build_azure_live_test_suite_steps()

    return steps


# ########################
# ##### BACKCOMPAT
# ########################


def build_backcompat_suite_steps() -> list[TopLevelStepConfiguration]:
    tox_factors = [
        ToxFactor("user-code-latest-release"),
        ToxFactor("user-code-earliest-release"),
    ]

    return build_integration_suite_steps(
        os.path.join("integration_tests", "test_suites", "backcompat-test-suite"),
        pytest_extra_cmds=backcompat_extra_cmds,
        pytest_tox_factors=tox_factors,
    )


def backcompat_extra_cmds(_, factor: Optional[ToxFactor]) -> list[str]:
    tox_factor_map = {
        "user-code-latest-release": LATEST_DAGSTER_RELEASE,
        "user-code-earliest-release": EARLIEST_TESTED_RELEASE,
    }
    assert factor
    factor_str = factor.factor
    webserver_version = DAGSTER_CURRENT_BRANCH
    webserver_library_version = _get_library_version(webserver_version)
    user_code_version = tox_factor_map[factor_str]
    user_code_library_version = _get_library_version(user_code_version)
    user_code_definitions_file = _infer_user_code_definitions_files(user_code_version)

    return [
        f"export EARLIEST_TESTED_RELEASE={EARLIEST_TESTED_RELEASE}",
        f"export USER_CODE_DEFINITIONS_FILE={user_code_definitions_file}",
        "pushd integration_tests/test_suites/backcompat-test-suite/webserver_service",
        " ".join(
            [
                "./build.sh",
                webserver_version,
                webserver_library_version,
                user_code_version,
                user_code_library_version,
                user_code_definitions_file,
            ]
        ),
        "docker-compose up -d --remove-orphans",  # clean up in hooks/pre-exit
        *network_buildkite_container("webserver_service_network"),
        *connect_sibling_docker_container(
            "webserver_service_network",
            "dagster_webserver",
            "BACKCOMPAT_TESTS_WEBSERVER_HOST",
        ),
        "popd",
    ]


def _infer_user_code_definitions_files(user_code_release: str) -> str:
    """Returns the definitions file to use for the user code release."""
    if user_code_release == EARLIEST_TESTED_RELEASE:
        return "defs_for_earliest_tested_release.py"
    else:
        return "defs_for_latest_release.py"


def _get_library_version(version: str) -> str:
    if version == DAGSTER_CURRENT_BRANCH:
        return DAGSTER_CURRENT_BRANCH
    else:
        return library_version_from_core_version(version)


# ########################
# ##### CELERY K8S
# ########################


def build_celery_k8s_suite_steps() -> list[TopLevelStepConfiguration]:
    pytest_tox_factors = [
        ToxFactor("-default"),
        ToxFactor("-markredis"),
    ]
    directory = os.path.join("integration_tests", "test_suites", "celery-k8s-test-suite")
    return build_integration_suite_steps(
        directory,
        pytest_tox_factors,
        queue=BuildkiteQueue.DOCKER,  # crashes on python 3.11/3.12 without additional resources
        always_run_if=has_helm_changes,
        pytest_extra_cmds=celery_k8s_integration_suite_pytest_extra_cmds,
    )


# ########################
# ##### DAEMON
# ########################


def build_daemon_suite_steps():
    pytest_tox_factors = None
    directory = os.path.join("integration_tests", "test_suites", "daemon-test-suite")
    return build_integration_suite_steps(
        directory,
        pytest_tox_factors,
        pytest_extra_cmds=daemon_pytest_extra_cmds,
    )


def build_auto_materialize_perf_suite_steps():
    pytest_tox_factors = None
    directory = os.path.join("integration_tests", "test_suites", "auto_materialize_perf_tests")
    return build_integration_suite_steps(
        directory,
        pytest_tox_factors,
        unsupported_python_versions=[
            version
            for version in AvailablePythonVersion.get_all()
            if version != AvailablePythonVersion.V3_12
        ],
    )


def skip_if_not_azure_commit():
    """If no dagster-azure files are changed, skip the azure live tests."""
    return (
        None
        if (any("dagster-azure" in str(path) for path in ChangedFiles.all_oss))
        else "Not a dagster-azure commit"
    )


def skip_if_not_gcp_commit():
    """If no dagster-gcp files are changed, skip the gcp live tests."""
    return (
        None
        if (any("dagster-gcp" in str(path) for path in ChangedFiles.all_oss))
        else "Not a dagster-gcp commit"
    )


def build_azure_live_test_suite_steps() -> list[TopLevelStepConfiguration]:
    return PackageSpec(
        os.path.join("integration_tests", "test_suites", "dagster-azure-live-tests"),
        skip_if=skip_if_not_azure_commit,
        env_vars=[
            "TEST_AZURE_TENANT_ID",
            "TEST_AZURE_CLIENT_ID",
            "TEST_AZURE_CLIENT_SECRET",
            "TEST_AZURE_STORAGE_ACCOUNT_ID",
            "TEST_AZURE_CONTAINER_ID",
            "TEST_AZURE_ACCESS_KEY",
        ],
    ).build_steps()


def daemon_pytest_extra_cmds(version: AvailablePythonVersion, _):
    return [
        "export DAGSTER_DOCKER_IMAGE_TAG=$${BUILDKITE_BUILD_ID}-" + version.value,
        'export DAGSTER_DOCKER_REPOSITORY="$${AWS_ACCOUNT_ID}.dkr.ecr.us-west-2.amazonaws.com"',
    ]


# ########################
# ##### K8S
# ########################


def build_k8s_suite_steps() -> list[TopLevelStepConfiguration]:
    pytest_tox_factors = [
        ToxFactor("-default", splits=2),
        ToxFactor("-subchart", splits=2),
        ToxFactor("-default_monitoring"),
        ToxFactor("-subchart_monitoring"),
    ]
    directory = os.path.join("integration_tests", "test_suites", "k8s-test-suite")
    return build_integration_suite_steps(
        directory,
        pytest_tox_factors,
        always_run_if=has_helm_changes,
        pytest_extra_cmds=k8s_integration_suite_pytest_extra_cmds,
        queue=BuildkiteQueue.DOCKER,
    )


# ########################
# ##### UTILITIES
# ########################


def build_integration_suite_steps(
    directory: str,
    pytest_tox_factors: Optional[list[ToxFactor]],
    pytest_extra_cmds: Optional[PytestExtraCommandsFunction] = None,
    queue=None,
    always_run_if: Optional[Callable[[], bool]] = None,
    unsupported_python_versions: Optional[
        list[AvailablePythonVersion] | UnsupportedVersionsFunction
    ] = None,
) -> list[TopLevelStepConfiguration]:
    return PackageSpec(
        directory,
        env_vars=[
            "AIRFLOW_HOME",
            "AWS_ACCOUNT_ID",
            "AWS_ACCESS_KEY_ID",
            "AWS_SECRET_ACCESS_KEY",
            "BUILDKITE_SECRETS_BUCKET",
            "GOOGLE_APPLICATION_CREDENTIALS",
        ],
        pytest_extra_cmds=pytest_extra_cmds,
        pytest_step_dependencies=test_project_depends_fn,
        pytest_tox_factors=pytest_tox_factors,
        retries=2,
        timeout_in_minutes=30,
        queue=queue,
        always_run_if=always_run_if,
        unsupported_python_versions=unsupported_python_versions,
    ).build_steps()


def k8s_integration_suite_pytest_extra_cmds(version: AvailablePythonVersion, _) -> list[str]:
    return [
        "export DOCKER_API_VERSION=1.41",
        "export DAGSTER_DOCKER_IMAGE_TAG=$${BUILDKITE_BUILD_ID}-" + version.value,
        'export DAGSTER_DOCKER_REPOSITORY="$${AWS_ACCOUNT_ID}.dkr.ecr.us-west-2.amazonaws.com"',
        "aws ecr get-login --no-include-email --region us-west-2 | sh",
    ]


def celery_k8s_integration_suite_pytest_extra_cmds(version: AvailablePythonVersion, _) -> list[str]:
    cmds = [
        "export DOCKER_API_VERSION=1.41",
        'export AIRFLOW_HOME="/airflow"',
        "mkdir -p $${AIRFLOW_HOME}",
        "export DAGSTER_DOCKER_IMAGE_TAG=$${BUILDKITE_BUILD_ID}-" + version.value,
        'export DAGSTER_DOCKER_REPOSITORY="$${AWS_ACCOUNT_ID}.dkr.ecr.us-west-2.amazonaws.com"',
        "aws ecr get-login --no-include-email --region us-west-2 | sh",
    ]

    # If integration tests are disabled, we won't have any gcp credentials to download.
    if not os.getenv("CI_DISABLE_INTEGRATION_TESTS"):
        cmds += [
            rf"aws s3 cp s3://\${{BUILDKITE_SECRETS_BUCKET}}/{GCP_CREDS_FILENAME} "
            + GCP_CREDS_LOCAL_FILE,
            "export GOOGLE_APPLICATION_CREDENTIALS=" + GCP_CREDS_LOCAL_FILE,
        ]

    cmds += [
        "pushd python_modules/libraries/dagster-celery",
        # Run the rabbitmq db. We are in docker running docker
        # so this will be a sibling container.
        "docker-compose up -d --remove-orphans",  # clean up in hooks/pre-exit,
        # Can't use host networking on buildkite and communicate via localhost
        # between these sibling containers, so pass along the ip.
        *network_buildkite_container("rabbitmq"),
        *connect_sibling_docker_container(
            "rabbitmq", "test-rabbitmq", "DAGSTER_CELERY_BROKER_HOST"
        ),
        "popd",
    ]

    return cmds
