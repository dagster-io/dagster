import os
import re
import subprocess
from collections.abc import Sequence
from pathlib import Path
from typing import Optional, Union

# https://stackoverflow.com/a/14693789
ANSI_ESCAPE = re.compile(
    r"""
    \x1B  # ESC
    (?:   # 7-bit C1 Fe (except CSI)
        [@-Z\\-_]
    |     # or [ for CSI, followed by a control sequence
        \[
        [0-?]*  # Parameter bytes
        [ -/]*  # Intermediate bytes
        [@-~]   # Final byte
    )
""",
    re.VERBOSE,
)


def snippet_to_regex_fn(snippet: str) -> str:
    """Convert a snippet to a regex that matches the snippet, treating
    `...` as a wildcard.
    """
    return re.escape(snippet).replace(r"\.\.\.", ".*")


def re_ignore_before(match_str: str) -> tuple[str, str]:
    """Generates a regex substitution pair that replaces any text before `match_str` with
    an ellipses.
    """
    return (rf"[\s\S]*{re.escape(match_str)}", f"...\n{match_str}")


def re_ignore_after(match_str: str) -> tuple[str, str]:
    """Generates a regex substitution pair that replaces any text after `match_str` with
    an ellipses.
    """
    return (rf"{re.escape(match_str)}[\s\S]*", f"{match_str}\n...")


def _run_command(
    cmd: Union[str, Sequence[str]],
) -> str:
    if not isinstance(cmd, str):
        cmd = " ".join(cmd)

    actual_output = (
        subprocess.check_output(
            f'{cmd}; echo "PWD=$(pwd)"', shell=True, stderr=subprocess.STDOUT
        )
        .decode("utf-8")
        .strip()
    )

    actual_output, pwd = actual_output.split("PWD=")
    os.chdir(pwd)

    actual_output = ANSI_ESCAPE.sub("", actual_output)
    return actual_output


def _assert_matches_or_update_snippet(
    contents: str,
    snippet_path: Path,
    update_snippets: bool,
    snippet_replace_regex: Optional[Sequence[tuple[str, str]]],
):
    if snippet_replace_regex:
        for regex, replacement in snippet_replace_regex:
            contents = re.sub(regex, replacement, contents, re.MULTILINE | re.DOTALL)

    snippet_output_file = Path(snippet_path)
    snippet_output_file.parent.mkdir(parents=True, exist_ok=True)

    if update_snippets:
        snippet_output_file.write_text(f"{contents.rstrip()}\n")
        print(f"Updated snippet at {snippet_path}")  # noqa: T201
    else:
        if not snippet_output_file.exists():
            raise Exception(f"Snippet at {snippet_path} does not exist")

        contents = contents.rstrip()
        snippet_contents = snippet_output_file.read_text().rstrip()
        if not snippet_contents == contents:
            print(f"Snapshot mismatch {snippet_path}")  # noqa: T201
            print("\nActual file:")  # noqa: T201
            print(contents)  # noqa: T201
            print("\n\nExpected file:")  # noqa: T201
            print(snippet_contents)  # noqa: T201
        else:
            print(f"Snippet {snippet_path} passed")  # noqa: T201

        assert (
            snippet_contents == contents
        ), "CLI snippets do not match.\nYou may need to run make regenerate_cli_snippets in the `dagster/docs` directory."


def create_file(
    file_path: Union[Path, str],
    contents: str,
    snippet_path: Optional[Path] = None,
):
    """Create a file with the given contents. If `snippet_path` is provided, outputs
    the contents to the snippet file too.

    Used for steps where the user is expected to create a file.

    Args:
        file_path (Union[Path, str]): The path to the file to create.
        contents (str): The contents to write to the file.
        snippet_path (Optional[Path]): The path to the snippet file to update.
    """
    file_path = Path(file_path)
    file_path.parent.mkdir(parents=True, exist_ok=True)

    file_path.write_text(contents)
    if snippet_path:
        _assert_matches_or_update_snippet(
            contents=contents,
            snippet_path=snippet_path,
            update_snippets=True,
            snippet_replace_regex=None,
        )


def check_file(
    file_path: Union[Path, str],
    snippet_path: Optional[Path] = None,
    update_snippets: Optional[bool] = None,
    snippet_replace_regex: Optional[Sequence[tuple[str, str]]] = None,
):
    """Check that the contents of the file at `file_path` match the contents of the snippet
    at `snippet_path`. If `update_snippets` is `True`, updates the snippet file with the
    contents of the file.

    Used for steps where we want to show the user the contents of a file (e.g. one that's
    generated by the framework, or by output).

    Args:
        file_path (Union[Path, str]): The path to the file to check.
        snippet_path (Optional[Path]): The path to the snippet file to check/update.
        update_snippets (Optional[bool]): Whether to update the snippet file with the file contents.
        snippet_replace_regex (Optional[Sequence[tuple[str, str]]]): A list of regex
            substitution pairs to apply to the file contents before checking it against the snippet.
            Useful to remove dynamic content, e.g. the temporary directory path or timestamps.
    """
    file_path = Path(file_path)
    assert file_path.exists()
    contents = file_path.read_text()

    if snippet_path:
        assert update_snippets is not None

        _assert_matches_or_update_snippet(
            contents=contents,
            snippet_path=snippet_path,
            update_snippets=update_snippets,
            snippet_replace_regex=snippet_replace_regex,
        )


def run_command_and_snippet_output(
    cmd: Union[str, Sequence[str]],
    snippet_path: Optional[Path] = None,
    update_snippets: Optional[bool] = None,
    snippet_replace_regex: Optional[Sequence[tuple[str, str]]] = None,
    ignore_output: bool = False,
):
    """Run the given command and check that the output matches the contents of the snippet
    at `snippet_path`. If `update_snippets` is `True`, updates the snippet file with the
    output of the command.

    Args:
        cmd (Union[str, Sequence[str]): The command to run.
        snippet_path (Optional[Path]): The path to the snippet file to check/update.
        update_snippets (Optional[bool]): Whether to update the snippet file with the output.
        snippet_replace_regex (Optional[Sequence[tuple[str, str]]]): A list of regex
            substitution pairs to apply to the output before checking it against the snippet.
            Useful to remove dynamic content, e.g. the temporary directory path or timestamps.
        ignore_output (bool): Whether to ignore the output of the command when updating the snippet.
            Useful when the output is too verbose or not meaningful.
    """
    assert update_snippets is not None or snippet_path is None

    output = _run_command(cmd)

    if snippet_path:
        assert update_snippets is not None

        if ignore_output:
            contents = f"$ {cmd}"
        else:
            contents = f"$ {cmd}\n\n{output}"

        _assert_matches_or_update_snippet(
            contents=contents,
            snippet_path=snippet_path,
            update_snippets=update_snippets,
            snippet_replace_regex=snippet_replace_regex,
        )
