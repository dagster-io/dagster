---
title: Concepts | Dagster Docs
---

# Concepts

Learn about Dagster's core concepts and how to use them in your data platform.

---

## Software-defined assets

An asset is an object in persistent storage, such as a table, file, or persisted machine learning model. A software-defined asset is a Dagster object that couples an asset to the function and upstream assets used to produce its contents.

<ArticleList>
  <ArticleListItem
    title="Software-defined assets"
    href="/concepts/assets/software-defined-assets"
  ></ArticleListItem>
  <ArticleListItem
    title="Asset materializations"
    href="/concepts/assets/asset-materializations"
  ></ArticleListItem>
  <ArticleListItem
    title="Asset observations"
    href="/concepts/assets/asset-observations"
  ></ArticleListItem>
  <ArticleListItem
    title="Multi-assets"
    href="/concepts/assets/multi-assets"
  ></ArticleListItem>
  <ArticleListItem
    title="Asset selection syntax"
    href="/concepts/assets/asset-selection-syntax"
  ></ArticleListItem>
</ArticleList>

---

## Ops

Ops are the core unit of computation in Dagster. They typically perform relatively simple tasks, such as executing a database query or sending a Slack message.

<ArticleList>
  <ArticleListItem
    title="Ops"
    href="/concepts/ops-jobs-graphs/ops"
  ></ArticleListItem>
  <ArticleListItem
    title="Op events"
    href="/concepts/ops-jobs-graphs/op-events"
  ></ArticleListItem>
  <ArticleListItem
    title="Op hooks"
    href="/concepts/ops-jobs-graphs/op-hooks"
  ></ArticleListItem>
  <ArticleListItem
    title="Op retries"
    href="/concepts/ops-jobs-graphs/op-retries"
  ></ArticleListItem>
</ArticleList>

---

## Graphs

A graph is a set of interconnected ops or sub-graphs. While individual ops typically perform simple tasks, ops can be assembled into a graph to accomplish complex tasks.

<ArticleList>
  <ArticleListItem
    title="Graphs"
    href="/concepts/ops-jobs-graphs/graphs"
  ></ArticleListItem>
  <ArticleListItem
    title="Nesting graphs"
    href="/concepts/ops-jobs-graphs/nesting-graphs"
  ></ArticleListItem>
  <ArticleListItem
    title="Dynamic graphs"
    href="/concepts/ops-jobs-graphs/dynamic-graphs"
  ></ArticleListItem>
</ArticleList>

---

## Jobs

Jobs are the main unit of execution and monitoring in Dagster. The core of a job is a graph of ops connected via data dependencies.

<ArticleList>
  <ArticleListItem
    title="Jobs"
    href="/concepts/ops-jobs-graphs/jobs"
  ></ArticleListItem>
  <ArticleListItem
    title="Job execution"
    href="/concepts/ops-jobs-graphs/job-execution"
  ></ArticleListItem>
  <ArticleListItem
    title="Metadata and tags"
    href="/concepts/ops-jobs-graphs/metadata-tags"
  ></ArticleListItem>
</ArticleList>

---

## Schedules and sensors

Schedules launch runs on a fixed interval, while sensors allow you to do so based on an external state change.

<ArticleList>
  <ArticleListItem
    title="Schedules"
    href="/concepts/partitions-schedules-sensors/schedules"
  ></ArticleListItem>
  <ArticleListItem
    title="Sensors"
    href="/concepts/partitions-schedules-sensors/sensors"
  ></ArticleListItem>
</ArticleList>

---

## Partitions and backfills

A software-defined asset or job can represent a collection of _partitions_ that can be tracked and executed independently.

<ArticleList>
  <ArticleListItem
    title="Partitions"
    href="/concepts/partitions-schedules-sensors/partitions"
  ></ArticleListItem>
  <ArticleListItem
    title="Backfills"
    href="/concepts/partitions-schedules-sensors/backfills"
  ></ArticleListItem>
</ArticleList>

---

## I/O management

IO Managers are user-provided objects that store asset and op outputs and load them as inputs to downstream assets and ops.

<ArticleList>
  <ArticleListItem
    title="I/O managers"
    href="/concepts/io-management/io-managers"
  ></ArticleListItem>
  <ArticleListItem
    title="Unconnected inputs"
    href="/concepts/io-management/unconnected-inputs"
  ></ArticleListItem>
</ArticleList>

---

## Configuration

Dagster provides a configuration system that allows you to document, schematize, and error-check your configuration.

<ArticleList>
  <ArticleListItem
    title="Run configuration"
    href="/concepts/configuration/config-schema"
  ></ArticleListItem>
  <ArticleListItem
    title="Definition-time configuration"
    href="/concepts/configuration/configured"
  ></ArticleListItem>
</ArticleList>

---

## Code locations

A code location is a collection of Dagster definitions, including assets, jobs, schedules, sensors, and resources. Dagster tools like Dagit and the Dagster CLI use code locations to load your code.

[Learn more about code locations](/concepts/code-locations).

---

## Resources

Resources enable you to separate logic from external dependencies, making developing and testing possible in multiple environments.

[Learn more about resources](/concepts/resources).

---

## Dagit

Dagit is a web-based interface for viewing and interacting with Dagster objects.

[Learn more about Dagit](/concepts/dagit/dagit).

---

## GraphQL API

The GraphQL API allows you to interact programmatically with Dagster.

<ArticleList>
  <ArticleListItem
    title="GraphQL API"
    href="/concepts/dagit/graphql"
  ></ArticleListItem>
  <ArticleListItem
    title="GraphQL Python client"
    href="/concepts/dagit/graphql-client"
  ></ArticleListItem>
</ArticleList>

---

## Dagster types

The Dagster type system provides gradual, opt-in typing for the inputs and outputs of assets and ops.

[Learn more about Dagster types](/concepts/types).

---

## Logging

A rich, extensible logging system, Dagster's built-in logger tracks all execution events. Loggers can also be customized to fit your infrastructure.

<ArticleList>
  <ArticleListItem
    title="Loggers"
    href="/concepts/logging/loggers"
  ></ArticleListItem>
  <ArticleListItem
    title="Python logging"
    href="/concepts/logging/python-logging"
  ></ArticleListItem>
</ArticleList>

---

## Testing

Dagster enables you to build testable and maintainable data applications. It provides ways to allow you unit-test your data applications, separate business logic from environments, and set explicit expectations on uncontrollable inputs.

[Learn more about testing](/concepts/testing).
