import PyObject from 'components/PyObject';

### Parametrizing Solids with Config

Solids often depend in predictable ways on features of the external world or
the pipeline in which they're invoked. For example, consider an extended
version of our csv-reading solid that implements more of the options available
in the underlying Python API:

```python literalinclude showLines startLine=7 emphasize-lines=9-15 caption=config_bad_1.py
file:/dagster_examples/intro_tutorial/basics/e02_solids/config_bad_1.py
lines:7-29
```

We obviously don't want to have to write a separate solid for each permutation
of these parameters that we use in our pipelines â€” especially because, in
more realistic cases like configuring a Spark job or even parametrizing the
`read_csv` function from a popular package like [Pandas](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv), we
might have dozens or hundreds of parameters like these.

But hoisting all of these parameters into the signature of the solid function
as inputs isn't the right answer either:

```python literalinclude showLines startLine=7 emphasize-lines=5-11 caption=config_bad_2.py
file:/dagster_examples/intro_tutorial/basics/e02_solids/config_bad_2.py
lines:7-39
```

Defaults are often sufficient for configuation values like these, and sets of
parameters are often reusable. And it's unlikely that values like this will be
provided dynamically by the outputs of other solids in a pipeline.

Inputs, on the other hand, will usually be provided by the outputs of other
solids in a pipeline, even though we might sometimes want to stub them using
the config facility.

For all these reasons, it's bad practice to mix configuration values like
these with true input values.

The solution is to define a config schema for our solid:

```python literalinclude showLines startLine=1 emphasize-lines=16,34-42,89 caption=config.py
file:/dagster_examples/intro_tutorial/basics/e02_solids/config.py
lines:1-102
```

First, we pass the `config` argument to the <PyObject module="dagster" object="solid" displayText="@solid" /> decorator.
This tells Dagster to give our solid a config field structured
as a dictionary, whose keys are the keys of this argument, and the types of whose
values are defined by the values of this argument (instances of <PyObject module="dagster" object="Field" />).

Then, we define one of these fields, `escapechar`, to be a string,
setting a default value, making it optional, and setting a human-readable
description.

Finally, inside the body of the solid function, we access the config value set
by the user using the `solid_config` field on the familiar <PyObject module="dagster" object="SystemComputeExecutionContext" displayText="context" /> object. When Dagster
executes our pipeline, the framework will make validated config for each solid available on this object.

Let's see how all of this looks in dagit. As usual, run:

```bash
$ dagit -f config.py -n config_pipeline
```

![config_figure_one.png](/assets/images/tutorial/config_figure_one.png)

As you may by now expect, Dagit provides a fully type-aware and schema-aware
config editing environment with a typeahead. The human-readable descriptions
we provided on our config fields appear in the config context minimap, as well
as in typeahead tooltips and in the Explore pane when clicking into the
individual solid definition.

![config_figure_two.png](/assets/images/tutorial/config_figure_two.png)

You can see that we've added a new section to the solid config. In addition to
the `inputs` section, which we'll still use to set the `csv_path` input, we now have a `config`
section, where we can set values defined in the `config` argument to <PyObject module="dagster" object="solid" displayText="@solid" />.

```YAML literalinclude caption=config_env_bad.yaml
file:/dagster_examples/intro_tutorial/basics/e02_solids/config_env_bad.yaml
```

Of course, this config won't give us the results we're expecting. The values
in `cereal.csv` are comma-separated, not semicolon-separated, as
they might be if this were a .csv from Europe, where commas are frequently
used in place of the decimal point.

We'll see later how we can use Dagster's facilities for automatic data quality
checks to guard against semantic issues like this, which won't be caught by
the type system.
