import PyObject from 'components/PyObject';

# Testing solids and pipelines

Our first solid and pipeline wouldn't be complete without some tests to
ensure they're working as expected. We'll use <PyObject module="dagster" object="execute_pipeline" displayText="execute_pipeline()" /> to test our
pipeline, as well as <PyObject module="dagster" object="execute_solid" displayText="execute_solid()" /> to test our solid in isolation.

These functions synchronously execute a pipeline or solid and return
results objects (the <PyObject module="dagster" object="SolidExecutionResult" /> and <PyObject module="dagster" object="PipelineExecutionResult" /> whose
methods let us investigate, in detail, the success or failure of execution, the outputs produced by solids, and (as we'll
see later) other events associated with execution.

```python literalinclude startLine=31
file:/intro_tutorial/hello_cereal.py
caption:hello_cereal.py
lines:31-40
```

Now you can use pytest, or your test runner of choice, to run unit tests
as you develop your data applications.

```bash
$ pytest hello_cereal.py
```

Note: pytest tests are typically in files prefixed with
**`test_`**. However in order to simplify the tutorial we have
them in the same file.

Obviously, in production we'll often execute pipelines in a parallel,
streaming way that doesn't admit this kind of API, which is intended to
enable local tests like this.

Dagster is written to make testing easy in a domain where it has
historically been very difficult. Throughout the rest of this tutorial,
we'll explore the writing of unit tests for each piece of the framework
as we learn about it.
