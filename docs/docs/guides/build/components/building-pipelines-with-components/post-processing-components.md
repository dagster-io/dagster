---
description: Post-process components to modify definitions after they are generated.
sidebar_position: 400
title: Post-processing components
---

It is often useful to make modifications to the definitions generated by a
component without needing to modify the component logic. Dagster provides a
generic mechanism for this called **post-processing**.

Post-processing is available on all components. To add post-processing to a
component instance, add a `post_process` field in `defs.yaml`.

:::note

Currently post-processing is only supported for the assets, not other
definitions.

:::

## Setup

Let's look at a simple example using the <PyObject module="dagster" section="components" object="DefsFolderComponent" />. `DefsFolderComponent`
simply loads all definitions from a specified folder.

Starting from a [blank project](/guides/build/projects/creating-a-new-project), let's scaffold a `DefsFolderComponent` called
`my_assets`:

<CliInvocationExample path="docs_snippets/docs_snippets/guides/components/post-processing-components/generated/1-dg-scaffold-defs-my-assets.txt" />

We now have a directory `my_project/defs/my_assets` with a single file,
`defs.yaml`:

<CodeExample
  path="docs_snippets/docs_snippets/guides/components/post-processing-components/generated/2-my-assets-defs-1.yaml"
  language="yaml"
  title="src/my_project/defs/my_assets/defs.yaml"
/>


Let's add some assets. We'll create two files
`my_project/defs/my_assets/foo.py` and `my_project/defs/my_assets/bar.py`, each
containing a single asset:

<Tabs>
    <TabItem value="foo" label="foo.py">
    <CodeExample
      path="docs_snippets/docs_snippets/guides/components/post-processing-components/foo.py"
      language="python"
      title="src/my_project/defs/my_assets/foo.py"
    />
    </TabItem>
    <TabItem value="bar" label="bar.py">
    <CodeExample
      path="docs_snippets/docs_snippets/guides/components/post-processing-components/bar.py"
      language="python"
      title="src/my_project/defs/my_assets/bar.py"
    />
</TabItem>
</Tabs>

Let's run `dg list defs` to see our assets:

<CliInvocationExample path="docs_snippets/docs_snippets/guides/components/post-processing-components/generated/3-dg-list-defs-1.txt" />

## Example 1: Adding kind tags to assets

Now suppose we want to add a [compute kind](/guides/build/assets/metadata-and-tags/kind-tags) to every asset defined in this folder.
We could do this by manually adding the kind on each asset declaration or by using
a factory. However, component post-processing provides a simpler solution. We
modify our `defs.yaml` to add a `post_processing` field that specifies the
kind:

<CodeExample
  path="docs_snippets/docs_snippets/guides/components/post-processing-components/my-assets-defs-2.yaml"
  language="yaml"
  title="src/my_project/defs/my_assets/defs.yaml"
/>

Let's break down the structure of the value we set for `post_processing`. The
top-level key, `assets`, is currently the only supported key. `assets` holds a
list of asset post-processors. Each post-processor transforms a set of asset
attributes and applies to a subset of all of the assets generated by the
component. In this case, we have a single post-processor with no defined
subset, which means the specified transformation is applied to all assets.

Let's run `dg list defs` again to see the result:

<CliInvocationExample path="docs_snippets/docs_snippets/guides/components/post-processing-components/generated/4-dg-list-defs-2.txt" />

You can see that both assets now have the `kind` we defined in our
`post_processing` field.

##  Example 2: Assigning assets to different groups

Adding a `kind` isn't the only thing we can do. The full schema for
`attributes` contains many other fields:

<details>
<CodeExample
  path="docs_snippets/docs_snippets/guides/components/post-processing-components/attr_json_schema.json"
  language="json"
  title="JSON Schema for asset attributes"
/>
</details>

Let's change our `defs.yaml` to assign `foo` and `bar` to different groups. To
do this, we'll add two more two post-processors, each with a separate `target`
argument to specify which assets they apply to:

<CodeExample
  path="docs_snippets/docs_snippets/guides/components/post-processing-components/my-assets-defs-3.yaml"
  language="yaml"
  title="src/my_project/defs/my_assets/defs.yaml"
/>

:::note

The `target` field supports the full Dagster [asset selection syntax](/guides/build/assets/asset-selection-syntax/reference).

:::

Now if we run `dg list defs` again, we can see that the assets are in different
groups:

<CliInvocationExample path="docs_snippets/docs_snippets/guides/components/post-processing-components/generated/5-dg-list-defs-3.txt" />

There are many other possibilities. Post-processors are a flexible and
convenient way to efficiently specify the properties of large sets of assets.
