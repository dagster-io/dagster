---
title: 'assets'
title_meta: 'assets API Documentation - Build Better Data Pipelines | Python Reference Documentation for Dagster'
description: 'assets Dagster API | Comprehensive Python API documentation for Dagster, the data orchestration platform. Learn how to build, test, and maintain data pipelines with our detailed guides and examples.'
last_update:
  date: '2025-03-03'
---

<div class="section" id="assets">


# Assets

An asset is an object in persistent storage, such as a table, file, or persisted machine learning model. An asset definition is a description, in code, of an asset that should exist and how to produce and update that asset.

<div class="section" id="asset-definitions">


## Asset definitions

Refer to the [Asset definitions](https://docs.dagster.io/guides/build/assets/defining-assets) documentation for more information.

<dl>
    <dt><Link id='dagster.asset'>@dagster.asset</Link></dt>
    <dd>

    Create a definition for how to compute an asset.

    A software-defined asset is the combination of:
        1. An asset key, e.g. the name of a table.
        2. A function, which can be run to compute the contents of the asset.
        3. A set of upstream assets that are provided as inputs to the function when computing the asset.
    Unlike an op, whose dependencies are determined by the graph it lives inside, an asset knows
    about the upstream assets it depends on. The upstream assets are inferred from the arguments
    to the decorated function. The name of the argument designates the name of the upstream asset.

    An asset has an op inside it to represent the function that computes it. The name of the op
    will be the segments of the asset key, separated by double-underscores.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the asset.  If not provided, defaults to the name of the decorated function. The asset’s name must be a valid name in dagster (ie only contains letters, numbers, and _) and may not contain python reserved keywords.
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, the asset’s key is the concatenation of the key_prefix and the asset’s name, which defaults to the name of the decorated function. Each item in key_prefix must be a valid name in dagster (ie only contains letters, numbers, and _) and may not contain python reserved keywords.
      - <strong>ins</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetIn*](#dagster.AssetIn)<em>]</em><em>]</em>) – A dictionary that maps input names to information about the input.
      - <strong>deps</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>Union</em><em>[</em>[*AssetDep*](#dagster.AssetDep)<em>, </em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*SourceAsset*](#dagster.SourceAsset)<em>, </em>[*AssetKey*](#dagster.AssetKey)<em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – The assets that are upstream dependencies, but do not correspond to a parameter of the decorated function. If the AssetsDefinition for a multi_asset is provided, dependencies on all assets created by the multi_asset will be created.
      - <strong>config_schema</strong> (<em>Optional</em><em>[</em>[*ConfigSchema*](config.mdx#dagster.ConfigSchema)) – The configuration schema for the asset’s underlying op. If set, Dagster will check that config provided for the op matches this schema and fail if it does not. If not set, Dagster will accept any config provided for the op.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dict of metadata entries for the asset.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Tags for filtering and organizing. These tags are not attached to runs of the asset.
      - <strong>required_resource_keys</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – Set of resource handles required by the op.
      - <strong>io_manager_key</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The resource key of the IOManager used for storing the output of the op as an asset, and for loading it in downstream ops (default: “io_manager”). Only one of io_manager_key and io_manager_def can be provided.
      - <strong>io_manager_def</strong> (<em>Optional</em><em>[</em><em>object</em><em>]</em>) – <span className="flag flag-warning">beta</span>  (Beta) The IOManager used for storing the output of the op as an asset,  and for loading it in downstream ops. Only one of io_manager_def and io_manager_key can be provided.
      - <strong>dagster_type</strong> (<em>Optional</em><em>[</em>[*DagsterType*](types.mdx#dagster.DagsterType)<em>]</em>) – Allows specifying type validation functions that will be executed on the output of the decorated function after it runs.
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that compose the asset.
      - <strong>op_tags</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dictionary of tags for the op that computes the asset. Frameworks may expect and require certain metadata to be attached to a op. Values that are not strings will be json encoded and must meet the criteria that <cite>json.loads(json.dumps(value)) == value</cite>.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. If not provided, the name “default” is used.
      - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – <span className="flag flag-warning">beta</span>  (Beta) A mapping of resource keys to resources. These resources will be initialized during execution, and can be accessed from the context within the body of the function.
      - <strong>output_required</strong> (<em>bool</em>) – Whether the decorated function will always materialize an asset. Defaults to True. If False, the function can conditionally not <cite>yield</cite> a result. If no result is yielded, no output will be materialized to storage and downstream assets will not be materialized. Note that for <cite>output_required</cite> to work at all, you must use <cite>yield</cite> in your asset logic rather than <cite>return</cite>. <cite>return</cite> will not respect this setting and will always produce an asset materialization, even if <cite>None</cite> is returned.
      - <strong>automation_condition</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – A condition describing when Dagster should materialize this asset.
      - <strong>backfill_policy</strong> ([*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)) – <span className="flag flag-warning">beta</span>  (Beta) Configure Dagster to backfill this asset according to its BackfillPolicy.
      - <strong>retry_policy</strong> (<em>Optional</em><em>[</em>[*RetryPolicy*](ops.mdx#dagster.RetryPolicy)<em>]</em>) – The retry policy for the op that computes the asset.
      - <strong>code_version</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Version of the code that generates this asset. In general, versions should be set only for code that deterministically produces the same output when given the same inputs.
      - <strong>check_specs</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetCheckSpec*](asset-checks.mdx#dagster.AssetCheckSpec)<em>]</em><em>]</em>) – Specs for asset checks that execute in the decorated function after materializing the asset.
      - <strong>key</strong> (<em>Optional</em><em>[</em><em>CoeercibleToAssetKey</em><em>]</em>) – The key for this asset. If provided, cannot specify key_prefix or name.
      - <strong>owners</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A list of strings representing owners of the asset. Each string can be a user’s email address, or a team name prefixed with <cite>team:</cite>, e.g. <cite>team:finops</cite>.
      - <strong>kinds</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A list of strings representing the kinds of the asset. These will be made visible in the Dagster UI.
      - <strong>pool</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string that identifies the concurrency pool that governs this asset’s execution.
      - <strong>non_argument_deps</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Set</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>, </em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – <span className="flag flag-danger">deprecated</span>  Deprecated, use deps instead. Set of asset keys that are upstream dependencies, but do not pass an input to the asset. Hidden parameter not exposed in the decorator signature, but passed in kwargs.


    Examples:

        ```python
        @asset
        def my_upstream_asset() -> int:
            return 5

        @asset
        def my_asset(my_upstream_asset: int) -> int:
            return my_upstream_asset + 1

        should_materialize = True

        @asset(output_required=False)
        def conditional_asset():
            if should_materialize:
                yield Output(5)  # you must `yield`, not `return`, the result

        # Will also only materialize if `should_materialize` is `True`
        @asset
        def downstream_asset(conditional_asset):
            return conditional_asset + 1
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.MaterializeResult'>`class` dagster.MaterializeResult</Link></dt>
    <dd>

    An object representing a successful materialization of an asset. These can be returned from
    @asset and @multi_asset decorated functions to pass metadata or specify specific assets were
    materialized.

    Parameters: 
      - <strong>asset_key</strong> (<em>Optional</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em>) – Optional in @asset, required in @multi_asset to discern which asset this refers to.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>RawMetadataMapping</em><em>]</em>) – Metadata to record with the corresponding AssetMaterialization event.
      - <strong>check_results</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetCheckResult*](asset-checks.mdx#dagster.AssetCheckResult)<em>]</em><em>]</em>) – Check results to record with the corresponding AssetMaterialization event.
      - <strong>data_version</strong> (<em>Optional</em><em>[</em><em>DataVersion</em><em>]</em>) – The data version of the asset that was observed.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Tags to record with the corresponding AssetMaterialization event.



    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetSpec'>`class` dagster.AssetSpec</Link></dt>
    <dd>

    Specifies the core attributes of an asset, except for the function that materializes or
    observes it.

    An asset spec plus any materialization or observation function for the asset constitutes an
    “asset definition”.

    Parameters: 
      - <strong>key</strong> ([*AssetKey*](#dagster.AssetKey)) – The unique identifier for this asset.
      - <strong>deps</strong> (<em>Optional</em><em>[</em><em>AbstractSet</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – The asset keys for the upstream assets that materializing this asset depends on.
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Human-readable description of this asset.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dict of static metadata for this asset. For example, users can provide information about the database table this asset corresponds to.
      - <strong>skippable</strong> (<em>bool</em>) – Whether this asset can be omitted during materialization, causing downstream dependencies to skip.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. If not provided, the name “default” is used.
      - <strong>code_version</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The version of the code for this specific asset, overriding the code version of the materialization function
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – BackfillPolicy to apply to the specified asset.
      - <strong>owners</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A list of strings representing owners of the asset. Each string can be a user’s email address, or a team name prefixed with <cite>team:</cite>, e.g. <cite>team:finops</cite>.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Tags for filtering and organizing. These tags are not attached to runs of the asset.
      - <strong>kinds</strong> – (Optional[Set[str]]): A list of strings representing the kinds of the asset. These will be made visible in the Dagster UI.
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that compose the asset.


    <dl>
        <dt><Link id='dagster.AssetSpec.merge_attributes'>merge_attributes</Link></dt>
        <dd>

        Returns a new AssetSpec with the specified attributes merged with the current attributes.

        Parameters: 
          - <strong>deps</strong> (<em>Optional</em><em>[</em><em>Iterable</em><em>[</em><em>CoercibleToAssetDep</em><em>]</em><em>]</em>) – A set of asset dependencies to add to the asset self.
          - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A set of metadata to add to the asset self. Will overwrite any existing metadata with the same key.
          - <strong>owners</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A set of owners to add to the asset self.
          - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – A set of tags to add to the asset self. Will overwrite any existing tags with the same key.
          - <strong>kinds</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A set of kinds to add to the asset self.


        Returns: AssetSpec

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.replace_attributes'>replace_attributes</Link></dt>
        <dd>
        Returns a new AssetSpec with the specified attributes replaced.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.with_io_manager_key'>with_io_manager_key</Link></dt>
        <dd>

        Returns a copy of this AssetSpec with an extra metadata value that dictates which I/O
        manager to use to load the contents of this asset in downstream computations.

        Parameters: <strong>io_manager_key</strong> (<em>str</em>) – The I/O manager key. This will be used as the value for the
        “dagster/io_manager_key” metadata key.Returns: AssetSpec

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetsDefinition'>`class` dagster.AssetsDefinition</Link></dt>
    <dd>

    Defines a set of assets that are produced by the same op or graph.

    AssetsDefinitions are typically not instantiated directly, but rather produced using the
    [`@asset`](#dagster.asset) or [`@multi_asset`](#dagster.multi_asset) decorators.

    <dl>
        <dt><Link id='dagster.AssetsDefinition.from_graph'>`static` from_graph</Link></dt>
        <dd>

        Constructs an AssetsDefinition from a GraphDefinition.

        Parameters: 
          - <strong>graph_def</strong> ([*GraphDefinition*](graphs.mdx#dagster.GraphDefinition)) – The GraphDefinition that is an asset.
          - <strong>keys_by_input_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – A mapping of the input names of the decorated graph to their corresponding asset keys. If not provided, the input asset keys will be created from the graph input names.
          - <strong>keys_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – A mapping of the output names of the decorated graph to their corresponding asset keys. If not provided, the output asset keys will be created from the graph output names.
          - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, key_prefix will be prepended to each key in keys_by_output_name. Each item in key_prefix must be a valid name in dagster (ie only contains letters, numbers, and _) and may not contain python reserved keywords.
          - <strong>internal_asset_deps</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Set</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em><em>]</em>) – By default, it is assumed that all assets produced by the graph depend on all assets that are consumed by that graph. If this default is not correct, you pass in a map of output names to a corrected set of AssetKeys that they depend on. Any AssetKeys in this list must be either used as input to the asset or produced within the graph.
          - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that compose the assets.
          - <strong>partition_mappings</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*PartitionMapping*](partitions.mdx#dagster.PartitionMapping)<em>]</em><em>]</em>) – Defines how to map partition keys for this asset to partition keys of upstream assets. Each key in the dictionary correponds to one of the input assets, and each value is a PartitionMapping. If no entry is provided for a particular asset dependency, the partition mapping defaults to the default partition mapping for the partitions definition, which is typically maps partition keys to the same partition keys in upstream assets.
          - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*ResourceDefinition*](resources.mdx#dagster.ResourceDefinition)<em>]</em><em>]</em>) – <span className="flag flag-warning">beta</span>  (Beta) A mapping of resource keys to resource definitions. These resources will be initialized during execution, and can be accessed from the body of ops in the graph during execution.
          - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A group name for the constructed asset. Assets without a group name are assigned to a group called “default”.
          - <strong>group_names_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Defines a group name to be associated with some or all of the output assets for this node. Keys are names of the outputs, and values are the group name. Cannot be used with the group_name argument.
          - <strong>descriptions_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Defines a description to be associated with each of the output asstes for this graph.
          - <strong>metadata_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>RawMetadataMapping</em><em>]</em><em>]</em><em>]</em>) – Defines metadata to be associated with each of the output assets for this node. Keys are names of the outputs, and values are dictionaries of metadata to be associated with the related asset.
          - <strong>tags_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em><em>]</em>) – Defines tags to be associated with each of the output assets for this node. Keys are the names of outputs, and values are dictionaries of tags to be associated with the related asset.
          - <strong>freshness_policies_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em><em>]</em><em>]</em>) – Defines a FreshnessPolicy to be associated with some or all of the output assets for this node. Keys are the names of the outputs, and values are the FreshnessPolicies to be attached to the associated asset.
          - <strong>automation_conditions_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em><em>]</em><em>]</em>) – Defines an AutomationCondition to be associated with some or all of the output assets for this node. Keys are the names of the outputs, and values are the AutoMaterializePolicies to be attached to the associated asset.
          - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – Defines this asset’s BackfillPolicy
          - <strong>owners_by_key</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Defines owners to be associated with each of the asset keys for this node.



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.from_op'>`static` from_op</Link></dt>
        <dd>

        Constructs an AssetsDefinition from an OpDefinition.

        Parameters: 
          - <strong>op_def</strong> ([*OpDefinition*](ops.mdx#dagster.OpDefinition)) – The OpDefinition that is an asset.
          - <strong>keys_by_input_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – A mapping of the input names of the decorated op to their corresponding asset keys. If not provided, the input asset keys will be created from the op input names.
          - <strong>keys_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – A mapping of the output names of the decorated op to their corresponding asset keys. If not provided, the output asset keys will be created from the op output names.
          - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, key_prefix will be prepended to each key in keys_by_output_name. Each item in key_prefix must be a valid name in dagster (ie only contains letters, numbers, and _) and may not contain python reserved keywords.
          - <strong>internal_asset_deps</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Set</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em><em>]</em>) – By default, it is assumed that all assets produced by the op depend on all assets that are consumed by that op. If this default is not correct, you pass in a map of output names to a corrected set of AssetKeys that they depend on. Any AssetKeys in this list must be either used as input to the asset or produced within the op.
          - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that compose the assets.
          - <strong>partition_mappings</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*PartitionMapping*](partitions.mdx#dagster.PartitionMapping)<em>]</em><em>]</em>) – Defines how to map partition keys for this asset to partition keys of upstream assets. Each key in the dictionary correponds to one of the input assets, and each value is a PartitionMapping. If no entry is provided for a particular asset dependency, the partition mapping defaults to the default partition mapping for the partitions definition, which is typically maps partition keys to the same partition keys in upstream assets.
          - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A group name for the constructed asset. Assets without a group name are assigned to a group called “default”.
          - <strong>group_names_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Defines a group name to be associated with some or all of the output assets for this node. Keys are names of the outputs, and values are the group name. Cannot be used with the group_name argument.
          - <strong>descriptions_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Defines a description to be associated with each of the output asstes for this graph.
          - <strong>metadata_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>RawMetadataMapping</em><em>]</em><em>]</em><em>]</em>) – Defines metadata to be associated with each of the output assets for this node. Keys are names of the outputs, and values are dictionaries of metadata to be associated with the related asset.
          - <strong>tags_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em><em>]</em>) – Defines tags to be associated with each othe output assets for this node. Keys are the names of outputs, and values are dictionaries of tags to be associated with the related asset.
          - <strong>freshness_policies_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em><em>]</em><em>]</em>) – Defines a FreshnessPolicy to be associated with some or all of the output assets for this node. Keys are the names of the outputs, and values are the FreshnessPolicies to be attached to the associated asset.
          - <strong>automation_conditions_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em><em>]</em><em>]</em>) – Defines an AutomationCondition to be associated with some or all of the output assets for this node. Keys are the names of the outputs, and values are the AutoMaterializePolicies to be attached to the associated asset.
          - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – Defines this asset’s BackfillPolicy



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.get_asset_spec'>get_asset_spec</Link></dt>
        <dd>

        Returns a representation of this asset as an [`AssetSpec`](#dagster.AssetSpec).

        If this is a multi-asset, the “key” argument allows selecting which asset to return the
        spec for.

        Parameters: <strong>key</strong> (<em>Optional</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em>) – If this is a multi-asset, select which asset to return its
        AssetSpec. If not a multi-asset, this can be left as None.Returns: AssetSpec

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.get_partition_mapping'>get_partition_mapping</Link></dt>
        <dd>
        Returns the partition mapping between keys in this AssetsDefinition and a given input
        asset key (if any).
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.to_source_asset'>to_source_asset</Link></dt>
        <dd>

        Returns a representation of this asset as a [`SourceAsset`](#dagster.SourceAsset).

        If this is a multi-asset, the “key” argument allows selecting which asset to return a
        SourceAsset representation of.

        Parameters: <strong>key</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em><em>]</em>) – If this is a multi-asset, select
        which asset to return a SourceAsset representation of. If not a multi-asset, this
        can be left as None.Returns: SourceAsset

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.to_source_assets'>to_source_assets</Link></dt>
        <dd>

        Returns a SourceAsset for each asset in this definition.

        Each produced SourceAsset will have the same key, metadata, io_manager_key, etc. as the
        corresponding asset


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.asset_deps'>`property` asset_deps</Link></dt>
        <dd>
        Maps assets that are produced by this definition to assets that they depend on. The
        dependencies can be either “internal”, meaning that they refer to other assets that are
        produced by this definition, or “external”, meaning that they refer to assets that aren’t
        produced by this definition.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.can_subset'>`property` can_subset</Link></dt>
        <dd>

        If True, indicates that this AssetsDefinition may materialize any subset of its
        asset keys in a given computation (as opposed to being required to materialize all asset
        keys).

        Type: bool

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.check_specs'>`property` check_specs</Link></dt>
        <dd>

        Returns the asset check specs defined on this AssetsDefinition, i.e. the checks that can
        be executed while materializing the assets.

        Return type: Iterable[AssetsCheckSpec]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.dependency_keys'>`property` dependency_keys</Link></dt>
        <dd>

        The asset keys which are upstream of any asset included in this
        AssetsDefinition.

        Type: Iterable[[AssetKey](#dagster.AssetKey)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.descriptions_by_key'>`property` descriptions_by_key</Link></dt>
        <dd>

        Returns a mapping from the asset keys in this AssetsDefinition
        to the descriptions assigned to them. If there is no assigned description for a given AssetKey,
        it will not be present in this dictionary.

        Type: Mapping[[AssetKey](#dagster.AssetKey), str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.group_names_by_key'>`property` group_names_by_key</Link></dt>
        <dd>

        Returns a mapping from the asset keys in this AssetsDefinition
        to the group names assigned to them. If there is no assigned group name for a given AssetKey,
        it will not be present in this dictionary.

        Type: Mapping[[AssetKey](#dagster.AssetKey), str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.key'>`property` key</Link></dt>
        <dd>

        The asset key associated with this AssetsDefinition. If this AssetsDefinition
        has more than one asset key, this will produce an error.

        Type: [AssetKey](#dagster.AssetKey)

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.keys'>`property` keys</Link></dt>
        <dd>

        The asset keys associated with this AssetsDefinition.

        Type: AbstractSet[[AssetKey](#dagster.AssetKey)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.node_def'>`property` node_def</Link></dt>
        <dd>

        Returns the OpDefinition or GraphDefinition that is used to materialize
        the assets in this AssetsDefinition.

        Type: NodeDefinition

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.op'>`property` op</Link></dt>
        <dd>

        Returns the OpDefinition that is used to materialize the assets in this
        AssetsDefinition.

        Type: [OpDefinition](ops.mdx#dagster.OpDefinition)

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.partitions_def'>`property` partitions_def</Link></dt>
        <dd>

        The PartitionsDefinition for this AssetsDefinition (if any).

        Type: Optional[[PartitionsDefinition](partitions.mdx#dagster.PartitionsDefinition)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.required_resource_keys'>`property` required_resource_keys</Link></dt>
        <dd>

        The set of keys for resources that must be provided to this AssetsDefinition.

        Type: Set[str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.resource_defs'>`property` resource_defs</Link></dt>
        <dd>

        A mapping from resource name to ResourceDefinition for
        the resources bound to this AssetsDefinition.

        Type: Mapping[str, [ResourceDefinition](resources.mdx#dagster.ResourceDefinition)]

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetKey'>`class` dagster.AssetKey</Link></dt>
    <dd>

    Object representing the structure of an asset key.  Takes in a sanitized string, list of
    strings, or tuple of strings.

    Example usage:

        ```python
        from dagster import AssetKey

        AssetKey("asset1")
        AssetKey(["asset1"]) # same as the above
        AssetKey(["prefix", "asset1"])
        AssetKey(["prefix", "subprefix", "asset1"])
        ```
    Parameters: <strong>path</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – String, list of strings, or tuple of strings.  A list of
    strings represent the hierarchical structure of the asset_key.
    <dl>
        <dt><Link id='dagster.AssetKey.path'>`property` path</Link></dt>
        <dd>

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.map_asset_specs'>dagster.map_asset_specs</Link></dt>
    <dd>

    Map a function over a sequence of AssetSpecs or AssetsDefinitions, replacing specs in the sequence
    or specs in an AssetsDefinitions with the result of the function.

    Parameters: 
      - <strong>func</strong> (<em>Callable</em><em>[</em><em>[</em>[*AssetSpec*](#dagster.AssetSpec)<em>]</em><em>, </em>[*AssetSpec*](#dagster.AssetSpec)<em>]</em>) – The function to apply to each AssetSpec.
      - <strong>iterable</strong> (<em>Iterable</em><em>[</em><em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*AssetSpec*](#dagster.AssetSpec)<em>]</em><em>]</em>) – The sequence of AssetSpecs or AssetsDefinitions.


    Returns: 
    A sequence of AssetSpecs or AssetsDefinitions with the function applied
        to each spec.

    Return type: Sequence[Union[[AssetsDefinition](#dagster.AssetsDefinition), [AssetSpec](#dagster.AssetSpec)]]
    Examples:

        ```python
        from dagster import AssetSpec, map_asset_specs

        asset_specs = [
            AssetSpec(key="my_asset"),
            AssetSpec(key="my_asset_2"),
        ]

        mapped_specs = map_asset_specs(lambda spec: spec.replace_attributes(owners=["nelson@hooli.com"]), asset_specs)
        ```

    </dd>

</dl>
</div>


<div class="section" id="graph-backed-asset-definitions">


## Graph-backed asset definitions

Refer to the [Graph-backed asset](https://docs.dagster.io/guides/build/assets/defining-assets#graph-asset) documentation for more information.

<dl>
    <dt><Link id='dagster.graph_asset'>@dagster.graph_asset</Link></dt>
    <dd>

    Creates a software-defined asset that’s computed using a graph of ops.

    This decorator is meant to decorate a function that composes a set of ops or graphs to define
    the dependencies between them.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the asset.  If not provided, defaults to the name of the decorated function. The asset’s name must be a valid name in Dagster (ie only contains letters, numbers, and underscores) and may not contain Python reserved keywords.
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A human-readable description of the asset.
      - <strong>ins</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetIn*](#dagster.AssetIn)<em>]</em><em>]</em>) – A dictionary that maps input names to information about the input.
      - <strong>config</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em>[*ConfigMapping*](config.mdx#dagster.ConfigMapping)<em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – 

        Describes how the graph underlying the asset is configured at runtime.

        If a [`ConfigMapping`](config.mdx#dagster.ConfigMapping) object is provided, then the graph takes on the config schema of this object. The mapping will be applied at runtime to generate the config for the graph’s constituent nodes.

        If a dictionary is provided, then it will be used as the default run config for the graph. This means it must conform to the config schema of the underlying nodes. Note that the values provided will be viewable and editable in the Dagster UI, so be careful with secrets.

      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, the asset’s key is the concatenation of the key_prefix and the asset’s name, which defaults to the name of the decorated function. Each item in key_prefix must be a valid name in Dagster (ie only contains letters, numbers, and underscores) and may not contain Python reserved keywords.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. If not provided, the name “default” is used.
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that compose the asset.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>RawMetadataMapping</em><em>]</em>) – Dictionary of metadata to be associated with the asset.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Tags for filtering and organizing. These tags are not attached to runs of the asset.
      - <strong>owners</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A list of strings representing owners of the asset. Each string can be a user’s email address, or a team name prefixed with <cite>team:</cite>, e.g. <cite>team:finops</cite>.
      - <strong>kinds</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A list of strings representing the kinds of the asset. These will be made visible in the Dagster UI.
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – The AutomationCondition to use for this asset.
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – The BackfillPolicy to use for this asset.
      - <strong>code_version</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Version of the code that generates this asset. In general, versions should be set only for code that deterministically produces the same output when given the same inputs.
      - <strong>key</strong> (<em>Optional</em><em>[</em><em>CoeercibleToAssetKey</em><em>]</em>) – The key for this asset. If provided, cannot specify key_prefix or name.


    Examples:

        ```python
        @op
        def fetch_files_from_slack(context) -> pd.DataFrame:
            ...

        @op
        def store_files(files) -> None:
            files.to_sql(name="slack_files", con=create_db_connection())

        @graph_asset
        def slack_files_table():
            return store_files(fetch_files_from_slack())
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.graph_multi_asset'>@dagster.graph_multi_asset</Link></dt>
    <dd>

    Create a combined definition of multiple assets that are computed using the same graph of
    ops, and the same upstream assets.

    Each argument to the decorated function references an upstream asset that this asset depends on.
    The name of the argument designates the name of the upstream asset.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the graph.
      - <strong>outs</strong> – (Optional[Dict[str, AssetOut]]): The AssetOuts representing the produced assets.
      - <strong>ins</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetIn*](#dagster.AssetIn)<em>]</em><em>]</em>) – A dictionary that maps input names to information about the input.
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that compose the assets.
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – The backfill policy for the asset.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. This group name will be applied to all assets produced by this multi_asset.
      - <strong>can_subset</strong> (<em>bool</em>) – Whether this asset’s computation can emit a subset of the asset keys based on the context.selected_assets argument. Defaults to False.
      - <strong>config</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em>[*ConfigMapping*](config.mdx#dagster.ConfigMapping)<em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – 

        Describes how the graph underlying the asset is configured at runtime.

        If a [`ConfigMapping`](config.mdx#dagster.ConfigMapping) object is provided, then the graph takes on the config schema of this object. The mapping will be applied at runtime to generate the config for the graph’s constituent nodes.

        If a dictionary is provided, then it will be used as the default run config for the graph. This means it must conform to the config schema of the underlying nodes. Note that the values provided will be viewable and editable in the Dagster UI, so be careful with secrets.

        If no value is provided, then the config schema for the graph is the default (derived



    </dd>

</dl>
</div>


<div class="section" id="multi-asset-definitions">


## Multi-asset definitions

Refer to the [Multi-asset](https://docs.dagster.io/guides/build/assets/defining-assets#multi-asset) documentation for more information.

<dl>
    <dt><Link id='dagster.multi_asset'>@dagster.multi_asset</Link></dt>
    <dd>

    Create a combined definition of multiple assets that are computed using the same op and same
    upstream assets.

    Each argument to the decorated function references an upstream asset that this asset depends on.
    The name of the argument designates the name of the upstream asset.

    You can set I/O managers keys, auto-materialize policies, freshness policies, group names, etc.
    on an individual asset within the multi-asset by attaching them to the [`AssetOut`](#dagster.AssetOut)
    corresponding to that asset in the <cite>outs</cite> parameter.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the op.
      - <strong>outs</strong> – (Optional[Dict[str, AssetOut]]): The AssetOuts representing the assets materialized by this function. AssetOuts detail the output, IO management, and core asset properties. This argument is required except when AssetSpecs are used.
      - <strong>ins</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetIn*](#dagster.AssetIn)<em>]</em><em>]</em>) – A dictionary that maps input names to information about the input.
      - <strong>deps</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*SourceAsset*](#dagster.SourceAsset)<em>, </em>[*AssetKey*](#dagster.AssetKey)<em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – The assets that are upstream dependencies, but do not correspond to a parameter of the decorated function. If the AssetsDefinition for a multi_asset is provided, dependencies on all assets created by the multi_asset will be created.
      - <strong>config_schema</strong> (<em>Optional</em><em>[</em>[*ConfigSchema*](config.mdx#dagster.ConfigSchema)) – The configuration schema for the asset’s underlying op. If set, Dagster will check that config provided for the op matches this schema and fail if it does not. If not set, Dagster will accept any config provided for the op.
      - <strong>required_resource_keys</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – Set of resource handles required by the underlying op.
      - <strong>internal_asset_deps</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Set</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em><em>]</em>) – By default, it is assumed that all assets produced by a multi_asset depend on all assets that are consumed by that multi asset. If this default is not correct, you pass in a map of output names to a corrected set of AssetKeys that they depend on. Any AssetKeys in this list must be either used as input to the asset or produced within the op.
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that compose the assets.
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – The backfill policy for the op that computes the asset.
      - <strong>op_tags</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dictionary of tags for the op that computes the asset. Frameworks may expect and require certain metadata to be attached to a op. Values that are not strings will be json encoded and must meet the criteria that <cite>json.loads(json.dumps(value)) == value</cite>.
      - <strong>can_subset</strong> (<em>bool</em>) – If this asset’s computation can emit a subset of the asset keys based on the context.selected_asset_keys argument. Defaults to False.
      - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – <span className="flag flag-warning">beta</span>  (Beta) A mapping of resource keys to resources. These resources will be initialized during execution, and can be accessed from the context within the body of the function.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. This group name will be applied to all assets produced by this multi_asset.
      - <strong>retry_policy</strong> (<em>Optional</em><em>[</em>[*RetryPolicy*](ops.mdx#dagster.RetryPolicy)<em>]</em>) – The retry policy for the op that computes the asset.
      - <strong>code_version</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Version of the code encapsulated by the multi-asset. If set, this is used as a default code version for all defined assets.
      - <strong>specs</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetSpec*](#dagster.AssetSpec)<em>]</em><em>]</em>) – The specifications for the assets materialized by this function.
      - <strong>check_specs</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetCheckSpec*](asset-checks.mdx#dagster.AssetCheckSpec)<em>]</em><em>]</em>) – Specs for asset checks that execute in the decorated function after materializing the assets.
      - <strong>pool</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string that identifies the concurrency pool that governs this multi-asset’s execution.
      - <strong>non_argument_deps</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Set</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>, </em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – <span className="flag flag-danger">deprecated</span>  Deprecated, use deps instead. Set of asset keys that are upstream dependencies, but do not pass an input to the multi_asset.


    Examples:

        ```python
        @multi_asset(
            specs=[
                AssetSpec("asset1", deps=["asset0"]),
                AssetSpec("asset2", deps=["asset0"]),
            ]
        )
        def my_function():
            asset0_value = load(path="asset0")
            asset1_result, asset2_result = do_some_transformation(asset0_value)
            write(asset1_result, path="asset1")
            write(asset2_result, path="asset2")

        # Or use IO managers to handle I/O:
        @multi_asset(
            outs={
                "asset1": AssetOut(),
                "asset2": AssetOut(),
            }
        )
        def my_function(asset0):
            asset1_value = do_some_transformation(asset0)
            asset2_value = do_some_other_transformation(asset0)
            return asset1_value, asset2_value
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.multi_observable_source_asset'>@dagster.multi_observable_source_asset</Link></dt>
    <dd>

        :::warning[beta]
        This API is currently in beta, and may have breaking changes in minor version releases, with behavior changes in patch releases.


        :::

    Defines a set of assets that can be observed together with the same function.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the op.
      - <strong>required_resource_keys</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – Set of resource handles required by the underlying op.
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that compose the assets.
      - <strong>can_subset</strong> (<em>bool</em>) – If this asset’s computation can emit a subset of the asset keys based on the context.selected_assets argument. Defaults to False.
      - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – <span className="flag flag-warning">beta</span>  (Beta) A mapping of resource keys to resources. These resources will be initialized during execution, and can be accessed from the context within the body of the function.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. This group name will be applied to all assets produced by this multi_asset.
      - <strong>specs</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetSpec*](#dagster.AssetSpec)<em>]</em><em>]</em>) – The specifications for the assets observed by this function.
      - <strong>check_specs</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetCheckSpec*](asset-checks.mdx#dagster.AssetCheckSpec)<em>]</em><em>]</em>) – Specs for asset checks that execute in the decorated function after observing the assets.


    Examples:

        ```python
        @multi_observable_source_asset(
            specs=[AssetSpec("asset1"), AssetSpec("asset2")],
        )
        def my_function():
            yield ObserveResult(asset_key="asset1", metadata={"foo": "bar"})
            yield ObserveResult(asset_key="asset2", metadata={"baz": "qux"})
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetOut'>`class` dagster.AssetOut</Link></dt>
    <dd>

    Defines one of the assets produced by a [`@multi_asset`](#dagster.multi_asset).

    Parameters: 
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, the asset’s key is the concatenation of the key_prefix and the asset’s name. When using `@multi_asset`, the asset name defaults to the key of the “outs” dictionary Only one of the “key_prefix” and “key” arguments should be provided.
      - <strong>key</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – The asset’s key. Only one of the “key_prefix” and “key” arguments should be provided.
      - <strong>dagster_type</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Type</em><em>, </em>[*DagsterType*](types.mdx#dagster.DagsterType)<em>]</em><em>]</em><em>]</em>) – The type of this output. Should only be set if the correct type can not be inferred directly from the type signature of the decorated function.
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Human-readable description of the output.
      - <strong>is_required</strong> (<em>bool</em>) – Whether the presence of this field is required. (default: True)
      - <strong>io_manager_key</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The resource key of the IO manager used for this output. (default: “io_manager”).
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dict of the metadata for the output. For example, users can provide a file path if the data object will be stored in a filesystem, or provide information of a database table when it is going to load the data into the table.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. If not provided, the name “default” is used.
      - <strong>code_version</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The version of the code that generates this asset.
      - <strong>freshness_policy</strong> (<em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em>) – <span className="flag flag-danger">deprecated</span>  (Deprecated) A policy which indicates how up to date this asset is intended to be.
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – AutomationCondition to apply to the specified asset.
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – BackfillPolicy to apply to the specified asset.
      - <strong>owners</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A list of strings representing owners of the asset. Each string can be a user’s email address, or a team name prefixed with <cite>team:</cite>, e.g. <cite>team:finops</cite>.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Tags for filtering and organizing. These tags are not attached to runs of the asset.


    <dl>
        <dt><Link id='dagster.AssetOut.from_spec'>`static` from_spec</Link></dt>
        <dd>

        Builds an AssetOut from the passed spec.

        Parameters: 
          - <strong>spec</strong> ([*AssetSpec*](#dagster.AssetSpec)) – The spec to build the AssetOut from.
          - <strong>dagster_type</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Type</em><em>, </em>[*DagsterType*](types.mdx#dagster.DagsterType)<em>]</em><em>]</em>) – The type of this output. Should only be set if the correct type can not be inferred directly from the type signature of the decorated function.
          - <strong>is_required</strong> (<em>bool</em>) – Whether the presence of this field is required. (default: True)
          - <strong>io_manager_key</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The resource key of the IO manager used for this output. (default: “io_manager”).
          - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – BackfillPolicy to apply to the specified asset.


        Returns: The AssetOut built from the spec.Return type: [AssetOut](#dagster.AssetOut)

        </dd>

    </dl>

    </dd>

</dl>
</div>


<div class="section" id="source-assets">


## Source assets

Refer to the [External asset dependencies](https://docs.dagster.io/guides/build/assets/external-assets) documentation for more information.

<dl>
    <dt><Link id='dagster.SourceAsset'>`class` dagster.SourceAsset</Link></dt>
    <dd>

        :::danger[deprecated]
        This API will be removed in version 2.0.0.
         Use AssetSpec instead. If using the SourceAsset io_manager_key property, use AssetSpec(...).with_io_manager_key(...)..

        :::

    A SourceAsset represents an asset that will be loaded by (but not updated by) Dagster.

    Parameters: 
      - <strong>key</strong> (<em>Union</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em><em>str</em><em>]</em>) – The key of the asset.
      - <strong>metadata</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em>[*MetadataValue*](metadata.mdx#dagster.MetadataValue)<em>]</em>) – Metadata associated with the asset.
      - <strong>io_manager_key</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The key for the IOManager that will be used to load the contents of the asset when it’s used as an input to other assets inside a job.
      - <strong>io_manager_def</strong> (<em>Optional</em><em>[</em>[*IOManagerDefinition*](io-managers.mdx#dagster.IOManagerDefinition)<em>]</em>) – <span className="flag flag-warning">beta</span>  (Beta) The definition of the IOManager that will be used to load the contents of the asset when it’s used as an input to other assets inside a job.
      - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*ResourceDefinition*](resources.mdx#dagster.ResourceDefinition)<em>]</em><em>]</em>) – <span className="flag flag-warning">beta</span>  (Beta) resource definitions that may be required by the [`dagster.IOManagerDefinition`](io-managers.mdx#dagster.IOManagerDefinition) provided in the <cite>io_manager_def</cite> argument.
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The description of the asset.
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that compose the asset.
      - <strong>observe_fn</strong> (<em>Optional</em><em>[</em><em>SourceAssetObserveFunction</em><em>]</em>)
      - <strong>op_tags</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dictionary of tags for the op that computes the asset. Frameworks may expect and require certain metadata to be attached to a op. Values that are not strings will be json encoded and must meet the criteria that <cite>json.loads(json.dumps(value)) == value</cite>.
      - <strong>auto_observe_interval_minutes</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – While the asset daemon is turned on, a run of the observation function for this asset will be launched at this interval. <cite>observe_fn</cite> must be provided.
      - <strong>freshness_policy</strong> (<em>FreshnessPolicy</em>) – <span className="flag flag-danger">deprecated</span>  A constraint telling Dagster how often this asset is intended to be updated with respect to its root data.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Tags for filtering and organizing. These tags are not attached to runs of the asset.


    <dl>
        <dt><Link id='dagster.SourceAsset.is_observable'>`property` is_observable</Link></dt>
        <dd>

        Whether the asset is observable.

        Type: bool

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.op'>`property` op</Link></dt>
        <dd>

        The OpDefinition associated with the observation function of an observable
        source asset.

        Throws an error if the asset is not observable.

        Type: [OpDefinition](ops.mdx#dagster.OpDefinition)

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.observable_source_asset'>@dagster.observable_source_asset</Link></dt>
    <dd>

        :::warning[beta]
        This API is currently in beta, and may have breaking changes in minor version releases, with behavior changes in patch releases.


        :::

    Create a <cite>SourceAsset</cite> with an associated observation function.

    The observation function of a source asset is wrapped inside of an op and can be executed as
    part of a job. Each execution generates an <cite>AssetObservation</cite> event associated with the source
    asset. The source asset observation function should return a `DataVersion`,
    a <cite>~dagster.DataVersionsByPartition</cite>, or an [`ObserveResult`](#dagster.ObserveResult).

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the source asset.  If not provided, defaults to the name of the decorated function. The asset’s name must be a valid name in dagster (ie only contains letters, numbers, and _) and may not contain python reserved keywords.
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, the source asset’s key is the concatenation of the key_prefix and the asset’s name, which defaults to the name of the decorated function. Each item in key_prefix must be a valid name in dagster (ie only contains letters, numbers, and _) and may not contain python reserved keywords.
      - <strong>metadata</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>RawMetadataValue</em><em>]</em>) – Metadata associated with the asset.
      - <strong>io_manager_key</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The key for the IOManager that will be used to load the contents of the source asset when it’s used as an input to other assets inside a job.
      - <strong>io_manager_def</strong> (<em>Optional</em><em>[</em>[*IOManagerDefinition*](io-managers.mdx#dagster.IOManagerDefinition)<em>]</em>) – <span className="flag flag-warning">beta</span>  (Beta) The definition of the IOManager that will be used to load the contents of the source asset when it’s used as an input to other assets inside a job.
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The description of the asset.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. If not provided, the name “default” is used.
      - <strong>required_resource_keys</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – Set of resource keys required by the observe op.
      - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*ResourceDefinition*](resources.mdx#dagster.ResourceDefinition)<em>]</em><em>]</em>) – <span className="flag flag-warning">beta</span>  (Beta) resource definitions that may be required by the [`dagster.IOManagerDefinition`](io-managers.mdx#dagster.IOManagerDefinition) provided in the <cite>io_manager_def</cite> argument.
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that compose the asset.
      - <strong>op_tags</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dictionary of tags for the op that computes the asset. Frameworks may expect and require certain metadata to be attached to a op. Values that are not strings will be json encoded and must meet the criteria that <cite>json.loads(json.dumps(value)) == value</cite>.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Tags for filtering and organizing. These tags are not attached to runs of the asset.
      - <strong>observe_fn</strong> (<em>Optional</em><em>[</em><em>SourceAssetObserveFunction</em><em>]</em>) – Observation function for the source asset.
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – A condition describing when Dagster should materialize this asset.



    </dd>

</dl>
<dl>
    <dt><Link id='dagster.ObserveResult'>`class` dagster.ObserveResult</Link></dt>
    <dd>

    An object representing a successful observation of an asset. These can be returned from an
    @observable_source_asset decorated function to pass metadata.

    Parameters: 
      - <strong>asset_key</strong> (<em>Optional</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em>) – The asset key. Optional to include.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>RawMetadataMapping</em><em>]</em>) – Metadata to record with the corresponding AssetObservation event.
      - <strong>check_results</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetCheckResult*](asset-checks.mdx#dagster.AssetCheckResult)<em>]</em><em>]</em>) – Check results to record with the corresponding AssetObservation event.
      - <strong>data_version</strong> (<em>Optional</em><em>[</em><em>DataVersion</em><em>]</em>) – The data version of the asset that was observed.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Tags to record with the corresponding AssetObservation event.



    </dd>

</dl>
</div>


<div class="section" id="dependencies">


## Dependencies

<dl>
    <dt><Link id='dagster.AssetDep'>`class` dagster.AssetDep</Link></dt>
    <dd>

    Specifies a dependency on an upstream asset.

    Parameters: 
      - <strong>asset</strong> (<em>Union</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>, </em><em>str</em><em>, </em>[*AssetSpec*](#dagster.AssetSpec)<em>, </em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*SourceAsset*](#dagster.SourceAsset)<em>]</em>) – The upstream asset to depend on.
      - <strong>partition_mapping</strong> (<em>Optional</em><em>[</em>[*PartitionMapping*](partitions.mdx#dagster.PartitionMapping)<em>]</em>) – Defines what partitions to depend on in the upstream asset. If not provided and the upstream asset is partitioned, defaults to the default partition mapping for the partitions definition, which is typically maps partition keys to the same partition keys in upstream assets.


    Examples:

        ```python
        upstream_asset = AssetSpec("upstream_asset")
        downstream_asset = AssetSpec(
            "downstream_asset",
            deps=[
                AssetDep(
                    upstream_asset,
                    partition_mapping=TimeWindowPartitionMapping(start_offset=-1, end_offset=-1)
                )
            ]
        )
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetIn'>`class` dagster.AssetIn</Link></dt>
    <dd>

    Defines an asset dependency.

    Parameters: 
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, the asset’s key is the concatenation of the key_prefix and the input name. Only one of the “key_prefix” and “key” arguments should be provided.
      - <strong>key</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – The asset’s key. Only one of the “key_prefix” and “key” arguments should be provided.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dict of the metadata for the input. For example, if you only need a subset of columns from an upstream table, you could include that in metadata and the IO manager that loads the upstream table could use the metadata to determine which columns to load.
      - <strong>partition_mapping</strong> (<em>Optional</em><em>[</em>[*PartitionMapping*](partitions.mdx#dagster.PartitionMapping)<em>]</em>) – Defines what partitions to depend on in the upstream asset. If not provided, defaults to the default partition mapping for the partitions definition, which is typically maps partition keys to the same partition keys in upstream assets.
      - <strong>dagster_type</strong> ([*DagsterType*](types.mdx#dagster.DagsterType)) – Allows specifying type validation functions that will be executed on the input of the decorated function before it runs.



    </dd>

</dl>
</div>


<div class="section" id="asset-jobs">


## Asset jobs

[Asset jobs](https://docs.dagster.io/guides/build/assets/asset-jobs) enable the automation of asset materializations.  Dagster’s [asset selection syntax](https://docs.dagster.io/guides/build/assets/asset-selection-syntax) can be used to select assets and assign them to a job.

<dl>
    <dt><Link id='dagster.define_asset_job'>dagster.define_asset_job</Link></dt>
    <dd>

    Creates a definition of a job which will either materialize a selection of assets or observe
    a selection of source assets. This will only be resolved to a JobDefinition once placed in a
    code location.

    Parameters: 
      - <strong>name</strong> (<em>str</em>) – The name for the job.
      - <strong>selection</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Sequence</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>, </em><em>Sequence</em><em>[</em><em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*SourceAsset*](#dagster.SourceAsset)<em>]</em><em>]</em><em>, </em>[*AssetSelection*](#dagster.AssetSelection)<em>]</em>) – 

        The assets that will be materialized or observed when the job is run.

        The selected assets must all be included in the assets that are passed to the assets argument of the Definitions object that this job is included on.

        The string “my_asset*” selects my_asset and all downstream assets within the code location. A list of strings represents the union of all assets selected by strings within the list.

      - <strong>config</strong> – 

        Describes how the Job is parameterized at runtime.

        If no value is provided, then the schema for the job’s run config is a standard format based on its ops and resources.

        If a dictionary is provided, then it must conform to the standard config schema, and it will be used as the job’s run config for the job whenever the job is executed. The values provided will be viewable and editable in the Dagster UI, so be careful with secrets.

      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – A set of key-value tags that annotate the job and can be used for searching and filtering in the UI. Values that are not already strings will be serialized as JSON. If <cite>run_tags</cite> is not set, then the content of <cite>tags</cite> will also be automatically appended to the tags of any runs of this job.
      - <strong>run_tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – A set of key-value tags that will be automatically attached to runs launched by this job. Values that are not already strings will be serialized as JSON. These tag values may be overwritten by tag values provided at invocation time. If <cite>run_tags</cite> is set, then <cite>tags</cite> are not automatically appended to the tags of any runs of this job.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>RawMetadataValue</em><em>]</em><em>]</em>) – Arbitrary metadata about the job. Keys are displayed string labels, and values are one of the following: string, float, int, JSON-serializable dict, JSON-serializable list, and one of the data classes returned by a MetadataValue static method.
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A description for the Job.
      - <strong>executor_def</strong> (<em>Optional</em><em>[</em>[*ExecutorDefinition*](internals.mdx#dagster.ExecutorDefinition)<em>]</em>) – How this Job will be executed. Defaults to [`multi_or_in_process_executor`](execution.mdx#dagster.multi_or_in_process_executor), which can be switched between multi-process and in-process modes of execution. The default mode of execution is multi-process.
      - <strong>op_retry_policy</strong> (<em>Optional</em><em>[</em>[*RetryPolicy*](ops.mdx#dagster.RetryPolicy)<em>]</em>) – The default retry policy for all ops that compute assets in this job. Only used if retry policy is not defined on the asset definition.
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – <span className="flag flag-danger">deprecated</span>  (Deprecated) Defines the set of partitions for this job. Deprecated because partitioning is inferred from the selected assets, so setting this is redundant.


    Returns: The job, which can be placed inside a code location.Return type: UnresolvedAssetJobDefinition
    Examples:

        ```python
        # A job that targets all assets in the code location:
        @asset
        def asset1():
            ...

        defs = Definitions(
            assets=[asset1],
            jobs=[define_asset_job("all_assets")],
        )

        # A job that targets a single asset
        @asset
        def asset1():
            ...

        defs = Definitions(
            assets=[asset1],
            jobs=[define_asset_job("all_assets", selection=[asset1])],
        )

        # A job that targets all the assets in a group:
        defs = Definitions(
            assets=assets,
            jobs=[define_asset_job("marketing_job", selection=AssetSelection.groups("marketing"))],
        )

        @observable_source_asset
        def source_asset():
            ...

        # A job that observes a source asset:
        defs = Definitions(
            assets=assets,
            jobs=[define_asset_job("observation_job", selection=[source_asset])],
        )

        # Resources are supplied to the assets, not the job:
        @asset(required_resource_keys={"slack_client"})
        def asset1():
            ...

        defs = Definitions(
            assets=[asset1],
            jobs=[define_asset_job("all_assets")],
            resources={"slack_client": prod_slack_client},
        )
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetSelection'>`class` dagster.AssetSelection</Link></dt>
    <dd>

    An AssetSelection defines a query over a set of assets and asset checks, normally all that are defined in a code location.

    You can use the “|”, “&”, and “-” operators to create unions, intersections, and differences of selections, respectively.

    AssetSelections are typically used with [`define_asset_job()`](#dagster.define_asset_job).

    By default, selecting assets will also select all of the asset checks that target those assets.

    Examples:

        ```python
        # Select all assets in group "marketing":
        AssetSelection.groups("marketing")

        # Select all assets in group "marketing", as well as the asset with key "promotion":
        AssetSelection.groups("marketing") | AssetSelection.assets("promotion")

        # Select all assets in group "marketing" that are downstream of asset "leads":
        AssetSelection.groups("marketing") & AssetSelection.assets("leads").downstream()

        # Select a list of assets:
        AssetSelection.assets(*my_assets_list)

        # Select all assets except for those in group "marketing"
        AssetSelection.all() - AssetSelection.groups("marketing")

        # Select all assets which are materialized by the same op as "projections":
        AssetSelection.assets("projections").required_multi_asset_neighbors()

        # Select all assets in group "marketing" and exclude their asset checks:
        AssetSelection.groups("marketing") - AssetSelection.all_asset_checks()

        # Select all asset checks that target a list of assets:
        AssetSelection.checks_for_assets(*my_assets_list)

        # Select a specific asset check:
        AssetSelection.checks(my_asset_check)
        ```
    <dl>
        <dt><Link id='dagster.AssetSelection.all'>`static` all</Link></dt>
        <dd>

        Returns a selection that includes all assets and their asset checks.

        Parameters: <strong>include_sources</strong> (<em>bool</em>) – <span className="flag flag-warning">beta</span>  If True, then include all external assets.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.all_asset_checks'>`static` all_asset_checks</Link></dt>
        <dd>
        Returns a selection that includes all asset checks.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.assets'>`static` assets</Link></dt>
        <dd>

        Returns a selection that includes all of the provided assets and asset checks that target
        them.

        Parameters: <strong>*assets_defs</strong> (<em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em>) – The assets to
        select.
        Examples:

            ```python
            AssetSelection.assets(AssetKey(["a"]))

            AssetSelection.assets("a")

            AssetSelection.assets(AssetKey(["a"]), AssetKey(["b"]))

            AssetSelection.assets("a", "b")

            @asset
            def asset1():
                ...

            AssetSelection.assets(asset1)

            asset_key_list = [AssetKey(["a"]), AssetKey(["b"])]
            AssetSelection.assets(*asset_key_list)
            ```

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.checks'>`static` checks</Link></dt>
        <dd>
        Returns a selection that includes all of the provided asset checks or check keys.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.checks_for_assets'>`static` checks_for_assets</Link></dt>
        <dd>

        Returns a selection with the asset checks that target the provided assets.

        Parameters: <strong>*assets_defs</strong> (<em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em>) – The assets to
        select checks for.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.groups'>`static` groups</Link></dt>
        <dd>

        Returns a selection that includes materializable assets that belong to any of the
        provided groups and all the asset checks that target them.

        Parameters: <strong>include_sources</strong> (<em>bool</em>) – <span className="flag flag-warning">beta</span>  If True, then include external assets matching the group in the
        selection.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.key_prefixes'>`static` key_prefixes</Link></dt>
        <dd>

        Returns a selection that includes assets that match any of the provided key prefixes and all the asset checks that target them.

        Parameters: <strong>include_sources</strong> (<em>bool</em>) – <span className="flag flag-warning">beta</span>  If True, then include external assets matching the key prefix(es)
        in the selection.
        Examples:

            ```python
            # match any asset key where the first segment is equal to "a" or "b"
            # e.g. AssetKey(["a", "b", "c"]) would match, but AssetKey(["abc"]) would not.
            AssetSelection.key_prefixes("a", "b")

            # match any asset key where the first two segments are ["a", "b"] or ["a", "c"]
            AssetSelection.key_prefixes(["a", "b"], ["a", "c"])
            ```

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.keys'>`static` keys</Link></dt>
        <dd>

            :::danger[deprecated]
            This API will be removed in version 2.0.
             Use AssetSelection.assets instead..

            :::

        Returns a selection that includes assets with any of the provided keys and all asset
        checks that target them.

        Deprecated: use AssetSelection.assets instead.

        Examples:

            ```python
            AssetSelection.keys(AssetKey(["a"]))

            AssetSelection.keys("a")

            AssetSelection.keys(AssetKey(["a"]), AssetKey(["b"]))

            AssetSelection.keys("a", "b")

            asset_key_list = [AssetKey(["a"]), AssetKey(["b"])]
            AssetSelection.keys(*asset_key_list)
            ```

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.tag'>`static` tag</Link></dt>
        <dd>

        Returns a selection that includes materializable assets that have the provided tag, and
        all the asset checks that target them.

        Parameters: <strong>include_sources</strong> (<em>bool</em>) – <span className="flag flag-warning">beta</span>  If True, then include external assets matching the group in the
        selection.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.downstream'>downstream</Link></dt>
        <dd>

        Returns a selection that includes all assets that are downstream of any of the assets in
        this selection, selecting the assets in this selection by default. Includes the asset checks targeting the returned assets. Iterates through each
        asset in this selection and returns the union of all downstream assets.

        depth (Optional[int]): If provided, then only include assets to the given depth. A depth
            of 2 means all assets that are children or grandchildren of the assets in this
            selection.

        include_self (bool): If True, then include the assets in this selection in the result.
            If the include_self flag is False, return each downstream asset that is not part of the
            original selection. By default, set to True.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.materializable'>materializable</Link></dt>
        <dd>
        Given an asset selection, returns a new asset selection that contains all of the assets
        that are materializable. Removes any assets which are not materializable.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.required_multi_asset_neighbors'>required_multi_asset_neighbors</Link></dt>
        <dd>
        Given an asset selection in which some assets are output from a multi-asset compute op
        which cannot be subset, returns a new asset selection that contains all of the assets
        required to execute the original asset selection. Includes the asset checks targeting the returned assets.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.roots'>roots</Link></dt>
        <dd>

        Given an asset selection, returns a new asset selection that contains all of the root
        assets within the original asset selection. Includes the asset checks targeting the returned assets.

        A root asset is an asset that has no upstream dependencies within the asset selection.
        The root asset can have downstream dependencies outside of the asset selection.

        Because mixed selections of external and materializable assets are currently not supported,
        keys corresponding to external assets will not be included as roots. To select external assets,
        use the <cite>upstream_source_assets</cite> method.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.sinks'>sinks</Link></dt>
        <dd>

        Given an asset selection, returns a new asset selection that contains all of the sink
        assets within the original asset selection. Includes the asset checks targeting the returned assets.

        A sink asset is an asset that has no downstream dependencies within the asset selection.
        The sink asset can have downstream dependencies outside of the asset selection.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.sources'>sources</Link></dt>
        <dd>

            :::danger[deprecated]
            This API will be removed in version 2.0.
             Use AssetSelection.roots instead..

            :::

        Given an asset selection, returns a new asset selection that contains all of the root
        assets within the original asset selection. Includes the asset checks targeting the returned assets.

        A root asset is a materializable asset that has no upstream dependencies within the asset
        selection. The root asset can have downstream dependencies outside of the asset selection.

        Because mixed selections of external and materializable assets are currently not supported,
        keys corresponding to external assets will not be included as roots. To select external assets,
        use the <cite>upstream_source_assets</cite> method.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.upstream'>upstream</Link></dt>
        <dd>

        Returns a selection that includes all materializable assets that are upstream of any of
        the assets in this selection, selecting the assets in this selection by default. Includes
        the asset checks targeting the returned assets. Iterates through each asset in this
        selection and returns the union of all upstream assets.

        Because mixed selections of external and materializable assets are currently not supported,
        keys corresponding to external assets will not be included as upstream of regular assets.

        Parameters: 
          - <strong>depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – If provided, then only include assets to the given depth. A depth of 2 means all assets that are parents or grandparents of the assets in this selection.
          - <strong>include_self</strong> (<em>bool</em>) – If True, then include the assets in this selection in the result. If the include_self flag is False, return each upstream asset that is not part of the original selection. By default, set to True.



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.upstream_source_assets'>upstream_source_assets</Link></dt>
        <dd>
        Given an asset selection, returns a new asset selection that contains all of the external
        assets that are parents of assets in the original selection. Includes the asset checks
        targeting the returned assets.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.without_checks'>without_checks</Link></dt>
        <dd>
        Removes all asset checks in the selection.
        </dd>

    </dl>

    </dd>

</dl>
</div>


<div class="section" id="code-locations">


## Code locations

Loading assets and asset jobs into a [code location](https://docs.dagster.io/guides/deploy/code-locations/) makes them available to Dagster tools like the UI, CLI, and GraphQL API.

<dl>
    <dt><Link id='dagster.load_assets_from_modules'>dagster.load_assets_from_modules</Link></dt>
    <dd>

    Constructs a list of assets and source assets from the given modules.

    Parameters: 
      - <strong>modules</strong> (<em>Iterable</em><em>[</em><em>ModuleType</em><em>]</em>) – The Python modules to look for assets inside.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Group name to apply to the loaded assets. The returned assets will be copies of the loaded objects, with the group name added.
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Prefix to prepend to the keys of the loaded assets. The returned assets will be copies of the loaded objects, with the prefix prepended.
      - <strong>freshness_policy</strong> (<em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em>) – FreshnessPolicy to apply to all the loaded assets.
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – AutomationCondition to apply to all the loaded assets.
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em><em>AutoMaterializePolicy</em><em>]</em>) – BackfillPolicy to apply to all the loaded assets.
      - <strong>source_key_prefix</strong> (<em>bool</em>) – Prefix to prepend to the keys of loaded SourceAssets. The returned assets will be copies of the loaded objects, with the prefix prepended.


    Returns: A list containing assets and source assets defined in the given modules.Return type: Sequence[Union[[AssetsDefinition](#dagster.AssetsDefinition), [SourceAsset](#dagster.SourceAsset)]]

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.load_assets_from_current_module'>dagster.load_assets_from_current_module</Link></dt>
    <dd>

    Constructs a list of assets, source assets, and cacheable assets from the module where
    this function is called.

    Parameters: 
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Group name to apply to the loaded assets. The returned assets will be copies of the loaded objects, with the group name added.
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Prefix to prepend to the keys of the loaded assets. The returned assets will be copies of the loaded objects, with the prefix prepended.
      - <strong>freshness_policy</strong> (<em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em>) – FreshnessPolicy to apply to all the loaded assets.
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – AutomationCondition to apply to all the loaded assets.
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em><em>AutoMaterializePolicy</em><em>]</em>) – BackfillPolicy to apply to all the loaded assets.
      - <strong>source_key_prefix</strong> (<em>bool</em>) – Prefix to prepend to the keys of loaded SourceAssets. The returned assets will be copies of the loaded objects, with the prefix prepended.


    Returns: A list containing assets, source assets, and cacheable assets defined in the module.Return type: Sequence[Union[[AssetsDefinition](#dagster.AssetsDefinition), [SourceAsset](#dagster.SourceAsset), CachableAssetsDefinition]]

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.load_assets_from_package_module'>dagster.load_assets_from_package_module</Link></dt>
    <dd>

    Constructs a list of assets and source assets that includes all asset
    definitions, source assets, and cacheable assets in all sub-modules of the given package module.

    A package module is the result of importing a package.

    Parameters: 
      - <strong>package_module</strong> (<em>ModuleType</em>) – The package module to looks for assets inside.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Group name to apply to the loaded assets. The returned assets will be copies of the loaded objects, with the group name added.
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Prefix to prepend to the keys of the loaded assets. The returned assets will be copies of the loaded objects, with the prefix prepended.
      - <strong>freshness_policy</strong> (<em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em>) – FreshnessPolicy to apply to all the loaded assets.
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – AutomationCondition to apply to all the loaded assets.
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em><em>AutoMaterializePolicy</em><em>]</em>) – BackfillPolicy to apply to all the loaded assets.
      - <strong>source_key_prefix</strong> (<em>bool</em>) – Prefix to prepend to the keys of loaded SourceAssets. The returned assets will be copies of the loaded objects, with the prefix prepended.


    Returns: A list containing assets, source assets, and cacheable assets defined in the module.Return type: Sequence[Union[[AssetsDefinition](#dagster.AssetsDefinition), [SourceAsset](#dagster.SourceAsset), CacheableAssetsDefinition]]

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.load_assets_from_package_name'>dagster.load_assets_from_package_name</Link></dt>
    <dd>

    Constructs a list of assets, source assets, and cacheable assets that includes all asset
    definitions and source assets in all sub-modules of the given package.

    Parameters: 
      - <strong>package_name</strong> (<em>str</em>) – The name of a Python package to look for assets inside.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Group name to apply to the loaded assets. The returned assets will be copies of the loaded objects, with the group name added.
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Prefix to prepend to the keys of the loaded assets. The returned assets will be copies of the loaded objects, with the prefix prepended.
      - <strong>freshness_policy</strong> (<em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em>) – FreshnessPolicy to apply to all the loaded assets.
      - <strong>auto_materialize_policy</strong> (<em>Optional</em><em>[</em><em>AutoMaterializePolicy</em><em>]</em>) – AutoMaterializePolicy to apply to all the loaded assets.
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em><em>AutoMaterializePolicy</em><em>]</em>) – BackfillPolicy to apply to all the loaded assets.
      - <strong>source_key_prefix</strong> (<em>bool</em>) – Prefix to prepend to the keys of loaded SourceAssets. The returned assets will be copies of the loaded objects, with the prefix prepended.


    Returns: A list containing assets, source assets, and cacheable assets defined in the module.Return type: Sequence[Union[[AssetsDefinition](#dagster.AssetsDefinition), [SourceAsset](#dagster.SourceAsset), CacheableAssetsDefinition]]

    </dd>

</dl>
</div>


<div class="section" id="observations">


## Observations

Refer to the [Asset observation](https://docs.dagster.io/guides/build/assets/metadata-and-tags/asset-observations) documentation for more information.

<dl>
    <dt><Link id='dagster.AssetObservation'>`class` dagster.AssetObservation</Link></dt>
    <dd>

    Event that captures metadata about an asset at a point in time.

    Parameters: 
      - <strong>asset_key</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>List</em><em>[</em><em>str</em><em>]</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em>) – A key to identify the asset.
      - <strong>partition</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of a partition of the asset that the metadata corresponds to.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – A mapping containing tags for the observation.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Union</em><em>[</em><em>str</em><em>, </em><em>float</em><em>, </em><em>int</em><em>, </em>[*MetadataValue*](metadata.mdx#dagster.MetadataValue)<em>]</em><em>]</em><em>]</em>) – Arbitrary metadata about the asset.  Keys are displayed string labels, and values are one of the following: string, float, int, JSON-serializable dict, JSON-serializable list, and one of the data classes returned by a MetadataValue static method.



    </dd>

</dl>
</div>


<div class="section" id="declarative-automation">


## Declarative Automation

Refer to the [Declarative Automation](https://docs.dagster.io/guides/automate/declarative-automation/) documentation for more information.

<dl>
    <dt><Link id='dagster.AutomationCondition'>`class` dagster.AutomationCondition</Link></dt>
    <dd>

    An AutomationCondition represents a condition of an asset that impacts whether it should be
    automatically executed. For example, you can have a condition which becomes true whenever the
    code version of the asset is changed, or whenever an upstream dependency is updated.

        ```python
        from dagster import AutomationCondition, asset

        @asset(automation_condition=AutomationCondition.on_cron("0 0 * * *"))
        def my_asset(): ...
        ```
    AutomationConditions may be combined together into expressions using a variety of operators.

        ```python
        from dagster import AssetSelection, AutomationCondition, asset

        # any dependencies from the "important" group are missing
        any_important_deps_missing = AutomationCondition.any_deps_match(
            AutomationCondition.missing(),
        ).allow(AssetSelection.groups("important"))

        # there is a new code version for this asset since the last time it was requested
        new_code_version = AutomationCondition.code_version_changed().since(
            AutomationCondition.newly_requested()
        )

        # there is a new code version and no important dependencies are missing
        my_condition = new_code_version & ~any_important_deps_missing

        @asset(automation_condition=my_condition)
        def my_asset(): ...
        ```
    <dl>
        <dt><Link id='dagster.AutomationCondition.all_checks_match'>`static` all_checks_match</Link></dt>
        <dd>

        Returns an AutomationCondition that is true for an asset partition if all of its checks
        evaluate to True for the given condition.

        Parameters: 
          - <strong>condition</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – The AutomationCondition that will be evaluated against this asset’s checks.
          - <strong>blocking_only</strong> (<em>bool</em>) – Determines if this condition will only be evaluated against blocking checks. Defaults to False.



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.all_deps_blocking_checks_passed'>`static` all_deps_blocking_checks_passed</Link></dt>
        <dd>

        Returns an AutomationCondition that is true for any partition where all upstream
        blocking checks have passed, or will be requested on this tick.

        In-tick requests are allowed to enable creating runs that target both a parent with
        blocking checks and a child. Even though the checks have not currently passed, if
        they fail within the run, the run machinery will prevent the child from being
        materialized.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.all_deps_match'>`static` all_deps_match</Link></dt>
        <dd>

        Returns an AutomationCondition that is true for a if at least one partition
        of the all of the target’s dependencies evaluate to True for the given condition.

        Parameters: <strong>condition</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – The AutomationCondition that will be evaluated against
        this target’s dependencies.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.all_deps_updated_since_cron'>`static` all_deps_updated_since_cron</Link></dt>
        <dd>
        Returns an AutomatonCondition that is true if all of the target’s dependencies have
        updated since the latest tick of the provided cron schedule.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_checks_match'>`static` any_checks_match</Link></dt>
        <dd>

        Returns an AutomationCondition that is true for if at least one of the target’s
        checks evaluate to True for the given condition.

        Parameters: 
          - <strong>condition</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – The AutomationCondition that will be evaluated against this asset’s checks.
          - <strong>blocking_only</strong> (<em>bool</em>) – Determines if this condition will only be evaluated against blocking checks. Defaults to False.



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_deps_in_progress'>`static` any_deps_in_progress</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target has at least one dependency
        that is in progress.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_deps_match'>`static` any_deps_match</Link></dt>
        <dd>

        Returns an AutomationCondition that is true for a if at least one partition
        of the any of the target’s dependencies evaluate to True for the given condition.

        Parameters: <strong>condition</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – The AutomationCondition that will be evaluated against
        this target’s dependencies.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_deps_missing'>`static` any_deps_missing</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target has at least one dependency
        that is missing, and will not be requested on this tick.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_deps_updated'>`static` any_deps_updated</Link></dt>
        <dd>

        Returns an AutomationCondition that is true if the target has at least one dependency
        that has updated since the previous tick, or will be requested on this tick.

        Will ignore parent updates if the run that updated the parent also plans to update
        the asset or check that this condition is applied to.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_downstream_conditions'>`static` any_downstream_conditions</Link></dt>
        <dd>

            :::warning[beta]
            This API is currently in beta, and may have breaking changes in minor version releases, with behavior changes in patch releases.


            :::

        Returns an AutomationCondition which represents the union of all distinct downstream conditions.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.asset_matches'>`static` asset_matches</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if this condition is true for the given key.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.backfill_in_progress'>`static` backfill_in_progress</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target is part of an in-progress backfill.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.check_failed'>`static` check_failed</Link></dt>
        <dd>
        Returns an AutomationCondition that is true for an asset check if it has evaluated against
        the latest materialization of an asset and failed.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.check_passed'>`static` check_passed</Link></dt>
        <dd>
        Returns an AutomationCondition that is true for an asset check if it has evaluated against
        the latest materialization of an asset and passed.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.code_version_changed'>`static` code_version_changed</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target’s code version has been changed
        since the previous tick.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.cron_tick_passed'>`static` cron_tick_passed</Link></dt>
        <dd>
        Returns an AutomationCondition that is whenever a cron tick of the provided schedule is passed.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.data_version_changed'>`static` data_version_changed</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target’s data version has been changed
        since the previous tick.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.eager'>`static` eager</Link></dt>
        <dd>

        Returns an AutomationCondition which will cause a target to be executed if any of
        its dependencies update, and will execute missing partitions if they become missing
        after this condition is applied to the target.

        This will not execute targets that have any missing or in progress dependencies, or
        are currently in progress.

        For time partitioned assets, only the latest time partition will be considered.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.execution_failed'>`static` execution_failed</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the latest execution of the target failed.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.in_latest_time_window'>`static` in_latest_time_window</Link></dt>
        <dd>

        Returns an AutomationCondition that is true when the target it is within the latest
        time window.

        Parameters: <strong>lookback_delta</strong> (<em>Optional</em><em>, </em><em>datetime.timedelta</em>) – If provided, the condition will
        return all partitions within the provided delta of the end of the latest time window.
        For example, if this is used on a daily-partitioned asset with a lookback_delta of
        48 hours, this will return the latest two partitions.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.in_progress'>`static` in_progress</Link></dt>
        <dd>
        Returns an AutomationCondition that is true for an asset partition if it is part of an
        in-progress run or backfill.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.initial_evaluation'>`static` initial_evaluation</Link></dt>
        <dd>
        Returns an AutomationCondition that is true on the first evaluation of the expression.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.missing'>`static` missing</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target has not been executed.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.newly_missing'>`static` newly_missing</Link></dt>
        <dd>
        Returns an AutomationCondition that is true on the tick that the target becomes missing.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.newly_requested'>`static` newly_requested</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target was requested on the previous tick.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.newly_updated'>`static` newly_updated</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target has been updated since the previous tick.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.on_cron'>`static` on_cron</Link></dt>
        <dd>

        Returns an AutomationCondition which will cause a target to be executed on a given
        cron schedule, after all of its dependencies have been updated since the latest
        tick of that cron schedule.

        For time partitioned assets, only the latest time partition will be considered.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.on_missing'>`static` on_missing</Link></dt>
        <dd>

        Returns an AutomationCondition which will execute partitions of the target that
        are added after this condition is applied to the asset.

        This will not execute targets that have any missing dependencies.

        For time partitioned assets, only the latest time partition will be considered.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.run_in_progress'>`static` run_in_progress</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target is part of an in-progress run.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.will_be_requested'>`static` will_be_requested</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target will be requested this tick.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.replace'>replace</Link></dt>
        <dd>

        Replaces all instances of `old` across any sub-conditions with `new`.

        If `old` is a string, then conditions with a label matching
        that string will be replaced.

        Parameters: 
          - <strong>old</strong> (<em>Union</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>, </em><em>str</em><em>]</em>) – The condition to replace.
          - <strong>new</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – The condition to replace with.



        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AutomationConditionSensorDefinition'>`class` dagster.AutomationConditionSensorDefinition</Link></dt>
    <dd>

    Targets a set of assets and repeatedly evaluates all the AutomationConditions on all of
    those assets to determine which to request runs for.

    Parameters: 
      - <strong>name</strong> – The name of the sensor.
      - <strong>target</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Sequence</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>, </em><em>Sequence</em><em>[</em><em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*SourceAsset*](#dagster.SourceAsset)<em>]</em><em>]</em><em>, </em>[*AssetSelection*](#dagster.AssetSelection)<em>]</em>) – A selection of assets to evaluate AutomationConditions of and request runs for.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – A set of key-value tags that annotate the sensor and can be used for searching and filtering in the UI.
      - <strong>run_tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – Tags that will be automatically attached to runs launched by this sensor.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – A set of metadata entries that annotate the sensor. Values will be normalized to typed <cite>MetadataValue</cite> objects.
      - <strong>default_status</strong> (<em>DefaultSensorStatus</em>) – Whether the sensor starts as running or not. The default status can be overridden from the Dagster UI or via the GraphQL API.
      - <strong>minimum_interval_seconds</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The frequency at which to try to evaluate the sensor. The actual interval will be longer if the sensor evaluation takes longer than the provided interval.
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A human-readable description of the sensor.
      - <strong>emit_backfills</strong> (<em>bool</em>) – If set to True, will emit a backfill on any tick where more than one partition of any single asset is requested, rather than individual runs. Defaults to True.
      - <strong>use_user_code_server</strong> (<em>bool</em>) – <span className="flag flag-warning">beta</span>  (Beta) If set to True, this sensor will be evaluated in the user code server, rather than the AssetDaemon. This enables evaluating custom AutomationCondition subclasses, and ensures that the condition definitions will remain in sync with your user code version, eliminating version skew. Note: currently a maximum of 500 assets or checks may be targeted at a time by a sensor that has this value set.
      - <strong>default_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – <span className="flag flag-warning">beta</span>  (Beta) If provided, this condition will be used for any selected assets or asset checks which do not have an automation condition defined. Requires <cite>use_user_code_server</cite> to be set to <cite>True</cite>.


    Examples:

        ```python
        import dagster as dg

        # automation condition sensor that defaults to running
        defs1 = dg.Definitions(
            assets=...,
            sensors=[
                dg.AutomationConditionSensorDefinition(
                    name="automation_condition_sensor",
                    target=dg.AssetSelection.all(),
                    default_status=dg.DefaultSensorStatus.RUNNING,
                ),
            ]
        )

        # one automation condition sensor per group
        defs2 = dg.Definitions(
            assets=...,
            sensors=[
                dg.AutomationConditionSensorDefinition(
                    name="raw_data_automation_condition_sensor",
                    target=dg.AssetSelection.groups("raw_data"),
                ),
                dg.AutomationConditionSensorDefinition(
                    name="ml_automation_condition_sensor",
                    target=dg.AssetSelection.groups("machine_learning"),
                ),
            ]
        )
        ```

    </dd>

</dl>
</div>


<div class="section" id="asset-values">

## Asset values

<dl>
    <dt><Link id='dagster.AssetValueLoader'>`class` dagster.AssetValueLoader</Link></dt>
    <dd>

    Caches resource definitions that are used to load asset values across multiple load
    invocations.

    Should not be instantiated directly. Instead, use
    [`get_asset_value_loader()`](repositories.mdx#dagster.RepositoryDefinition.get_asset_value_loader).

    <dl>
        <dt><Link id='dagster.AssetValueLoader.load_asset_value'>load_asset_value</Link></dt>
        <dd>

        Loads the contents of an asset as a Python object.

        Invokes <cite>load_input</cite> on the [`IOManager`](io-managers.mdx#dagster.IOManager) associated with the asset.

        Parameters: 
          - <strong>asset_key</strong> (<em>Union</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em><em>str</em><em>]</em>) – The key of the asset to load.
          - <strong>python_type</strong> (<em>Optional</em><em>[</em><em>Type</em><em>]</em>) – The python type to load the asset as. This is what will be returned inside <cite>load_input</cite> by <cite>context.dagster_type.typing_type</cite>.
          - <strong>partition_key</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The partition of the asset to load.
          - <strong>input_definition_metadata</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – Input metadata to pass to the [`IOManager`](io-managers.mdx#dagster.IOManager) (is equivalent to setting the metadata argument in <cite>In</cite> or <cite>AssetIn</cite>).
          - <strong>resource_config</strong> (<em>Optional</em><em>[</em><em>Any</em><em>]</em>) – A dictionary of resource configurations to be passed to the [`IOManager`](io-managers.mdx#dagster.IOManager).


        Returns: The contents of an asset as a Python object.

        </dd>

    </dl>

    </dd>

</dl>
</div></div>
