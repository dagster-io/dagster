---
title: 'partitions definitions'
title_meta: 'partitions definitions API Documentation - Build Better Data Pipelines | Python Reference Documentation for Dagster'
description: 'partitions definitions Dagster API | Comprehensive Python API documentation for Dagster, the data orchestration platform. Learn how to build, test, and maintain data pipelines with our detailed guides and examples.'
last_update:
  date: '2025-03-03'
---

<div class="section" id="partitions-definitions">


# Partitions Definitions

<dl>
    <dt><Link id='dagster.PartitionsDefinition'>`class` dagster.PartitionsDefinition</Link></dt>
    <dd>

    Defines a set of partitions, which can be attached to a software-defined asset or job.

    Abstract class with implementations for different kinds of partitions.

    <dl>
        <dt><Link id='dagster.PartitionsDefinition.get_partition_keys'>`abstractmethod` get_partition_keys</Link></dt>
        <dd>

        Returns a list of strings representing the partition keys of the PartitionsDefinition.

        Parameters: 
          - <strong>current_time</strong> (<em>Optional</em><em>[</em><em>datetime</em><em>]</em>) – A datetime object representing the current time, only applicable to time-based partitions definitions.
          - <strong>dynamic_partitions_store</strong> (<em>Optional</em><em>[</em><em>DynamicPartitionsStore</em><em>]</em>) – The DynamicPartitionsStore object that is responsible for fetching dynamic partitions. Required when the partitions definition is a DynamicPartitionsDefinition with a name defined. Users can pass the DagsterInstance fetched via <cite>context.instance</cite> to this argument.


        Returns: Sequence[str]

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.HourlyPartitionsDefinition'>`class` dagster.HourlyPartitionsDefinition</Link></dt>
    <dd>

    A set of hourly partitions.

    The first partition in the set will start on the start_date at midnight. The last partition
    in the set will end before the current time, unless the end_offset argument is set to a
    positive number. If minute_offset is provided, the start and end times of each partition
    will be minute_offset past the hour.

    Parameters: 
      - <strong>start_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>]</em>) – The first date in the set of partitions. Can provide in either a datetime or string format.
      - <strong>end_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>, </em><em>None</em><em>]</em>) – The last date(excluding) in the set of partitions. Default is None. Can provide in either a datetime or string format.
      - <strong>minute_offset</strong> (<em>int</em>) – Number of minutes past the hour to “split” the partition. Defaults to 0.
      - <strong>fmt</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The date format to use. Defaults to <cite>%Y-%m-%d</cite>. Note that if a non-UTC timezone is used, the date format must include a timezone offset to disambiguate between multiple instances of the same time before and after the Fall DST transition. If the format does not contain this offset, the second instance of the ambiguous time partition key will have the UTC offset automatically appended to it.
      - <strong>timezone</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The timezone in which each date should exist. Supported strings for timezones are the ones provided by the <cite>IANA time zone database \<https://www.iana.org/time-zones></cite> - e.g. “America/Los_Angeles”.
      - <strong>end_offset</strong> (<em>int</em>) – Extends the partition set by a number of partitions equal to the value passed. If end_offset is 0 (the default), the last partition ends before the current time. If end_offset is 1, the second-to-last partition ends before the current time, and so on.


        ```python
        HourlyPartitionsDefinition(start_date=datetime(2022, 03, 12))
        # creates partitions (2022-03-12-00:00, 2022-03-12-01:00), (2022-03-12-01:00, 2022-03-12-02:00), ...

        HourlyPartitionsDefinition(start_date=datetime(2022, 03, 12), minute_offset=15)
        # creates partitions (2022-03-12-00:15, 2022-03-12-01:15), (2022-03-12-01:15, 2022-03-12-02:15), ...
        ```
    <dl>
        <dt><Link id='dagster.HourlyPartitionsDefinition.get_cron_schedule'>get_cron_schedule</Link></dt>
        <dd>

        The schedule executes at the cadence specified by the partitioning, but may overwrite
        the minute/hour/day offset of the partitioning.

        This is useful e.g. if you have partitions that span midnight to midnight but you want to
        schedule a job that runs at 2 am.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.HourlyPartitionsDefinition.day_offset'>`property` day_offset</Link></dt>
        <dd>

        For a weekly or monthly partitions definition, returns the day to “split” partitions
        by. Each partition will start on this day, and end before this day in the following
        week/month. Returns 0 if the day_offset parameter is unset in the
        WeeklyPartitionsDefinition, MonthlyPartitionsDefinition, or the provided cron schedule.

        For weekly partitions, returns a value between 0 (representing Sunday) and 6 (representing
        Saturday). Providing a value of 1 means that a partition will exist weekly from Monday to
        the following Sunday.

        For monthly partitions, returns a value between 0 (the first day of the month) and 31 (the
        last possible day of the month).

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.HourlyPartitionsDefinition.end'>`property` end</Link></dt>
        <dd>

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.HourlyPartitionsDefinition.hour_offset'>`property` hour_offset</Link></dt>
        <dd>

        Number of hours past 00:00 to “split” partitions. Defaults to 0.

        For example, returns 1 if each partition starts at 01:00.

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.HourlyPartitionsDefinition.minute_offset'>`property` minute_offset</Link></dt>
        <dd>

        Number of minutes past the hour to “split” partitions. Defaults to 0.

        For example, returns 15 if each partition starts at 15 minutes past the hour.

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.HourlyPartitionsDefinition.schedule_type'>`property` schedule_type</Link></dt>
        <dd>

        An enum representing the partition cadence (hourly, daily,
        weekly, or monthly).

        Type: Optional[ScheduleType]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.HourlyPartitionsDefinition.start'>`property` start</Link></dt>
        <dd>

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.DailyPartitionsDefinition'>`class` dagster.DailyPartitionsDefinition</Link></dt>
    <dd>

    A set of daily partitions.

    The first partition in the set will start at the start_date at midnight. The last partition
    in the set will end before the current time, unless the end_offset argument is set to a
    positive number. If minute_offset and/or hour_offset are used, the start and end times of
    each partition will be hour_offset:minute_offset of each day.

    Parameters: 
      - <strong>start_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>]</em>) – The first date in the set of partitions. Can provide in either a datetime or string format.
      - <strong>end_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>, </em><em>None</em><em>]</em>) – The last date(excluding) in the set of partitions. Default is None. Can provide in either a datetime or string format.
      - <strong>minute_offset</strong> (<em>int</em>) – Number of minutes past the hour to “split” the partition. Defaults to 0.
      - <strong>hour_offset</strong> (<em>int</em>) – Number of hours past 00:00 to “split” the partition. Defaults to 0.
      - <strong>timezone</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The timezone in which each date should exist. Supported strings for timezones are the ones provided by the <cite>IANA time zone database \<https://www.iana.org/time-zones></cite> - e.g. “America/Los_Angeles”.
      - <strong>fmt</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The date format to use. Defaults to <cite>%Y-%m-%d</cite>.
      - <strong>end_offset</strong> (<em>int</em>) – Extends the partition set by a number of partitions equal to the value passed. If end_offset is 0 (the default), the last partition ends before the current time. If end_offset is 1, the second-to-last partition ends before the current time, and so on.


        ```python
        DailyPartitionsDefinition(start_date="2022-03-12")
        # creates partitions (2022-03-12-00:00, 2022-03-13-00:00), (2022-03-13-00:00, 2022-03-14-00:00), ...

        DailyPartitionsDefinition(start_date="2022-03-12", minute_offset=15, hour_offset=16)
        # creates partitions (2022-03-12-16:15, 2022-03-13-16:15), (2022-03-13-16:15, 2022-03-14-16:15), ...
        ```
    <dl>
        <dt><Link id='dagster.DailyPartitionsDefinition.get_cron_schedule'>get_cron_schedule</Link></dt>
        <dd>

        The schedule executes at the cadence specified by the partitioning, but may overwrite
        the minute/hour/day offset of the partitioning.

        This is useful e.g. if you have partitions that span midnight to midnight but you want to
        schedule a job that runs at 2 am.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.DailyPartitionsDefinition.day_offset'>`property` day_offset</Link></dt>
        <dd>

        For a weekly or monthly partitions definition, returns the day to “split” partitions
        by. Each partition will start on this day, and end before this day in the following
        week/month. Returns 0 if the day_offset parameter is unset in the
        WeeklyPartitionsDefinition, MonthlyPartitionsDefinition, or the provided cron schedule.

        For weekly partitions, returns a value between 0 (representing Sunday) and 6 (representing
        Saturday). Providing a value of 1 means that a partition will exist weekly from Monday to
        the following Sunday.

        For monthly partitions, returns a value between 0 (the first day of the month) and 31 (the
        last possible day of the month).

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.DailyPartitionsDefinition.end'>`property` end</Link></dt>
        <dd>

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.DailyPartitionsDefinition.hour_offset'>`property` hour_offset</Link></dt>
        <dd>

        Number of hours past 00:00 to “split” partitions. Defaults to 0.

        For example, returns 1 if each partition starts at 01:00.

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.DailyPartitionsDefinition.minute_offset'>`property` minute_offset</Link></dt>
        <dd>

        Number of minutes past the hour to “split” partitions. Defaults to 0.

        For example, returns 15 if each partition starts at 15 minutes past the hour.

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.DailyPartitionsDefinition.schedule_type'>`property` schedule_type</Link></dt>
        <dd>

        An enum representing the partition cadence (hourly, daily,
        weekly, or monthly).

        Type: Optional[ScheduleType]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.DailyPartitionsDefinition.start'>`property` start</Link></dt>
        <dd>

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.WeeklyPartitionsDefinition'>`class` dagster.WeeklyPartitionsDefinition</Link></dt>
    <dd>

    Defines a set of weekly partitions.

    The first partition in the set will start at the start_date. The last partition in the set will
    end before the current time, unless the end_offset argument is set to a positive number. If
    day_offset is provided, the start and end date of each partition will be day of the week
    corresponding to day_offset (0 indexed with Sunday as the start of the week). If
    minute_offset and/or hour_offset are used, the start and end times of each partition will be
    hour_offset:minute_offset of each day.

    Parameters: 
      - <strong>start_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>]</em>) – The first date in the set of partitions will Sunday at midnight following start_date. Can provide in either a datetime or string format.
      - <strong>end_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>, </em><em>None</em><em>]</em>) – The last date(excluding) in the set of partitions. Default is None. Can provide in either a datetime or string format.
      - <strong>minute_offset</strong> (<em>int</em>) – Number of minutes past the hour to “split” the partition. Defaults to 0.
      - <strong>hour_offset</strong> (<em>int</em>) – Number of hours past 00:00 to “split” the partition. Defaults to 0.
      - <strong>day_offset</strong> (<em>int</em>) – Day of the week to “split” the partition. Defaults to 0 (Sunday).
      - <strong>timezone</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The timezone in which each date should exist. Supported strings for timezones are the ones provided by the <cite>IANA time zone database \<https://www.iana.org/time-zones></cite> - e.g. “America/Los_Angeles”.
      - <strong>fmt</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The date format to use. Defaults to <cite>%Y-%m-%d</cite>.
      - <strong>end_offset</strong> (<em>int</em>) – Extends the partition set by a number of partitions equal to the value passed. If end_offset is 0 (the default), the last partition ends before the current time. If end_offset is 1, the second-to-last partition ends before the current time, and so on.


        ```python
        WeeklyPartitionsDefinition(start_date="2022-03-12")
        # creates partitions (2022-03-13-00:00, 2022-03-20-00:00), (2022-03-20-00:00, 2022-03-27-00:00), ...

        WeeklyPartitionsDefinition(start_date="2022-03-12", minute_offset=15, hour_offset=3, day_offset=6)
        # creates partitions (2022-03-12-03:15, 2022-03-19-03:15), (2022-03-19-03:15, 2022-03-26-03:15), ...
        ```
    <dl>
        <dt><Link id='dagster.WeeklyPartitionsDefinition.get_cron_schedule'>get_cron_schedule</Link></dt>
        <dd>

        The schedule executes at the cadence specified by the partitioning, but may overwrite
        the minute/hour/day offset of the partitioning.

        This is useful e.g. if you have partitions that span midnight to midnight but you want to
        schedule a job that runs at 2 am.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.WeeklyPartitionsDefinition.day_offset'>`property` day_offset</Link></dt>
        <dd>

        For a weekly or monthly partitions definition, returns the day to “split” partitions
        by. Each partition will start on this day, and end before this day in the following
        week/month. Returns 0 if the day_offset parameter is unset in the
        WeeklyPartitionsDefinition, MonthlyPartitionsDefinition, or the provided cron schedule.

        For weekly partitions, returns a value between 0 (representing Sunday) and 6 (representing
        Saturday). Providing a value of 1 means that a partition will exist weekly from Monday to
        the following Sunday.

        For monthly partitions, returns a value between 0 (the first day of the month) and 31 (the
        last possible day of the month).

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.WeeklyPartitionsDefinition.end'>`property` end</Link></dt>
        <dd>

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.WeeklyPartitionsDefinition.hour_offset'>`property` hour_offset</Link></dt>
        <dd>

        Number of hours past 00:00 to “split” partitions. Defaults to 0.

        For example, returns 1 if each partition starts at 01:00.

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.WeeklyPartitionsDefinition.minute_offset'>`property` minute_offset</Link></dt>
        <dd>

        Number of minutes past the hour to “split” partitions. Defaults to 0.

        For example, returns 15 if each partition starts at 15 minutes past the hour.

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.WeeklyPartitionsDefinition.schedule_type'>`property` schedule_type</Link></dt>
        <dd>

        An enum representing the partition cadence (hourly, daily,
        weekly, or monthly).

        Type: Optional[ScheduleType]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.WeeklyPartitionsDefinition.start'>`property` start</Link></dt>
        <dd>

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.MonthlyPartitionsDefinition'>`class` dagster.MonthlyPartitionsDefinition</Link></dt>
    <dd>

    A set of monthly partitions.

    The first partition in the set will start at the soonest first of the month after start_date
    at midnight. The last partition in the set will end before the current time, unless the
    end_offset argument is set to a positive number. If day_offset is provided, the start and
    end date of each partition will be day_offset. If minute_offset and/or hour_offset are used,
    the start and end times of each partition will be hour_offset:minute_offset of each day.

    Parameters: 
      - <strong>start_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>]</em>) – The first date in the set of partitions will be midnight the soonest first of the month following start_date. Can provide in either a datetime or string format.
      - <strong>end_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>, </em><em>None</em><em>]</em>) – The last date(excluding) in the set of partitions. Default is None. Can provide in either a datetime or string format.
      - <strong>minute_offset</strong> (<em>int</em>) – Number of minutes past the hour to “split” the partition. Defaults to 0.
      - <strong>hour_offset</strong> (<em>int</em>) – Number of hours past 00:00 to “split” the partition. Defaults to 0.
      - <strong>day_offset</strong> (<em>int</em>) – Day of the month to “split” the partition. Defaults to 1.
      - <strong>timezone</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The timezone in which each date should exist. Supported strings for timezones are the ones provided by the <cite>IANA time zone database \<https://www.iana.org/time-zones></cite> - e.g. “America/Los_Angeles”.
      - <strong>fmt</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The date format to use. Defaults to <cite>%Y-%m-%d</cite>.
      - <strong>end_offset</strong> (<em>int</em>) – Extends the partition set by a number of partitions equal to the value passed. If end_offset is 0 (the default), the last partition ends before the current time. If end_offset is 1, the second-to-last partition ends before the current time, and so on.


        ```python
        MonthlyPartitionsDefinition(start_date="2022-03-12")
        # creates partitions (2022-04-01-00:00, 2022-05-01-00:00), (2022-05-01-00:00, 2022-06-01-00:00), ...

        MonthlyPartitionsDefinition(start_date="2022-03-12", minute_offset=15, hour_offset=3, day_offset=5)
        # creates partitions (2022-04-05-03:15, 2022-05-05-03:15), (2022-05-05-03:15, 2022-06-05-03:15), ...
        ```
    <dl>
        <dt><Link id='dagster.MonthlyPartitionsDefinition.get_cron_schedule'>get_cron_schedule</Link></dt>
        <dd>

        The schedule executes at the cadence specified by the partitioning, but may overwrite
        the minute/hour/day offset of the partitioning.

        This is useful e.g. if you have partitions that span midnight to midnight but you want to
        schedule a job that runs at 2 am.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.MonthlyPartitionsDefinition.day_offset'>`property` day_offset</Link></dt>
        <dd>

        For a weekly or monthly partitions definition, returns the day to “split” partitions
        by. Each partition will start on this day, and end before this day in the following
        week/month. Returns 0 if the day_offset parameter is unset in the
        WeeklyPartitionsDefinition, MonthlyPartitionsDefinition, or the provided cron schedule.

        For weekly partitions, returns a value between 0 (representing Sunday) and 6 (representing
        Saturday). Providing a value of 1 means that a partition will exist weekly from Monday to
        the following Sunday.

        For monthly partitions, returns a value between 0 (the first day of the month) and 31 (the
        last possible day of the month).

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.MonthlyPartitionsDefinition.end'>`property` end</Link></dt>
        <dd>

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.MonthlyPartitionsDefinition.hour_offset'>`property` hour_offset</Link></dt>
        <dd>

        Number of hours past 00:00 to “split” partitions. Defaults to 0.

        For example, returns 1 if each partition starts at 01:00.

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.MonthlyPartitionsDefinition.minute_offset'>`property` minute_offset</Link></dt>
        <dd>

        Number of minutes past the hour to “split” partitions. Defaults to 0.

        For example, returns 15 if each partition starts at 15 minutes past the hour.

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.MonthlyPartitionsDefinition.schedule_type'>`property` schedule_type</Link></dt>
        <dd>

        An enum representing the partition cadence (hourly, daily,
        weekly, or monthly).

        Type: Optional[ScheduleType]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.MonthlyPartitionsDefinition.start'>`property` start</Link></dt>
        <dd>

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.TimeWindowPartitionsDefinition'>`class` dagster.TimeWindowPartitionsDefinition</Link></dt>
    <dd>

    A set of partitions where each partition corresponds to a time window.

    The provided cron_schedule determines the bounds of the time windows. E.g. a cron_schedule of
    “0 0 \* \* \*” will result in daily partitions that start at midnight and end at midnight of the
    following day.

    The string partition_key associated with each partition corresponds to the start of the
    partition’s time window.

    The first partition in the set will start on at the first cron_schedule tick that is equal to
    or after the given start datetime. The last partition in the set will end before the current
    time, unless the end_offset argument is set to a positive number.

    We recommended limiting partition counts for each asset to 25,000 partitions or fewer.

    Parameters: 
      - <strong>cron_schedule</strong> (<em>str</em>) – Determines the bounds of the time windows.
      - <strong>start</strong> (<em>datetime</em>) – The first partition in the set will start on at the first cron_schedule tick that is equal to or after this value.
      - <strong>timezone</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The timezone in which each time should exist. Supported strings for timezones are the ones provided by the <cite>IANA time zone database \<https://www.iana.org/time-zones></cite> - e.g. “America/Los_Angeles”.
      - <strong>end</strong> (<em>datetime</em>) – The last partition (excluding) in the set.
      - <strong>fmt</strong> (<em>str</em>) – The date format to use for partition_keys. Note that if a non-UTC timezone is used, and the cron schedule repeats every hour or faster, the date format must include a timezone offset to disambiguate between multiple instances of the same time before and after the Fall DST transition. If the format does not contain this offset, the second instance of the ambiguous time partition key will have the UTC offset automatically appended to it.
      - <strong>end_offset</strong> (<em>int</em>) – Extends the partition set by a number of partitions equal to the value passed. If end_offset is 0 (the default), the last partition ends before the current time. If end_offset is 1, the second-to-last partition ends before the current time, and so on.


    <dl>
        <dt><Link id='dagster.TimeWindowPartitionsDefinition.get_cron_schedule'>get_cron_schedule</Link></dt>
        <dd>

        The schedule executes at the cadence specified by the partitioning, but may overwrite
        the minute/hour/day offset of the partitioning.

        This is useful e.g. if you have partitions that span midnight to midnight but you want to
        schedule a job that runs at 2 am.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.TimeWindowPartitionsDefinition.day_offset'>`property` day_offset</Link></dt>
        <dd>

        For a weekly or monthly partitions definition, returns the day to “split” partitions
        by. Each partition will start on this day, and end before this day in the following
        week/month. Returns 0 if the day_offset parameter is unset in the
        WeeklyPartitionsDefinition, MonthlyPartitionsDefinition, or the provided cron schedule.

        For weekly partitions, returns a value between 0 (representing Sunday) and 6 (representing
        Saturday). Providing a value of 1 means that a partition will exist weekly from Monday to
        the following Sunday.

        For monthly partitions, returns a value between 0 (the first day of the month) and 31 (the
        last possible day of the month).

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.TimeWindowPartitionsDefinition.end'>`property` end</Link></dt>
        <dd>

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.TimeWindowPartitionsDefinition.hour_offset'>`property` hour_offset</Link></dt>
        <dd>

        Number of hours past 00:00 to “split” partitions. Defaults to 0.

        For example, returns 1 if each partition starts at 01:00.

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.TimeWindowPartitionsDefinition.minute_offset'>`property` minute_offset</Link></dt>
        <dd>

        Number of minutes past the hour to “split” partitions. Defaults to 0.

        For example, returns 15 if each partition starts at 15 minutes past the hour.

        Type: int

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.TimeWindowPartitionsDefinition.schedule_type'>`property` schedule_type</Link></dt>
        <dd>

        An enum representing the partition cadence (hourly, daily,
        weekly, or monthly).

        Type: Optional[ScheduleType]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.TimeWindowPartitionsDefinition.start'>`property` start</Link></dt>
        <dd>

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.TimeWindow'>`class` dagster.TimeWindow</Link></dt>
    <dd>

    An interval that is closed at the start and open at the end.

    Parameters: 
      - <strong>start</strong> (<em>datetime</em>) – A datetime that marks the start of the window.
      - <strong>end</strong> (<em>datetime</em>) – A datetime that marks the end of the window.



    </dd>

</dl>
<dl>
    <dt><Link id='dagster.StaticPartitionsDefinition'>`class` dagster.StaticPartitionsDefinition</Link></dt>
    <dd>

    A statically-defined set of partitions.

    We recommended limiting partition counts for each asset to 25,000 partitions or fewer.

    Example:

        ```python
        from dagster import StaticPartitionsDefinition, asset

        oceans_partitions_def = StaticPartitionsDefinition(
            ["arctic", "atlantic", "indian", "pacific", "southern"]
        )

        @asset(partitions_def=oceans_partitions_defs)
        def ml_model_for_each_ocean():
            ...
        ```
    <dl>
        <dt><Link id='dagster.StaticPartitionsDefinition.get_partition_keys'>get_partition_keys</Link></dt>
        <dd>

        Returns a list of strings representing the partition keys of the PartitionsDefinition.

        Parameters: 
          - <strong>current_time</strong> (<em>Optional</em><em>[</em><em>datetime</em><em>]</em>) – A datetime object representing the current time, only applicable to time-based partitions definitions.
          - <strong>dynamic_partitions_store</strong> (<em>Optional</em><em>[</em><em>DynamicPartitionsStore</em><em>]</em>) – The DynamicPartitionsStore object that is responsible for fetching dynamic partitions. Only applicable to DynamicPartitionsDefinitions.


        Returns: Sequence[str]

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.MultiPartitionsDefinition'>`class` dagster.MultiPartitionsDefinition</Link></dt>
    <dd>

    Takes the cross-product of partitions from two partitions definitions.

    For example, with a static partitions definition where the partitions are [“a”, “b”, “c”]
    and a daily partitions definition, this partitions definition will have the following
    partitions:

    2020-01-01|a
    2020-01-01|b
    2020-01-01|c
    2020-01-02|a
    2020-01-02|b
    …

    We recommended limiting partition counts for each asset to 25,000 partitions or fewer.

    Parameters: 
      - <strong>partitions_defs</strong> (<em>Sequence</em><em>[</em><em>PartitionDimensionDefinition</em><em>]</em>) – A mapping of dimension name to partitions definition. The total set of partitions will be the cross-product of the partitions from each PartitionsDefinition.
      - <strong>partitions_defs</strong> – A sequence of PartitionDimensionDefinition objects, each of which contains a dimension name and a PartitionsDefinition. The total set of partitions will be the cross-product of the partitions from each PartitionsDefinition. This sequence is ordered by dimension name, to ensure consistent ordering of the partitions.


    <dl>
        <dt><Link id='dagster.MultiPartitionsDefinition.get_partition_keys'>get_partition_keys</Link></dt>
        <dd>

        Returns a list of MultiPartitionKeys representing the partition keys of the
        PartitionsDefinition.

        Parameters: 
          - <strong>current_time</strong> (<em>Optional</em><em>[</em><em>datetime</em><em>]</em>) – A datetime object representing the current time, only applicable to time-based partition dimensions.
          - <strong>dynamic_partitions_store</strong> (<em>Optional</em><em>[</em><em>DynamicPartitionsStore</em><em>]</em>) – The DynamicPartitionsStore object that is responsible for fetching dynamic partitions. Required when a dimension is a DynamicPartitionsDefinition with a name defined. Users can pass the DagsterInstance fetched via <cite>context.instance</cite> to this argument.


        Returns: Sequence[MultiPartitionKey]

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.MultiPartitionKey'>`class` dagster.MultiPartitionKey</Link></dt>
    <dd>

    A multi-dimensional partition key stores the partition key for each dimension.
    Subclasses the string class to keep partition key type as a string.

    Contains additional methods to access the partition key for each dimension.
    Creates a string representation of the partition key for each dimension, separated by a pipe (|).
    Orders the dimensions by name, to ensure consistent string representation.


    </dd>

</dl>
<dl>
    <dt><Link id='dagster.DynamicPartitionsDefinition'>`class` dagster.DynamicPartitionsDefinition</Link></dt>
    <dd>

    A partitions definition whose partition keys can be dynamically added and removed.

    This is useful for cases where the set of partitions is not known at definition time,
    but is instead determined at runtime.

    Partitions can be added and removed using <cite>instance.add_dynamic_partitions</cite> and
    <cite>instance.delete_dynamic_partition</cite> methods.

    We recommended limiting partition counts for each asset to 25,000 partitions or fewer.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the partitions definition.
      - <strong>partition_fn</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Optional</em><em>[</em><em>datetime</em><em>]</em><em>]</em><em>, </em><em>Union</em><em>[</em><em>Sequence</em><em>[</em><em>Partition</em><em>]</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em><em>]</em>) – <span className="flag flag-danger">deprecated</span>  A function that returns the current set of partitions. This argument is deprecated and will be removed in 2.0.0.


    Examples:

        ```python
        fruits = DynamicPartitionsDefinition(name="fruits")

        @sensor(job=my_job)
        def my_sensor(context):
            return SensorResult(
                run_requests=[RunRequest(partition_key="apple")],
                dynamic_partitions_requests=[fruits.build_add_request(["apple"])]
            )
        ```
    <dl>
        <dt><Link id='dagster.DynamicPartitionsDefinition.get_partition_keys'>get_partition_keys</Link></dt>
        <dd>

        Returns a list of strings representing the partition keys of the
        PartitionsDefinition.

        Parameters: 
          - <strong>current_time</strong> (<em>Optional</em><em>[</em><em>datetime</em><em>]</em>) – A datetime object representing the current time, only applicable to time-based partitions definitions.
          - <strong>dynamic_partitions_store</strong> (<em>Optional</em><em>[</em><em>DynamicPartitionsStore</em><em>]</em>) – The DynamicPartitionsStore object that is responsible for fetching dynamic partitions. Required when the partitions definition is a DynamicPartitionsDefinition with a name defined. Users can pass the DagsterInstance fetched via <cite>context.instance</cite> to this argument.


        Returns: Sequence[str]

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.PartitionKeyRange'>`class` dagster.PartitionKeyRange</Link></dt>
    <dd>

    Defines a range of partitions.

    Parameters: 
      - <strong>start</strong> (<em>str</em>) – The starting partition key in the range (inclusive).
      - <strong>end</strong> (<em>str</em>) – The ending partition key in the range (inclusive).


    Examples:

        ```python
        partitions_def = StaticPartitionsDefinition(["a", "b", "c", "d"])
        partition_key_range = PartitionKeyRange(start="a", end="c") # Represents ["a", "b", "c"]
        ```

    </dd>

</dl>
</div>


<div class="section" id="partitioned-schedules">


# Partitioned Schedules

<dl>
    <dt>dagster.build_schedule_from_partitioned_job</dt>
    <dd>

    Creates a schedule from a job that targets
    time window-partitioned or statically-partitioned assets. The job can also be
    multi-partitioned, as long as one of the partition dimensions is time-partitioned.

    The schedule executes at the cadence specified by the time partitioning of the job or assets.

    <strong>Example:</strong>
            ```python
            ######################################
            # Job that targets partitioned assets
            ######################################

            from dagster import (
                DailyPartitionsDefinition,
                asset,
                build_schedule_from_partitioned_job,
                define_asset_job,
                Definitions,
            )

            @asset(partitions_def=DailyPartitionsDefinition(start_date="2020-01-01"))
            def asset1():
                ...

            asset1_job = define_asset_job("asset1_job", selection=[asset1])

            # The created schedule will fire daily
            asset1_job_schedule = build_schedule_from_partitioned_job(asset1_job)

            defs = Definitions(assets=[asset1], schedules=[asset1_job_schedule])

            ################
            # Non-asset job
            ################

            from dagster import DailyPartitionsDefinition, build_schedule_from_partitioned_job, jog


            @job(partitions_def=DailyPartitionsDefinition(start_date="2020-01-01"))
            def do_stuff_partitioned():
                ...

            # The created schedule will fire daily
            do_stuff_partitioned_schedule = build_schedule_from_partitioned_job(
                do_stuff_partitioned,
            )

            defs = Definitions(schedules=[do_stuff_partitioned_schedule])
            ```

    </dd>

</dl>
</div>


<div class="section" id="partition-mapping">


# Partition Mapping

<dl>
    <dt><Link id='dagster.PartitionMapping'>`class` dagster.PartitionMapping</Link></dt>
    <dd>

    Defines a correspondence between the partitions in an asset and the partitions in an asset
    that it depends on.

    Overriding PartitionMapping outside of Dagster is not supported. The abstract methods of this
    class may change at any time.

    <dl>
        <dt><Link id='dagster.PartitionMapping.get_downstream_partitions_for_partitions'>`abstractmethod` get_downstream_partitions_for_partitions</Link></dt>
        <dd>

        Returns the subset of partition keys in the downstream asset that use the data in the given
        partition key subset of the upstream asset.

        Parameters: 
          - <strong>upstream_partitions_subset</strong> (<em>Union</em><em>[</em>[*PartitionKeyRange*](#dagster.PartitionKeyRange)<em>, </em><em>PartitionsSubset</em><em>]</em>) – The subset of partition keys in the upstream asset.
          - <strong>downstream_partitions_def</strong> ([*PartitionsDefinition*](#dagster.PartitionsDefinition)) – The partitions definition for the downstream asset.



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.PartitionMapping.get_upstream_mapped_partitions_result_for_partitions'>`abstractmethod` get_upstream_mapped_partitions_result_for_partitions</Link></dt>
        <dd>

        Returns a UpstreamPartitionsResult object containing the partition keys the downstream
        partitions subset was mapped to in the upstream partitions definition.

        Valid upstream partitions will be included in UpstreamPartitionsResult.partitions_subset.
        Invalid upstream partitions will be included in UpstreamPartitionsResult.required_but_nonexistent_subset.

        For example, if an upstream asset is time-partitioned and starts in June 2023, and the
        downstream asset is time-partitioned and starts in May 2023, this function would return a
        UpstreamPartitionsResult(PartitionsSubset(“2023-06-01”), required_but_nonexistent_subset=PartitionsSubset(“2023-05-01”))
        when downstream_partitions_subset contains 2023-05-01 and 2023-06-01.


        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.TimeWindowPartitionMapping'>`class` dagster.TimeWindowPartitionMapping</Link></dt>
    <dd>

    The default mapping between two TimeWindowPartitionsDefinitions.

    A partition in the downstream partitions definition is mapped to all partitions in the upstream
    asset whose time windows overlap it.

    This means that, if the upstream and downstream partitions definitions share the same time
    period, then this mapping is essentially the identity partition mapping - plus conversion of
    datetime formats.

    If the upstream time period is coarser than the downstream time period, then each partition in
    the downstream asset will map to a single (larger) upstream partition. E.g. if the downstream is
    hourly and the upstream is daily, then each hourly partition in the downstream will map to the
    daily partition in the upstream that contains that hour.

    If the upstream time period is finer than the downstream time period, then each partition in the
    downstream asset will map to multiple upstream partitions. E.g. if the downstream is daily and
    the upstream is hourly, then each daily partition in the downstream asset will map to the 24
    hourly partitions in the upstream that occur on that day.

    Parameters: 
      - <strong>start_offset</strong> (<em>int</em>) – If not 0, then the starts of the upstream windows are shifted by this offset relative to the starts of the downstream windows. For example, if start_offset=-1 and end_offset=0, then the downstream partition “2022-07-04” would map to the upstream partitions “2022-07-03” and “2022-07-04”. If the upstream and downstream PartitionsDefinitions are different, then the offset is in the units of the downstream. Defaults to 0.
      - <strong>end_offset</strong> (<em>int</em>) – If not 0, then the ends of the upstream windows are shifted by this offset relative to the ends of the downstream windows. For example, if start_offset=0 and end_offset=1, then the downstream partition “2022-07-04” would map to the upstream partitions “2022-07-04” and “2022-07-05”. If the upstream and downstream PartitionsDefinitions are different, then the offset is in the units of the downstream. Defaults to 0.
      - <strong>allow_nonexistent_upstream_partitions</strong> (<em>bool</em>) – <span className="flag flag-warning">beta</span>  Defaults to false. If true, does not raise an error when mapped upstream partitions fall outside the start-end time window of the partitions def. For example, if the upstream partitions def starts on “2023-01-01” but the downstream starts on “2022-01-01”, setting this bool to true would return no partition keys when get_upstream_partitions_for_partitions is called with “2022-06-01”. When set to false, would raise an error.


    Examples:

        ```python
        from dagster import DailyPartitionsDefinition, TimeWindowPartitionMapping, AssetIn, asset

        partitions_def = DailyPartitionsDefinition(start_date="2020-01-01")

        @asset(partitions_def=partitions_def)
        def asset1():
            ...

        @asset(
            partitions_def=partitions_def,
            ins={
                "asset1": AssetIn(
                    partition_mapping=TimeWindowPartitionMapping(start_offset=-1)
                )
            }
        )
        def asset2(asset1):
            ...
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.IdentityPartitionMapping'>`class` dagster.IdentityPartitionMapping</Link></dt>
    <dd>
    Expects that the upstream and downstream assets are partitioned in the same way, and maps
    partitions in the downstream asset to the same partition in the upstream asset.
    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AllPartitionMapping'>`class` dagster.AllPartitionMapping</Link></dt>
    <dd>

    Maps every partition in the downstream asset to every partition in the upstream asset.

    Commonly used in the case when the downstream asset is not partitioned, in which the entire
    downstream asset depends on all partitions of the upstream asset.


    </dd>

</dl>
<dl>
    <dt><Link id='dagster.LastPartitionMapping'>`class` dagster.LastPartitionMapping</Link></dt>
    <dd>

    Maps all dependencies to the last partition in the upstream asset.

    Commonly used in the case when the downstream asset is not partitioned, in which the entire
    downstream asset depends on the last partition of the upstream asset.


    </dd>

</dl>
<dl>
    <dt><Link id='dagster.StaticPartitionMapping'>`class` dagster.StaticPartitionMapping</Link></dt>
    <dd>

    Define an explicit correspondence between two StaticPartitionsDefinitions.

    Parameters: <strong>downstream_partition_keys_by_upstream_partition_key</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>str</em><em> | </em><em>Collection</em><em>[</em><em>str</em><em>]</em><em>]</em>) – The single or multi-valued correspondence from upstream keys to downstream keys.

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.SpecificPartitionsPartitionMapping'>`class` dagster.SpecificPartitionsPartitionMapping</Link></dt>
    <dd>

    Maps to a specific subset of partitions in the upstream asset.

    Example:

        ```python
        from dagster import SpecificPartitionsPartitionMapping, StaticPartitionsDefinition, asset

        @asset(partitions_def=StaticPartitionsDefinition(["a", "b", "c"]))
        def upstream():
            ...

        @asset(
            ins={
                "upstream": AssetIn(partition_mapping=SpecificPartitionsPartitionMapping(["a"]))
            }
        )
        def a_downstream(upstream):
            ...
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.MultiToSingleDimensionPartitionMapping'>`class` dagster.MultiToSingleDimensionPartitionMapping</Link></dt>
    <dd>

        :::warning[beta]
        This API is currently in beta, and may have breaking changes in minor version releases, with behavior changes in patch releases.


        :::

    Defines a correspondence between an single-dimensional partitions definition
    and a MultiPartitionsDefinition. The single-dimensional partitions definition must be
    a dimension of the MultiPartitionsDefinition.

    This class handles the case where the upstream asset is multipartitioned and the
    downstream asset is single dimensional, and vice versa.

    For a partition key X, this partition mapping assumes that any multi-partition key with
    X in the selected dimension is a dependency.

    Parameters: <strong>partition_dimension_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the partition dimension in the
    MultiPartitionsDefinition that matches the single-dimension partitions definition.

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.MultiPartitionMapping'>`class` dagster.MultiPartitionMapping</Link></dt>
    <dd>

        :::warning[beta]
        This API is currently in beta, and may have breaking changes in minor version releases, with behavior changes in patch releases.


        :::

    Defines a correspondence between two MultiPartitionsDefinitions.

    Accepts a mapping of upstream dimension name to downstream DimensionPartitionMapping, representing
    the explicit correspondence between the upstream and downstream MultiPartitions dimensions
    and the partition mapping used to calculate the downstream partitions.

    Examples:

        ```python
        weekly_abc = MultiPartitionsDefinition(
            {
                "abc": StaticPartitionsDefinition(["a", "b", "c"]),
                "weekly": WeeklyPartitionsDefinition("2023-01-01"),
            }
        )
        daily_123 = MultiPartitionsDefinition(
            {
                "123": StaticPartitionsDefinition(["1", "2", "3"]),
                "daily": DailyPartitionsDefinition("2023-01-01"),
            }
        )

        MultiPartitionMapping(
            {
                "abc": DimensionPartitionMapping(
                    dimension_name="123",
                    partition_mapping=StaticPartitionMapping({"a": "1", "b": "2", "c": "3"}),
                ),
                "weekly": DimensionPartitionMapping(
                    dimension_name="daily",
                    partition_mapping=TimeWindowPartitionMapping(),
                )
            }
        )
        ```
    For upstream or downstream dimensions not explicitly defined in the mapping, Dagster will
    assume an <cite>AllPartitionsMapping</cite>, meaning that all upstream partitions in those dimensions
    will be mapped to all downstream partitions in those dimensions.

    Examples:

        ```python
        weekly_abc = MultiPartitionsDefinition(
            {
                "abc": StaticPartitionsDefinition(["a", "b", "c"]),
                "daily": DailyPartitionsDefinition("2023-01-01"),
            }
        )
        daily_123 = MultiPartitionsDefinition(
            {
                "123": StaticPartitionsDefinition(["1", "2", "3"]),
                "daily": DailyPartitionsDefinition("2023-01-01"),
            }
        )

        MultiPartitionMapping(
            {
                "daily": DimensionPartitionMapping(
                    dimension_name="daily",
                    partition_mapping=IdentityPartitionMapping(),
                )
            }
        )

        # Will map `daily_123` partition key {"123": "1", "daily": "2023-01-01"} to the upstream:
        # {"abc": "a", "daily": "2023-01-01"}
        # {"abc": "b", "daily": "2023-01-01"}
        # {"abc": "c", "daily": "2023-01-01"}
        ```
    Parameters: <strong>downstream_mappings_by_upstream_dimension</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>DimensionPartitionMapping</em><em>]</em>) – A
    mapping that defines an explicit correspondence between one dimension of the upstream
    MultiPartitionsDefinition and one dimension of the downstream MultiPartitionsDefinition.
    Maps a string representing upstream dimension name to downstream DimensionPartitionMapping,
    containing the downstream dimension name and partition mapping.

    </dd>

</dl>
</div>


<div class="section" id="backfill-policy">


# Backfill Policy

<dl>
    <dt><Link id='dagster.BackfillPolicy'>`class` dagster.BackfillPolicy</Link></dt>
    <dd>

        :::warning[beta]
        This API is currently in beta, and may have breaking changes in minor version releases, with behavior changes in patch releases.


        :::

    A BackfillPolicy specifies how Dagster should attempt to backfill a partitioned asset.

    There are two main kinds of backfill policies: single-run and multi-run.

    An asset with a single-run backfill policy will take a single run to backfill all of its
    partitions at once.

    An asset with a multi-run backfill policy will take multiple runs to backfill all of its
    partitions. Each run will backfill a subset of the partitions. The number of partitions to
    backfill in each run is controlled by the <cite>max_partitions_per_run</cite> parameter.

    For example:

      - If an asset has 100 partitions, and the <cite>max_partitions_per_run</cite> is set to 10, then it will be backfilled in 10 runs; each run will backfill 10 partitions.
      - If an asset has 100 partitions, and the <cite>max_partitions_per_run</cite> is set to 11, then it will be backfilled in 10 runs; the first 9 runs will backfill 11 partitions, and the last one run will backfill the remaining 9 partitions.


    <strong>Warning:</strong>

    Constructing an BackfillPolicy directly is not recommended as the API is subject to change.
    BackfillPolicy.single_run() and BackfillPolicy.multi_run(max_partitions_per_run=x) are the
    recommended APIs.

    <dl>
        <dt><Link id='dagster.BackfillPolicy.multi_run'>`static` multi_run</Link></dt>
        <dd>

        Creates a BackfillPolicy that executes the entire backfill in multiple runs.
        Each run will backfill [max_partitions_per_run] number of partitions.

        Parameters: <strong>max_partitions_per_run</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The maximum number of partitions in each run of
        the multiple runs. Defaults to 1.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.BackfillPolicy.single_run'>`static` single_run</Link></dt>
        <dd>
        Creates a BackfillPolicy that executes the entire backfill in a single run.
        </dd>

    </dl>

    </dd>

</dl>
</div>


<div class="section" id="partitioned-config">

# Partitioned Config

<dl>
    <dt><Link id='dagster.PartitionedConfig'>`class` dagster.PartitionedConfig</Link></dt>
    <dd>

    Defines a way of configuring a job where the job can be run on one of a discrete set of
    partitions, and each partition corresponds to run configuration for the job.

    Setting PartitionedConfig as the config for a job allows you to launch backfills for that job
    and view the run history across partitions.

    <dl>
        <dt><Link id='dagster.PartitionedConfig.get_partition_keys'>get_partition_keys</Link></dt>
        <dd>

        Returns a list of partition keys, representing the full set of partitions that
        config can be applied to.

        Parameters: <strong>current_time</strong> (<em>Optional</em><em>[</em><em>datetime</em><em>]</em>) – A datetime object representing the current time. Only
        applicable to time-based partitions definitions.Returns: Sequence[str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.PartitionedConfig.partitions_def'>`property` partitions_def</Link></dt>
        <dd>

        The partitions definition associated with this PartitionedConfig.

        Type: T_PartitionsDefinition

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.PartitionedConfig.run_config_for_partition_fn'>`property` run_config_for_partition_fn</Link></dt>
        <dd>

            :::danger[deprecated]
            This API will be removed in version 2.0.
             Use `run_config_for_partition_key_fn` instead..

            :::

        A function that accepts a partition
        and returns a dictionary representing the config to attach to runs for that partition.
        Deprecated as of 1.3.3.

        Type: Optional[Callable[[Partition], Mapping[str, Any]]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.PartitionedConfig.run_config_for_partition_key_fn'>`property` run_config_for_partition_key_fn</Link></dt>
        <dd>

        A function that accepts a partition key
        and returns a dictionary representing the config to attach to runs for that partition.

        Type: Optional[Callable[[str], Union[[RunConfig](config.mdx#dagster.RunConfig), Mapping[str, Any]]]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.PartitionedConfig.tags_for_partition_fn'>`property` tags_for_partition_fn</Link></dt>
        <dd>

            :::danger[deprecated]
            This API will be removed in version 2.0.
             Use `tags_for_partition_key_fn` instead..

            :::

        A function that
        accepts a partition and returns a dictionary of tags to attach to runs for
        that partition. Deprecated as of 1.3.3.

        Type: Optional[Callable[[Partition], Mapping[str, str]]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.PartitionedConfig.tags_for_partition_key_fn'>`property` tags_for_partition_key_fn</Link></dt>
        <dd>

        A function that
        accepts a partition key and returns a dictionary of tags to attach to runs for
        that partition.

        Type: Optional[Callable[[str], Mapping[str, str]]]

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.static_partitioned_config'>dagster.static_partitioned_config</Link></dt>
    <dd>

    Creates a static partitioned config for a job.

    The provided partition_keys is a static list of strings identifying the set of partitions. The
    list of partitions is static, so while the run config returned by the decorated function may
    change over time, the list of valid partition keys does not.

    This has performance advantages over <cite>dynamic_partitioned_config</cite> in terms of loading different
    partition views in the Dagster UI.

    The decorated function takes in a partition key and returns a valid run config for a particular
    target job.

    Parameters: 
      - <strong>partition_keys</strong> (<em>Sequence</em><em>[</em><em>str</em><em>]</em>) – A list of valid partition keys, which serve as the range of values that can be provided to the decorated run config function.
      - <strong>tags_for_partition_fn</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – <span className="flag flag-danger">deprecated</span>  A function that accepts a partition key and returns a dictionary of tags to attach to runs for that partition.
      - <strong>tags_for_partition_key_fn</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – A function that accepts a partition key and returns a dictionary of tags to attach to runs for that partition.


    Returns: PartitionedConfig

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.dynamic_partitioned_config'>dagster.dynamic_partitioned_config</Link></dt>
    <dd>

    Creates a dynamic partitioned config for a job.

    The provided partition_fn returns a list of strings identifying the set of partitions, given
    an optional datetime argument (representing the current time).  The list of partitions returned
    may change over time.

    The decorated function takes in a partition key and returns a valid run config for a particular
    target job.

    Parameters: 
      - <strong>partition_fn</strong> (<em>Callable</em><em>[</em><em>[</em><em>datetime.datetime</em><em>]</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A function that generates a list of valid partition keys, which serve as the range of values that can be provided to the decorated run config function.
      - <strong>tags_for_partition_fn</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – <span className="flag flag-danger">deprecated</span>  A function that accepts a partition key and returns a dictionary of tags to attach to runs for that partition.


    Returns: PartitionedConfig

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.hourly_partitioned_config'>dagster.hourly_partitioned_config</Link></dt>
    <dd>

    Defines run config over a set of hourly partitions.

    The decorated function should accept a start datetime and end datetime, which represent the date
    partition the config should delineate.

    The decorated function should return a run config dictionary.

    The resulting object created by this decorator can be provided to the config argument of a Job.
    The first partition in the set will start at the start_date at midnight. The last partition in
    the set will end before the current time, unless the end_offset argument is set to a positive
    number. If minute_offset is provided, the start and end times of each partition will be
    minute_offset past the hour.

    Parameters: 
      - <strong>start_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>]</em>) – The first date in the set of partitions. Can provide in either a datetime or string format.
      - <strong>minute_offset</strong> (<em>int</em>) – Number of minutes past the hour to “split” the partition. Defaults to 0.
      - <strong>fmt</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The date format to use. Defaults to <cite>%Y-%m-%d</cite>.
      - <strong>timezone</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The timezone in which each date should exist. Supported strings for timezones are the ones provided by the <cite>IANA time zone database \<https://www.iana.org/time-zones></cite> - e.g. “America/Los_Angeles”.
      - <strong>end_offset</strong> (<em>int</em>) – Extends the partition set by a number of partitions equal to the value passed. If end_offset is 0 (the default), the last partition ends before the current time. If end_offset is 1, the second-to-last partition ends before the current time, and so on.
      - <strong>tags_for_partition_fn</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – A function that accepts a partition time window and returns a dictionary of tags to attach to runs for that partition.


        ```python
        @hourly_partitioned_config(start_date=datetime(2022, 03, 12))
        # creates partitions (2022-03-12-00:00, 2022-03-12-01:00), (2022-03-12-01:00, 2022-03-12-02:00), ...

        @hourly_partitioned_config(start_date=datetime(2022, 03, 12), minute_offset=15)
        # creates partitions (2022-03-12-00:15, 2022-03-12-01:15), (2022-03-12-01:15, 2022-03-12-02:15), ...
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.daily_partitioned_config'>dagster.daily_partitioned_config</Link></dt>
    <dd>

    Defines run config over a set of daily partitions.

    The decorated function should accept a start datetime and end datetime, which represent the bounds
    of the date partition the config should delineate.

    The decorated function should return a run config dictionary.

    The resulting object created by this decorator can be provided to the config argument of a Job.
    The first partition in the set will start at the start_date at midnight. The last partition in
    the set will end before the current time, unless the end_offset argument is set to a positive
    number. If minute_offset and/or hour_offset are used, the start and end times of each partition
    will be hour_offset:minute_offset of each day.

    Parameters: 
      - <strong>start_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>]</em>) – The first date in the set of partitions. Can provide in either a datetime or string format.
      - <strong>minute_offset</strong> (<em>int</em>) – Number of minutes past the hour to “split” the partition. Defaults to 0.
      - <strong>hour_offset</strong> (<em>int</em>) – Number of hours past 00:00 to “split” the partition. Defaults to 0.
      - <strong>timezone</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The timezone in which each date should exist. Supported strings for timezones are the ones provided by the <cite>IANA time zone database \<https://www.iana.org/time-zones></cite> - e.g. “America/Los_Angeles”.
      - <strong>fmt</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The date format to use. Defaults to <cite>%Y-%m-%d</cite>.
      - <strong>end_offset</strong> (<em>int</em>) – Extends the partition set by a number of partitions equal to the value passed. If end_offset is 0 (the default), the last partition ends before the current time. If end_offset is 1, the second-to-last partition ends before the current time, and so on.
      - <strong>tags_for_partition_fn</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – A function that accepts a partition time window and returns a dictionary of tags to attach to runs for that partition.


        ```python
        @daily_partitioned_config(start_date="2022-03-12")
        # creates partitions (2022-03-12-00:00, 2022-03-13-00:00), (2022-03-13-00:00, 2022-03-14-00:00), ...

        @daily_partitioned_config(start_date="2022-03-12", minute_offset=15, hour_offset=16)
        # creates partitions (2022-03-12-16:15, 2022-03-13-16:15), (2022-03-13-16:15, 2022-03-14-16:15), ...
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.weekly_partitioned_config'>dagster.weekly_partitioned_config</Link></dt>
    <dd>

    Defines run config over a set of weekly partitions.

    The decorated function should accept a start datetime and end datetime, which represent the date
    partition the config should delineate.

    The decorated function should return a run config dictionary.

    The resulting object created by this decorator can be provided to the config argument of a Job.
    The first partition in the set will start at the start_date. The last partition in the set will
    end before the current time, unless the end_offset argument is set to a positive number. If
    day_offset is provided, the start and end date of each partition will be day of the week
    corresponding to day_offset (0 indexed with Sunday as the start of the week). If
    minute_offset and/or hour_offset are used, the start and end times of each partition will be
    hour_offset:minute_offset of each day.

    Parameters: 
      - <strong>start_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>]</em>) – The first date in the set of partitions will Sunday at midnight following start_date. Can provide in either a datetime or string format.
      - <strong>minute_offset</strong> (<em>int</em>) – Number of minutes past the hour to “split” the partition. Defaults to 0.
      - <strong>hour_offset</strong> (<em>int</em>) – Number of hours past 00:00 to “split” the partition. Defaults to 0.
      - <strong>day_offset</strong> (<em>int</em>) – Day of the week to “split” the partition. Defaults to 0 (Sunday).
      - <strong>timezone</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The timezone in which each date should exist. Supported strings for timezones are the ones provided by the <cite>IANA time zone database \<https://www.iana.org/time-zones></cite> - e.g. “America/Los_Angeles”.
      - <strong>fmt</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The date format to use. Defaults to <cite>%Y-%m-%d</cite>.
      - <strong>end_offset</strong> (<em>int</em>) – Extends the partition set by a number of partitions equal to the value passed. If end_offset is 0 (the default), the last partition ends before the current time. If end_offset is 1, the second-to-last partition ends before the current time, and so on.
      - <strong>tags_for_partition_fn</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – A function that accepts a partition time window and returns a dictionary of tags to attach to runs for that partition.


        ```python
        @weekly_partitioned_config(start_date="2022-03-12")
        # creates partitions (2022-03-13-00:00, 2022-03-20-00:00), (2022-03-20-00:00, 2022-03-27-00:00), ...

        @weekly_partitioned_config(start_date="2022-03-12", minute_offset=15, hour_offset=3, day_offset=6)
        # creates partitions (2022-03-12-03:15, 2022-03-19-03:15), (2022-03-19-03:15, 2022-03-26-03:15), ...
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.monthly_partitioned_config'>dagster.monthly_partitioned_config</Link></dt>
    <dd>

    Defines run config over a set of monthly partitions.

    The decorated function should accept a start datetime and end datetime, which represent the date
    partition the config should delineate.

    The decorated function should return a run config dictionary.

    The resulting object created by this decorator can be provided to the config argument of a Job.
    The first partition in the set will start at midnight on the soonest first of the month after
    start_date. The last partition in the set will end before the current time, unless the
    end_offset argument is set to a positive number. If day_offset is provided, the start and end
    date of each partition will be day_offset. If minute_offset and/or hour_offset are used, the
    start and end times of each partition will be hour_offset:minute_offset of each day.

    Parameters: 
      - <strong>start_date</strong> (<em>Union</em><em>[</em><em>datetime.datetime</em><em>, </em><em>str</em><em>]</em>) – The first date in the set of partitions will be midnight the soonest first of the month following start_date. Can provide in either a datetime or string format.
      - <strong>minute_offset</strong> (<em>int</em>) – Number of minutes past the hour to “split” the partition. Defaults to 0.
      - <strong>hour_offset</strong> (<em>int</em>) – Number of hours past 00:00 to “split” the partition. Defaults to 0.
      - <strong>day_offset</strong> (<em>int</em>) – Day of the month to “split” the partition. Defaults to 1.
      - <strong>timezone</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The timezone in which each date should exist. Supported strings for timezones are the ones provided by the <cite>IANA time zone database \<https://www.iana.org/time-zones></cite> - e.g. “America/Los_Angeles”.
      - <strong>fmt</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The date format to use. Defaults to <cite>%Y-%m-%d</cite>.
      - <strong>end_offset</strong> (<em>int</em>) – Extends the partition set by a number of partitions equal to the value passed. If end_offset is 0 (the default), the last partition ends before the current time. If end_offset is 1, the second-to-last partition ends before the current time, and so on.
      - <strong>tags_for_partition_fn</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – A function that accepts a partition time window and returns a dictionary of tags to attach to runs for that partition.


        ```python
        @monthly_partitioned_config(start_date="2022-03-12")
        # creates partitions (2022-04-01-00:00, 2022-05-01-00:00), (2022-05-01-00:00, 2022-06-01-00:00), ...

        @monthly_partitioned_config(start_date="2022-03-12", minute_offset=15, hour_offset=3, day_offset=5)
        # creates partitions (2022-04-05-03:15, 2022-05-05-03:15), (2022-05-05-03:15, 2022-06-05-03:15), ...
        ```

    </dd>

</dl>
</div>
