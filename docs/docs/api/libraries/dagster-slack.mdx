---
title: 'slack (dagster-slack)'
title_meta: 'slack (dagster-slack) API Documentation - Build Better Data Pipelines | Python Reference Documentation for Dagster'
description: 'slack (dagster-slack) Dagster API | Comprehensive Python API documentation for Dagster, the data orchestration platform. Learn how to build, test, and maintain data pipelines with our detailed guides and examples.'
last_update:
  date: '2025-12-05'
custom_edit_url: null
---

<div class="section" id="slack-dagster-slack">

# Slack (dagster-slack)

    <div className='lineblock'> </div>

This library provides an integration with Slack, to support posting messages in your company’s Slack workspace.

    <div className='lineblock'> </div>

Presently, it provides a thin wrapper on the Slack client API [chat.postMessage](https://api.slack.com/methods/chat.postMessage).

    <div className='lineblock'> </div>

To use this integration, you’ll first need to create a Slack App for it.

1. <strong>Create App</strong>: Go to [https://api.slack.com/apps](https://api.slack.com/apps) and click “Create New
   App”:

2. <strong>Install App</strong>: After creating an app, on the left-hand side of the app configuration, click “Bot
   Users”, and then create a bot user. Then, click “Install App” on the left hand side, and finally “Install App to
   Workspace”.
3. <strong>Bot Token</strong>: Once finished, this will create a new bot token for your bot/workspace:

Copy this bot token and put it somewhere safe; see [Safely Storing Credentials](https://api.slack.com/docs/oauth-safety) for more on this topic.

<dl>
    <dt><Link class="anchor" id='dagster_slack.SlackResource'>dagster_slack.SlackResource ResourceDefinition <a href='https://github.com/dagster-io/dagster/blob/master/python_modules/libraries/dagster-slack/dagster_slack/resources.py#L7' className='source-link' target='_blank' rel='noopener noreferrer'>[source]</a><a href="#dagster_slack.SlackResource" class="hash-link"></a></Link></dt>
    <dd>

    This resource is for connecting to Slack.

    By configuring this Slack resource, you can post messages to Slack from any Dagster op, asset, schedule or sensor.



    Examples:

        ```python
        import os

        from dagster import EnvVar, job, op
        from dagster_slack import SlackResource


        @op
        def slack_op(slack: SlackResource):
            slack.get_client().chat_postMessage(channel='#noise', text=':wave: hey there!')

        @job
        def slack_job():
            slack_op()

        Definitions(
            jobs=[slack_job],
            resources={
                "slack": SlackResource(token=EnvVar("MY_SLACK_TOKEN")),
            },
        )
        ```

    </dd>

</dl>
<dl>
    <dt><Link class="anchor" id='dagster_slack.make_slack_on_run_failure_sensor'>dagster_slack.make_slack_on_run_failure_sensor <a href='https://github.com/dagster-io/dagster/blob/master/python_modules/libraries/dagster-slack/dagster_slack/sensors.py#L76' className='source-link' target='_blank' rel='noopener noreferrer'>[source]</a><a href="#dagster_slack.make_slack_on_run_failure_sensor" class="hash-link"></a></Link></dt>
    <dd>

    Create a sensor on job failures that will message the given Slack channel.

    Parameters:
      - <strong>channel</strong> (<em>str</em>) – The channel to send the message to (e.g. “#my_channel”)
      - <strong>slack_token</strong> (<em>str</em>) – The slack token. Tokens are typically either user tokens or bot tokens. More in the Slack API documentation here: [https://api.slack.com/docs/token-types](https://api.slack.com/docs/token-types)
      - <strong>text_fn</strong> (<em>Optional</em><em>(</em><em>Callable</em><em>[</em><em>[</em>[*RunFailureSensorContext*](../dagster/schedules-sensors.mdx#dagster.RunFailureSensorContext)<em>]</em><em>, </em><em>str</em><em>]</em><em>)</em>) – Function which takes in the `RunFailureSensorContext` and outputs the message you want to send. Defaults to a text message that contains error message, job name, and run ID. The usage of the <cite>text_fn</cite> changes depending on whether you’re using <cite>blocks_fn</cite>. If you are using <cite>blocks_fn</cite>, this is used as a fallback string to display in notifications. If you aren’t, this is the main body text of the message. It can be formatted as plain text, or with markdown. See more details in [https://api.slack.com/methods/chat.postMessage#text_usage](https://api.slack.com/methods/chat.postMessage#text_usage)
      - <strong>blocks_fn</strong> (<em>Callable</em><em>[</em><em>[</em>[*RunFailureSensorContext*](../dagster/schedules-sensors.mdx#dagster.RunFailureSensorContext)<em>]</em><em>, </em><em>List</em><em>[</em><em>Dict</em><em>]</em><em>]</em>) – Function which takes in the `RunFailureSensorContext` and outputs the message blocks you want to send. See information about Blocks in [https://api.slack.com/reference/block-kit/blocks](https://api.slack.com/reference/block-kit/blocks)
      - <strong>name</strong> – (Optional[str]): The name of the sensor. Defaults to “slack_on_run_failure”.
      - <strong>dagit_base_url</strong> – <span className="flag flag-warning">deprecated</span>  (Optional[str]): The base url of your Dagit instance. Specify this to allow messages to include deeplinks to the failed job run.
      - <strong>minimum_interval_seconds</strong> – (Optional[int]): The minimum number of seconds that will elapse between sensor evaluations.
      - <strong>monitored_jobs</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Union</em><em>[</em>[*JobDefinition*](../dagster/jobs.mdx#dagster.JobDefinition)<em>, </em>[*GraphDefinition*](../dagster/graphs.mdx#dagster.GraphDefinition)<em>, </em>[*RepositorySelector*](../dagster/schedules-sensors.mdx#dagster.RepositorySelector)<em>, </em>[*JobSelector*](../dagster/schedules-sensors.mdx#dagster.JobSelector)<em>, </em><em>CodeLocationSensor</em><em>]</em><em>]</em><em>]</em>) – The jobs in the current repository that will be monitored by this failure sensor. Defaults to None, which means the alert will be sent when any job in the repository fails. To monitor jobs in external repositories, use RepositorySelector and JobSelector
      - <strong>job_selection</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Union</em><em>[</em>[*JobDefinition*](../dagster/jobs.mdx#dagster.JobDefinition)<em>, </em>[*GraphDefinition*](../dagster/graphs.mdx#dagster.GraphDefinition)<em>, </em>[*RepositorySelector*](../dagster/schedules-sensors.mdx#dagster.RepositorySelector)<em>, </em>[*JobSelector*](../dagster/schedules-sensors.mdx#dagster.JobSelector)<em>, </em><em>CodeLocationSensor</em><em>]</em><em>]</em><em>]</em>) – <span className="flag flag-warning">deprecated</span>  (deprecated in favor of monitored_jobs) The jobs in the current repository that will be monitored by this failure sensor. Defaults to None, which means the alert will be sent when any job in the repository fails.
      - <strong>monitor_all_code_locations</strong> (<em>bool</em>) – If set to True, the sensor will monitor all runs in the Dagster deployment. If set to True, an error will be raised if you also specify monitored_jobs or job_selection. Defaults to False.
      - <strong>default_status</strong> (<em>DefaultSensorStatus</em>) – Whether the sensor starts as running or not. The default status can be overridden from Dagit or via the GraphQL API.
      - <strong>webserver_base_url</strong> – (Optional[str]): The base url of your webserver instance. Specify this to allow messages to include deeplinks to the failed job run.
      - <strong>monitor_all_repositories</strong> (<em>bool</em>) – <span className="flag flag-warning">deprecated</span>  If set to True, the sensor will monitor all runs in the Dagster instance. If set to True, an error will be raised if you also specify monitored_jobs or job_selection. Defaults to False.




    Examples:

        ```python
        slack_on_run_failure = make_slack_on_run_failure_sensor(
            "#my_channel",
            os.getenv("MY_SLACK_TOKEN")
        )

        @repository
        def my_repo():
            return [my_job + slack_on_run_failure]
        ```
        ```python
        def my_message_fn(context: RunFailureSensorContext) -> str:
            return (
                f"Job {context.dagster_run.job_name} failed!"
                f"Error: {context.failure_event.message}"
            )

        slack_on_run_failure = make_slack_on_run_failure_sensor(
            channel="#my_channel",
            slack_token=os.getenv("MY_SLACK_TOKEN"),
            text_fn=my_message_fn,
            webserver_base_url="http://mycoolsite.com",
        )
        ```

    </dd>

</dl>
<dl>
    <dt><Link class="anchor" id='dagster_slack.slack_on_failure'>dagster_slack.slack_on_failure HookDefinition <a href='https://github.com/dagster-io/dagster/blob/master/python_modules/libraries/dagster-slack/dagster_slack/hooks.py#L22' className='source-link' target='_blank' rel='noopener noreferrer'>[source]</a><a href="#dagster_slack.slack_on_failure" class="hash-link"></a></Link></dt>
    <dd>

    Create a hook on step failure events that will message the given Slack channel.

    Parameters:
      - <strong>channel</strong> (<em>str</em>) – The channel to send the message to (e.g. “#my_channel”)
      - <strong>message_fn</strong> (<em>Optional</em><em>(</em><em>Callable</em><em>[</em><em>[</em>[*HookContext*](../dagster/hooks.mdx#dagster.HookContext)<em>]</em><em>, </em><em>str</em><em>]</em><em>)</em>) – Function which takes in the HookContext outputs the message you want to send.
      - <strong>dagit_base_url</strong> – <span className="flag flag-warning">deprecated</span>  (Optional[str]): The base url of your webserver instance. Specify this to allow messages to include deeplinks to the specific run that triggered the hook.
      - <strong>webserver_base_url</strong> – (Optional[str]): The base url of your webserver instance. Specify this to allow messages to include deeplinks to the specific run that triggered the hook.




    Examples:

        ```python
        @slack_on_failure("#foo", webserver_base_url="http://localhost:3000")
        @job(...)
        def my_job():
            pass
        ```
        ```python
        def my_message_fn(context: HookContext) -> str:
            return f"Op {context.op} failed!"

        @op
        def an_op(context):
            pass

        @job(...)
        def my_job():
            an_op.with_hooks(hook_defs={slack_on_failure("#foo", my_message_fn)})
        ```

    </dd>

</dl>
<dl>
    <dt><Link class="anchor" id='dagster_slack.slack_on_success'>dagster_slack.slack_on_success HookDefinition <a href='https://github.com/dagster-io/dagster/blob/master/python_modules/libraries/dagster-slack/dagster_slack/hooks.py#L81' className='source-link' target='_blank' rel='noopener noreferrer'>[source]</a><a href="#dagster_slack.slack_on_success" class="hash-link"></a></Link></dt>
    <dd>

    Create a hook on step success events that will message the given Slack channel.

    Parameters:
      - <strong>channel</strong> (<em>str</em>) – The channel to send the message to (e.g. “#my_channel”)
      - <strong>message_fn</strong> (<em>Optional</em><em>(</em><em>Callable</em><em>[</em><em>[</em>[*HookContext*](../dagster/hooks.mdx#dagster.HookContext)<em>]</em><em>, </em><em>str</em><em>]</em><em>)</em>) – Function which takes in the HookContext outputs the message you want to send.
      - <strong>dagit_base_url</strong> – <span className="flag flag-warning">deprecated</span>  (Optional[str]): The base url of your webserver instance. Specify this to allow messages to include deeplinks to the specific run that triggered the hook.
      - <strong>webserver_base_url</strong> – (Optional[str]): The base url of your webserver instance. Specify this to allow messages to include deeplinks to the specific run that triggered the hook.




    Examples:

        ```python
        @slack_on_success("#foo", webserver_base_url="http://localhost:3000")
        @job(...)
        def my_job():
            pass
        ```
        ```python
        def my_message_fn(context: HookContext) -> str:
            return f"Op {context.op} worked!"

        @op
        def an_op(context):
            pass

        @job(...)
        def my_job():
            an_op.with_hooks(hook_defs={slack_on_success("#foo", my_message_fn)})
        ```

    </dd>

</dl>
<div class="section" id="legacy">

## Legacy

<dl>
    <dt><Link class="anchor" id='dagster_slack.slack_resource'>dagster_slack.slack_resource ResourceDefinition <a href='https://github.com/dagster-io/dagster/blob/master/python_modules/libraries/dagster-slack/dagster_slack/resources.py#L56' className='source-link' target='_blank' rel='noopener noreferrer'>[source]</a><a href="#dagster_slack.slack_resource" class="hash-link"></a></Link></dt>
    <dd>

    This resource is for connecting to Slack.

    The resource object is a <cite>slack_sdk.WebClient</cite>.

    By configuring this Slack resource, you can post messages to Slack from any Dagster op, asset, schedule or sensor.



    Examples:

        ```python
        import os

        from dagster import job, op
        from dagster_slack import slack_resource


        @op(required_resource_keys={'slack'})
        def slack_op(context):
            context.resources.slack.chat_postMessage(channel='#noise', text=':wave: hey there!')

        @job(resource_defs={'slack': slack_resource})
        def slack_job():
            slack_op()

        slack_job.execute_in_process(
            run_config={'resources': {'slack': {'config': {'token': os.getenv('SLACK_TOKEN')}}}}
        )
        ```

    </dd>

</dl>
</div></div>
