---
title: Components
description: Defining our own components
sidebar_position: 90
---

So far we have built out everything via `Definitions`. But this is not the only way to include `Definitions` in a Dagster project.

If we think about the code for our three assets (`customers`, `orders`, and `payments`), it is all very similar. Each asset performs the same action, turning an S3 file into a DuckDB table while differing only in the URL path and table name.

These assets are a great candidate for a [component](/guides/build/components/creating-new-components). Components generate `Definitions` through a configuration layer. There are built-in components that let you integrate with common workflows (such as turning Python scripts into assets) or with popular tools like [dbt](https://www.getdbt.com/) or [Fivetran](https://www.fivetran.com/). There are also custom components that let you define your own specific use cases.

Here we will use a custom component to streamline the development of our assets and replace their `Definitions` in our project with a `Component` which can generate them instead.

![2048 resolution](/images/tutorial/dagster-tutorial/overviews/components.png)

## 1. Scaffold a custom component

First, scaffold a custom component using `dg`:

<CliInvocationExample path="docs_snippets/docs_snippets/guides/tutorials/dagster-tutorial/commands/dg-create-custom-component.txt" />

This adds a new directory, `components`, within `src/dagster_tutorial`:

<CliInvocationExample path="docs_snippets/docs_snippets/guides/tutorials/dagster-tutorial/tree/step-6a.txt" />

This directory contains the files needed to define the custom component.

## 2. Define the custom component

When designing a component, keep its interface in mind. In this case, the assets that our component will create share the following attributes:

- A DuckDB database shared across all assets.
- A list of ETL assets, each with a URL path and a table name.

The first step is to create a `dg.Model` for our ETL assets. These are similar to [Pydantic](https://docs.pydantic.dev/) models. This model will contain the two attributes that define an asset:

<CodeExample
  path="docs_snippets/docs_snippets/guides/tutorials/dagster-tutorial/src/dagster_tutorial/components/tutorial.py"
  language="python"
  startAfter="start_etl_model"
  endBefore="end_etl_model"
  title="src/etl_tutorial/components/tutorial.py"
/>

Next, add the interface to the `dg.Component` class. In this case, there will be a single attribute for the DuckDB database and a list of the `ETL` models we just defined:

```python
    duckdb_database: str
    etl_steps: list[ETL]
```

The rest of the code will look very similar to the asset definitions we wrote earlier. The `build_defs` method constructs a `Definitions` object containing all the Dagster objects created by the component. Based on the interface defined at the class level, we will generate multiple ETL assets. The final Dagster object to include is the `resource` that the assets rely on, which can also be set via an attribute.

<CodeExample
  path="docs_snippets/docs_snippets/guides/tutorials/dagster-tutorial/src/dagster_tutorial/components/tutorial.py"
  language="python"
  startAfter="start_tutorial_component"
  endBefore="end_tutorial_component"
  title="src/etl_tutorial/components/tutorial.py"
/>

Run `dg check` to ensure that the component code is correct.

## 3. Scaffold the component

If we list our components again, we will see that the custom component is now registered:

<CliInvocationExample path="docs_snippets/docs_snippets/guides/tutorials/dagster-tutorial/commands/dg-list-components-custom.txt" />

We can now scaffold it just like any other component:

<CliInvocationExample path="docs_snippets/docs_snippets/guides/tutorials/dagster-tutorial/commands/dg-scaffold-custom-component.txt" />

This adds a new directory, `tutorials`, within `defs`:

<CliInvocationExample path="docs_snippets/docs_snippets/guides/tutorials/dagster-tutorial/tree/step-6b.txt" />

## 4. Configure the component

Set the configuration in the YAML file created when the component was scaffolded:

<CodeExample
  path="docs_snippets/docs_snippets/guides/tutorials/dagster-tutorial/src/dagster_tutorial/components/defs.yaml"
  language="yaml"
  title="src/dagster_tutorial/defs/tutorial/defs.yaml"
/>

Before running `dg check` again, remove the `customers`, `orders`, and `payments` assets, as well as `resource.py`, since those objects are now generated by the component.

## 5. Materialize the assets

In the Dagster UI at [http://127.0.0.1:3000](http://127.0.0.1:3000), you will see that the asset graph looks the same as before.
