{
  "parents": [{ "link": "../", "title": "Module code" }],
  "title": "typing",
  "body": "<h1>Source code for typing</h1><div class=\"highlight\"><pre>\n<span></span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">The typing module: Support for gradual typing as defined by PEP 484.</span>\n\n<span class=\"sd\">At large scale, the structure of the module is following:</span>\n<span class=\"sd\">* Imports and exports, all public names should be explicitly added to __all__.</span>\n<span class=\"sd\">* Internal helper functions: these should never be used in code outside this module.</span>\n<span class=\"sd\">* _SpecialForm and its instances (special forms): Any, NoReturn, ClassVar, Union, Optional</span>\n<span class=\"sd\">* Two classes whose instances can be type arguments in addition to types: ForwardRef and TypeVar</span>\n<span class=\"sd\">* The core of internal generics API: _GenericAlias and _VariadicGenericAlias, the latter is</span>\n<span class=\"sd\">  currently only used by Tuple and Callable. All subscripted types like X[int], Union[int, str],</span>\n<span class=\"sd\">  etc., are instances of either of these classes.</span>\n<span class=\"sd\">* The public counterpart of the generics API consists of two classes: Generic and Protocol</span>\n<span class=\"sd\">  (the latter is currently private, but will be made public after PEP 544 acceptance).</span>\n<span class=\"sd\">* Public helper functions: get_type_hints, overload, cast, no_type_check,</span>\n<span class=\"sd\">  no_type_check_decorator.</span>\n<span class=\"sd\">* Generic aliases for collections.abc ABCs and few additional protocols.</span>\n<span class=\"sd\">* Special types: NewType, NamedTuple, TypedDict (may be added soon).</span>\n<span class=\"sd\">* Wrapper submodules for re and io related types.</span>\n<span class=\"sd\">&quot;&quot;&quot;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">abc</span>\n<span class=\"kn\">from</span> <span class=\"nn\">abc</span> <span class=\"kn\">import</span> <span class=\"n\">abstractmethod</span><span class=\"p\">,</span> <span class=\"n\">abstractproperty</span>\n<span class=\"kn\">import</span> <span class=\"nn\">collections</span>\n<span class=\"kn\">import</span> <span class=\"nn\">collections.abc</span>\n<span class=\"kn\">import</span> <span class=\"nn\">contextlib</span>\n<span class=\"kn\">import</span> <span class=\"nn\">functools</span>\n<span class=\"kn\">import</span> <span class=\"nn\">operator</span>\n<span class=\"kn\">import</span> <span class=\"nn\">re</span> <span class=\"k\">as</span> <span class=\"nn\">stdlib_re</span>  <span class=\"c1\"># Avoid confusion with the re we export.</span>\n<span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">types</span>\n<span class=\"kn\">from</span> <span class=\"nn\">types</span> <span class=\"kn\">import</span> <span class=\"n\">WrapperDescriptorType</span><span class=\"p\">,</span> <span class=\"n\">MethodWrapperType</span><span class=\"p\">,</span> <span class=\"n\">MethodDescriptorType</span>\n\n<span class=\"c1\"># Please keep __all__ alphabetized within each category.</span>\n<span class=\"n\">__all__</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"c1\"># Super-special typing primitives.</span>\n    <span class=\"s1\">&#39;Any&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Callable&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;ClassVar&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;ForwardRef&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Generic&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Optional&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Tuple&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Type&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;TypeVar&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Union&#39;</span><span class=\"p\">,</span>\n\n    <span class=\"c1\"># ABCs (from collections.abc).</span>\n    <span class=\"s1\">&#39;AbstractSet&#39;</span><span class=\"p\">,</span>  <span class=\"c1\"># collections.abc.Set.</span>\n    <span class=\"s1\">&#39;ByteString&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Container&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;ContextManager&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Hashable&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;ItemsView&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Iterable&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Iterator&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;KeysView&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Mapping&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;MappingView&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;MutableMapping&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;MutableSequence&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;MutableSet&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Sequence&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Sized&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;ValuesView&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Awaitable&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;AsyncIterator&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;AsyncIterable&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Coroutine&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Collection&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;AsyncGenerator&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;AsyncContextManager&#39;</span><span class=\"p\">,</span>\n\n    <span class=\"c1\"># Structural checks, a.k.a. protocols.</span>\n    <span class=\"s1\">&#39;Reversible&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;SupportsAbs&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;SupportsBytes&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;SupportsComplex&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;SupportsFloat&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;SupportsInt&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;SupportsRound&#39;</span><span class=\"p\">,</span>\n\n    <span class=\"c1\"># Concrete collection types.</span>\n    <span class=\"s1\">&#39;ChainMap&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Counter&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Deque&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Dict&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;DefaultDict&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;List&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;OrderedDict&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Set&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;FrozenSet&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;NamedTuple&#39;</span><span class=\"p\">,</span>  <span class=\"c1\"># Not really a type.</span>\n    <span class=\"s1\">&#39;Generator&#39;</span><span class=\"p\">,</span>\n\n    <span class=\"c1\"># One-off things.</span>\n    <span class=\"s1\">&#39;AnyStr&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;cast&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;get_type_hints&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;NewType&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;no_type_check&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;no_type_check_decorator&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;NoReturn&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;overload&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;Text&#39;</span><span class=\"p\">,</span>\n    <span class=\"s1\">&#39;TYPE_CHECKING&#39;</span><span class=\"p\">,</span>\n<span class=\"p\">]</span>\n\n<span class=\"c1\"># The pseudo-submodules &#39;re&#39; and &#39;io&#39; are part of the public</span>\n<span class=\"c1\"># namespace, but excluded from __all__ because they might stomp on</span>\n<span class=\"c1\"># legitimate imports of those modules.</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_type_check</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">is_argument</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Check that the argument is a type, and return it (internal helper).</span>\n\n<span class=\"sd\">    As a special case, accept None and return type(None) instead. Also wrap strings</span>\n<span class=\"sd\">    into ForwardRef instances. Consider several corner cases, for example plain</span>\n<span class=\"sd\">    special forms like Union are not valid, while Union[int, str] is OK, etc.</span>\n<span class=\"sd\">    The msg argument is a human-readable error message, e.g::</span>\n\n<span class=\"sd\">        &quot;Union[arg, ...]: arg should be a type.&quot;</span>\n\n<span class=\"sd\">    We append the repr() of the actual value (truncated to 100 chars).</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">invalid_generic_forms</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">,</span> <span class=\"n\">_Protocol</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">is_argument</span><span class=\"p\">:</span>\n        <span class=\"n\">invalid_generic_forms</span> <span class=\"o\">=</span> <span class=\"n\">invalid_generic_forms</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">ClassVar</span><span class=\"p\">,</span> <span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">arg</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">ForwardRef</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n            <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">in</span> <span class=\"n\">invalid_generic_forms</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{arg}</span><span class=\"s2\"> is not valid as type argument&quot;</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">arg</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">NoReturn</span><span class=\"p\">)</span> <span class=\"ow\">or</span>\n            <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">,</span> <span class=\"n\">_Protocol</span><span class=\"p\">)):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Plain </span><span class=\"si\">{arg}</span><span class=\"s2\"> is not valid as type argument&quot;</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">,</span> <span class=\"n\">TypeVar</span><span class=\"p\">,</span> <span class=\"n\">ForwardRef</span><span class=\"p\">)):</span>\n        <span class=\"k\">return</span> <span class=\"n\">arg</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">callable</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{msg}</span><span class=\"s2\"> Got </span><span class=\"si\">{arg!r:.100}</span><span class=\"s2\">.&quot;</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">arg</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_type_repr</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Return the repr() of an object, special-casing types (internal helper).</span>\n\n<span class=\"sd\">    If obj is a type, we return a shorter version than the default</span>\n<span class=\"sd\">    type.__repr__, based on the module and qualified name, which is</span>\n<span class=\"sd\">    typically enough to uniquely identify a type.  For everything</span>\n<span class=\"sd\">    else, we fall back on repr(obj).</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__module__</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;builtins&#39;</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n        <span class=\"k\">return</span> <span class=\"sa\">f</span><span class=\"s1\">&#39;</span><span class=\"si\">{obj.__module__}</span><span class=\"s1\">.</span><span class=\"si\">{obj.__qualname__}</span><span class=\"s1\">&#39;</span>\n    <span class=\"k\">if</span> <span class=\"n\">obj</span> <span class=\"ow\">is</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span><span class=\"p\">(</span><span class=\"s1\">&#39;...&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">FunctionType</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n    <span class=\"k\">return</span> <span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_collect_type_vars</span><span class=\"p\">(</span><span class=\"n\">types</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Collect all type variable contained in types in order of</span>\n<span class=\"sd\">    first appearance (lexicographic order). For example::</span>\n\n<span class=\"sd\">        _collect_type_vars((T, List[S, T])) == (T, S)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">tvars</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">TypeVar</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">t</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">tvars</span><span class=\"p\">:</span>\n            <span class=\"n\">tvars</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"n\">tvars</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">([</span><span class=\"n\">t</span> <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span> <span class=\"k\">if</span> <span class=\"n\">t</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">tvars</span><span class=\"p\">])</span>\n    <span class=\"k\">return</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">tvars</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_subs_tvars</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"p\">,</span> <span class=\"n\">tvars</span><span class=\"p\">,</span> <span class=\"n\">subs</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Substitute type variables &#39;tvars&#39; with substitutions &#39;subs&#39;.</span>\n<span class=\"sd\">    These two must have the same length.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">tp</span>\n    <span class=\"n\">new_args</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">TypeVar</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">tvar</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">tvars</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">arg</span> <span class=\"o\">==</span> <span class=\"n\">tvar</span><span class=\"p\">:</span>\n                    <span class=\"n\">new_args</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">subs</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">new_args</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">_subs_tvars</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">tvars</span><span class=\"p\">,</span> <span class=\"n\">subs</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">new_args</span><span class=\"p\">)]</span>\n    <span class=\"k\">return</span> <span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">(</span><span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">new_args</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_check_generic</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Check correct count for parameters of a generic cls (internal helper).</span>\n<span class=\"sd\">    This gives a nice error message in case of count mismatch.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{cls}</span><span class=\"s2\"> is not a generic class&quot;</span><span class=\"p\">)</span>\n    <span class=\"n\">alen</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n    <span class=\"n\">elen</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">alen</span> <span class=\"o\">!=</span> <span class=\"n\">elen</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Too {&#39;many&#39; if alen &gt; elen else &#39;few&#39;} parameters for </span><span class=\"si\">{cls}</span><span class=\"s2\">;&quot;</span>\n                        <span class=\"sa\">f</span><span class=\"s2\">&quot; actual </span><span class=\"si\">{alen}</span><span class=\"s2\">, expected </span><span class=\"si\">{elen}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_remove_dups_flatten</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;An internal helper for Union creation and substitution: flatten Unions</span>\n<span class=\"sd\">    among parameters, then remove duplicates.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"c1\"># Flatten out Union[Union[...], ...].</span>\n    <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span><span class=\"p\">:</span>\n            <span class=\"n\">params</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"ow\">and</span> <span class=\"n\">p</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span><span class=\"p\">:</span>\n            <span class=\"n\">params</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:])</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">params</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Weed out strict duplicates, preserving the first of each occurrence.</span>\n    <span class=\"n\">all_params</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">all_params</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"n\">new_params</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">all_params</span><span class=\"p\">:</span>\n                <span class=\"n\">new_params</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n                <span class=\"n\">all_params</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n        <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"n\">new_params</span>\n        <span class=\"k\">assert</span> <span class=\"ow\">not</span> <span class=\"n\">all_params</span><span class=\"p\">,</span> <span class=\"n\">all_params</span>\n    <span class=\"k\">return</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">_cleanups</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_tp_cache</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Internal wrapper caching __getitem__ of generic types with a fallback to</span>\n<span class=\"sd\">    original function for non-hashable arguments.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">cached</span> <span class=\"o\">=</span> <span class=\"n\">functools</span><span class=\"o\">.</span><span class=\"n\">lru_cache</span><span class=\"p\">()(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"n\">_cleanups</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">cached</span><span class=\"o\">.</span><span class=\"n\">cache_clear</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@functools</span><span class=\"o\">.</span><span class=\"n\">wraps</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">inner</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">cached</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">)</span>\n        <span class=\"k\">except</span> <span class=\"ne\">TypeError</span><span class=\"p\">:</span>\n            <span class=\"k\">pass</span>  <span class=\"c1\"># All real errors (not unhashable args) are raised below.</span>\n        <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">inner</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_eval_type</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Evaluate all forward reverences in the given type t.</span>\n<span class=\"sd\">    For use of globalns and localns see the docstring for get_type_hints().</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">ForwardRef</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">_evaluate</span><span class=\"p\">(</span><span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">):</span>\n        <span class=\"n\">ev_args</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_eval_type</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">ev_args</span> <span class=\"o\">==</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">t</span>\n        <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">(</span><span class=\"n\">ev_args</span><span class=\"p\">)</span>\n        <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">_special</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">_special</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span>\n    <span class=\"k\">return</span> <span class=\"n\">t</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_Final</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;Mixin to prohibit subclassing&quot;&quot;&quot;</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;__weakref__&#39;</span><span class=\"p\">,)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__init_subclass__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"s1\">&#39;_root&#39;</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">kwds</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Cannot subclass special typing classes&quot;</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">_Immutable</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;Mixin to indicate that object should not be copied.&quot;&quot;&quot;</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__copy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__deepcopy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_SpecialForm</span><span class=\"p\">(</span><span class=\"n\">_Final</span><span class=\"p\">,</span> <span class=\"n\">_Immutable</span><span class=\"p\">,</span> <span class=\"n\">_root</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Internal indicator of special typing constructs.</span>\n<span class=\"sd\">    See _doc instance attribute for specific docs.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;_name&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_doc&#39;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Constructor.</span>\n\n<span class=\"sd\">        This only exists to give a better error message in case</span>\n<span class=\"sd\">        someone tries to subclass a special typing object (not a good idea).</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">3</span> <span class=\"ow\">and</span>\n                <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n                <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">)):</span>\n            <span class=\"c1\"># Close enough.</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Cannot subclass </span><span class=\"si\">{cls!r}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_doc</span> <span class=\"o\">=</span> <span class=\"n\">doc</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__eq__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">_name</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__hash__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">((</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">,))</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"s1\">&#39;typing.&#39;</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__reduce__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Cannot instantiate </span><span class=\"si\">{self!r}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__instancecheck__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{self}</span><span class=\"s2\"> cannot be used with isinstance()&quot;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__subclasscheck__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{self}</span><span class=\"s2\"> cannot be used with issubclass()&quot;</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@_tp_cache</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;ClassVar&#39;</span><span class=\"p\">:</span>\n            <span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ClassVar accepts only single type.&#39;</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">,))</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;Union&#39;</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">parameters</span> <span class=\"o\">==</span> <span class=\"p\">():</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Cannot take a Union of no types.&quot;</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n                <span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">,)</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;Union[arg, ...]: each arg must be a type.&quot;</span>\n            <span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n            <span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"n\">_remove_dups_flatten</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">parameters</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n            <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;Optional&#39;</span><span class=\"p\">:</span>\n            <span class=\"n\">arg</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Optional[t] requires a single type.&quot;</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">)]</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{self}</span><span class=\"s2\"> is not subscriptable&quot;</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">&#39;Any&#39;</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">&quot;&quot;&quot;Special type indicating an unconstrained type.</span>\n\n<span class=\"sd\">    - Any is compatible with every type.</span>\n<span class=\"sd\">    - Any assumed to have all methods.</span>\n<span class=\"sd\">    - All values assumed to be instances of Any.</span>\n\n<span class=\"sd\">    Note that all the above statements are true from the point of view of</span>\n<span class=\"sd\">    static type checkers. At runtime, Any should not be used with instance</span>\n<span class=\"sd\">    or class checks.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span><span class=\"p\">)</span>\n\n<span class=\"n\">NoReturn</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">&#39;NoReturn&#39;</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">&quot;&quot;&quot;Special type indicating functions that never return.</span>\n<span class=\"sd\">    Example::</span>\n\n<span class=\"sd\">      from typing import NoReturn</span>\n\n<span class=\"sd\">      def stop() -&gt; NoReturn:</span>\n<span class=\"sd\">          raise Exception(&#39;no way&#39;)</span>\n\n<span class=\"sd\">    This type is invalid in other positions, e.g., ``List[NoReturn]``</span>\n<span class=\"sd\">    will fail in static type checkers.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span><span class=\"p\">)</span>\n\n<span class=\"n\">ClassVar</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">&#39;ClassVar&#39;</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">&quot;&quot;&quot;Special type construct to mark class variables.</span>\n\n<span class=\"sd\">    An annotation wrapped in ClassVar indicates that a given</span>\n<span class=\"sd\">    attribute is intended to be used as a class variable and</span>\n<span class=\"sd\">    should not be set on instances of that class. Usage::</span>\n\n<span class=\"sd\">      class Starship:</span>\n<span class=\"sd\">          stats: ClassVar[Dict[str, int]] = {} # class variable</span>\n<span class=\"sd\">          damage: int = 10                     # instance variable</span>\n\n<span class=\"sd\">    ClassVar accepts only types and cannot be further subscribed.</span>\n\n<span class=\"sd\">    Note that ClassVar is not a class itself, and should not</span>\n<span class=\"sd\">    be used with isinstance() or issubclass().</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span><span class=\"p\">)</span>\n\n<span class=\"n\">Union</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">&#39;Union&#39;</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">&quot;&quot;&quot;Union type; Union[X, Y] means either X or Y.</span>\n\n<span class=\"sd\">    To define a union, use e.g. Union[int, str].  Details:</span>\n<span class=\"sd\">    - The arguments must be types and there must be at least one.</span>\n<span class=\"sd\">    - None as an argument is a special case and is replaced by</span>\n<span class=\"sd\">      type(None).</span>\n<span class=\"sd\">    - Unions of unions are flattened, e.g.::</span>\n\n<span class=\"sd\">        Union[Union[int, str], float] == Union[int, str, float]</span>\n\n<span class=\"sd\">    - Unions of a single argument vanish, e.g.::</span>\n\n<span class=\"sd\">        Union[int] == int  # The constructor actually returns int</span>\n\n<span class=\"sd\">    - Redundant arguments are skipped, e.g.::</span>\n\n<span class=\"sd\">        Union[int, str, int] == Union[int, str]</span>\n\n<span class=\"sd\">    - When comparing unions, the argument order is ignored, e.g.::</span>\n\n<span class=\"sd\">        Union[int, str] == Union[str, int]</span>\n\n<span class=\"sd\">    - You cannot subclass or instantiate a union.</span>\n<span class=\"sd\">    - You can use Optional[X] as a shorthand for Union[X, None].</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span><span class=\"p\">)</span>\n\n<span class=\"n\">Optional</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">&#39;Optional&#39;</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">&quot;&quot;&quot;Optional type.</span>\n\n<span class=\"sd\">    Optional[X] is equivalent to Union[X, None].</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">ForwardRef</span><span class=\"p\">(</span><span class=\"n\">_Final</span><span class=\"p\">,</span> <span class=\"n\">_root</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Internal wrapper to hold a forward reference.&quot;&quot;&quot;</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;__forward_arg__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__forward_code__&#39;</span><span class=\"p\">,</span>\n                 <span class=\"s1\">&#39;__forward_evaluated__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__forward_value__&#39;</span><span class=\"p\">,</span>\n                 <span class=\"s1\">&#39;__forward_is_argument__&#39;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">is_argument</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">):</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Forward reference must be a string -- got </span><span class=\"si\">{arg!r}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">code</span> <span class=\"o\">=</span> <span class=\"nb\">compile</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;&lt;string&gt;&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;eval&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">except</span> <span class=\"ne\">SyntaxError</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">SyntaxError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Forward reference must be an expression -- got </span><span class=\"si\">{arg!r}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span> <span class=\"o\">=</span> <span class=\"n\">arg</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_code__</span> <span class=\"o\">=</span> <span class=\"n\">code</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_evaluated__</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_is_argument__</span> <span class=\"o\">=</span> <span class=\"n\">is_argument</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_evaluate</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_evaluated__</span> <span class=\"ow\">or</span> <span class=\"n\">localns</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"n\">globalns</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">globalns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"ow\">and</span> <span class=\"n\">localns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">globalns</span> <span class=\"o\">=</span> <span class=\"n\">localns</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n            <span class=\"k\">elif</span> <span class=\"n\">globalns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">globalns</span> <span class=\"o\">=</span> <span class=\"n\">localns</span>\n            <span class=\"k\">elif</span> <span class=\"n\">localns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">localns</span> <span class=\"o\">=</span> <span class=\"n\">globalns</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span>\n                <span class=\"nb\">eval</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_code__</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">),</span>\n                <span class=\"s2\">&quot;Forward references must evaluate to types.&quot;</span><span class=\"p\">,</span>\n                <span class=\"n\">is_argument</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_is_argument__</span><span class=\"p\">)</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_evaluated__</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__eq__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">ForwardRef</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span> <span class=\"ow\">and</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__hash__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">((</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"sa\">f</span><span class=\"s1\">&#39;ForwardRef(</span><span class=\"si\">{self.__forward_arg__!r}</span><span class=\"s1\">)&#39;</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">TypeVar</span><span class=\"p\">(</span><span class=\"n\">_Final</span><span class=\"p\">,</span> <span class=\"n\">_Immutable</span><span class=\"p\">,</span> <span class=\"n\">_root</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Type variable.</span>\n\n<span class=\"sd\">    Usage::</span>\n\n<span class=\"sd\">      T = TypeVar(&#39;T&#39;)  # Can be anything</span>\n<span class=\"sd\">      A = TypeVar(&#39;A&#39;, str, bytes)  # Must be str or bytes</span>\n\n<span class=\"sd\">    Type variables exist primarily for the benefit of static type</span>\n<span class=\"sd\">    checkers.  They serve as the parameters for generic types as well</span>\n<span class=\"sd\">    as for generic function definitions.  See class Generic for more</span>\n<span class=\"sd\">    information on generic types.  Generic functions work as follows:</span>\n\n<span class=\"sd\">      def repeat(x: T, n: int) -&gt; List[T]:</span>\n<span class=\"sd\">          &#39;&#39;&#39;Return a list containing n references to x.&#39;&#39;&#39;</span>\n<span class=\"sd\">          return [x]*n</span>\n\n<span class=\"sd\">      def longest(x: A, y: A) -&gt; A:</span>\n<span class=\"sd\">          &#39;&#39;&#39;Return the longest of two strings.&#39;&#39;&#39;</span>\n<span class=\"sd\">          return x if len(x) &gt;= len(y) else y</span>\n\n<span class=\"sd\">    The latter example&#39;s signature is essentially the overloading</span>\n<span class=\"sd\">    of (str, str) -&gt; str and (bytes, bytes) -&gt; bytes.  Also note</span>\n<span class=\"sd\">    that if the arguments are instances of some subclass of str,</span>\n<span class=\"sd\">    the return type is still plain str.</span>\n\n<span class=\"sd\">    At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.</span>\n\n<span class=\"sd\">    Type variables defined with covariant=True or contravariant=True</span>\n<span class=\"sd\">    can be used to declare covariant or contravariant generic types.</span>\n<span class=\"sd\">    See PEP 484 for more details. By default generic types are invariant</span>\n<span class=\"sd\">    in all type variables.</span>\n\n<span class=\"sd\">    Type variables can be introspected. e.g.:</span>\n\n<span class=\"sd\">      T.__name__ == &#39;T&#39;</span>\n<span class=\"sd\">      T.__constraints__ == ()</span>\n<span class=\"sd\">      T.__covariant__ == False</span>\n<span class=\"sd\">      T.__contravariant__ = False</span>\n<span class=\"sd\">      A.__constraints__ == (str, bytes)</span>\n\n<span class=\"sd\">    Note that only type variables defined in global scope can be pickled.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;__name__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__bound__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__constraints__&#39;</span><span class=\"p\">,</span>\n                 <span class=\"s1\">&#39;__covariant__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__contravariant__&#39;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">constraints</span><span class=\"p\">,</span> <span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n                 <span class=\"n\">covariant</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">contravariant</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n        <span class=\"k\">if</span> <span class=\"n\">covariant</span> <span class=\"ow\">and</span> <span class=\"n\">contravariant</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Bivariant types are not supported.&quot;</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__covariant__</span> <span class=\"o\">=</span> <span class=\"nb\">bool</span><span class=\"p\">(</span><span class=\"n\">covariant</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__contravariant__</span> <span class=\"o\">=</span> <span class=\"nb\">bool</span><span class=\"p\">(</span><span class=\"n\">contravariant</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">constraints</span> <span class=\"ow\">and</span> <span class=\"n\">bound</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Constraints cannot be combined with bound=...&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">constraints</span> <span class=\"ow\">and</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">constraints</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;A single constraint is not allowed&quot;</span><span class=\"p\">)</span>\n        <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;TypeVar(name, constraint, ...): constraints must be types.&quot;</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__constraints__</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">constraints</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">bound</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__bound__</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">bound</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Bound must be a type.&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__bound__</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n        <span class=\"n\">def_mod</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">_getframe</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">f_globals</span><span class=\"p\">[</span><span class=\"s1\">&#39;__name__&#39;</span><span class=\"p\">]</span>  <span class=\"c1\"># for pickling</span>\n        <span class=\"k\">if</span> <span class=\"n\">def_mod</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;typing&#39;</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__module__</span> <span class=\"o\">=</span> <span class=\"n\">def_mod</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__covariant__</span><span class=\"p\">:</span>\n            <span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;+&#39;</span>\n        <span class=\"k\">elif</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__contravariant__</span><span class=\"p\">:</span>\n            <span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;-&#39;</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;~&#39;</span>\n        <span class=\"k\">return</span> <span class=\"n\">prefix</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__reduce__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n\n\n<span class=\"c1\"># Special typing constructs Union, Optional, Generic, Callable and Tuple</span>\n<span class=\"c1\"># use three special attributes for internal bookkeeping of generic types:</span>\n<span class=\"c1\"># * __parameters__ is a tuple of unique free type parameters of a generic</span>\n<span class=\"c1\">#   type, for example, Dict[T, T].__parameters__ == (T,);</span>\n<span class=\"c1\"># * __origin__ keeps a reference to a type that was subscripted,</span>\n<span class=\"c1\">#   e.g., Union[T, int].__origin__ == Union, or the non-generic version of</span>\n<span class=\"c1\">#   the type.</span>\n<span class=\"c1\"># * __args__ is a tuple of all arguments used in subscripting,</span>\n<span class=\"c1\">#   e.g., Dict[T, int].__args__ == (T, int).</span>\n\n\n<span class=\"c1\"># Mapping from non-generic type names that have a generic alias in typing</span>\n<span class=\"c1\"># but with a different name.</span>\n<span class=\"n\">_normalize_alias</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;list&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;List&#39;</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;tuple&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;Tuple&#39;</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;dict&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;Dict&#39;</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;set&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;Set&#39;</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;frozenset&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;FrozenSet&#39;</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;deque&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;Deque&#39;</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;defaultdict&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;DefaultDict&#39;</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;type&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;Type&#39;</span><span class=\"p\">,</span>\n                    <span class=\"s1\">&#39;Set&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;AbstractSet&#39;</span><span class=\"p\">}</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">_is_dunder</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">startswith</span><span class=\"p\">(</span><span class=\"s1\">&#39;__&#39;</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">endswith</span><span class=\"p\">(</span><span class=\"s1\">&#39;__&#39;</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_GenericAlias</span><span class=\"p\">(</span><span class=\"n\">_Final</span><span class=\"p\">,</span> <span class=\"n\">_root</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;The central part of internal API.</span>\n\n<span class=\"sd\">    This represents a generic version of type &#39;origin&#39; with type arguments &#39;params&#39;.</span>\n<span class=\"sd\">    There are two kind of these aliases: user defined and special. The special ones</span>\n<span class=\"sd\">    are wrappers around builtin collections and ABCs in collections.abc. These must</span>\n<span class=\"sd\">    have &#39;name&#39; always set. If &#39;inst&#39; is False, then the alias can&#39;t be instantiated,</span>\n<span class=\"sd\">    this is used by e.g. typing.List and typing.Dict.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">origin</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">special</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_inst</span> <span class=\"o\">=</span> <span class=\"n\">inst</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span> <span class=\"o\">=</span> <span class=\"n\">special</span>\n        <span class=\"k\">if</span> <span class=\"n\">special</span> <span class=\"ow\">and</span> <span class=\"n\">name</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">orig_name</span> <span class=\"o\">=</span> <span class=\"n\">origin</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n            <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">_normalize_alias</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">orig_name</span><span class=\"p\">,</span> <span class=\"n\">orig_name</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"o\">=</span> <span class=\"n\">origin</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"o\">...</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"ow\">is</span> <span class=\"n\">_TypingEllipsis</span> <span class=\"k\">else</span>\n                              <span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"ow\">is</span> <span class=\"n\">_TypingEmpty</span> <span class=\"k\">else</span>\n                              <span class=\"n\">a</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span> <span class=\"o\">=</span> <span class=\"n\">_collect_type_vars</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>  <span class=\"c1\"># This is not documented.</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">name</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__module__</span> <span class=\"o\">=</span> <span class=\"n\">origin</span><span class=\"o\">.</span><span class=\"vm\">__module__</span>\n\n    <span class=\"nd\">@_tp_cache</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">,</span> <span class=\"n\">_Protocol</span><span class=\"p\">):</span>\n            <span class=\"c1\"># Can&#39;t subscript Generic[...] or _Protocol[...].</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Cannot subscript already-subscripted </span><span class=\"si\">{self}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,)</span>\n        <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;Parameters to generic types must be types.&quot;</span>\n        <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"n\">_check_generic</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">_subs_tvars</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">copy_with</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"c1\"># We don&#39;t copy self._special.</span>\n        <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_inst</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;Callable&#39;</span> <span class=\"ow\">or</span>\n                <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"bp\">Ellipsis</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">:</span>\n                <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;typing.&#39;</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">_type_repr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n                <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"sa\">f</span><span class=\"s1\">&#39;[{&quot;, &quot;.join([_type_repr(a) for a in self.__args__])}]&#39;</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>\n            <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">&#39;</span><span class=\"si\">{name}{args}</span><span class=\"s1\">&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"s1\">&#39;typing.Callable&#39;</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">&#39;typing.Callable&#39;</span>\n                <span class=\"sa\">f</span><span class=\"s1\">&#39;[[{&quot;, &quot;.join([_type_repr(a) for a in self.__args__[:-1]])}], &#39;</span>\n                <span class=\"sa\">f</span><span class=\"s1\">&#39;{_type_repr(self.__args__[-1])}]&#39;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__eq__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"o\">!=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"kc\">False</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span> <span class=\"ow\">and</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"nb\">frozenset</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nb\">frozenset</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__args__</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__hash__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">((</span><span class=\"n\">Union</span><span class=\"p\">,</span> <span class=\"nb\">frozenset</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)))</span>\n        <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">((</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_inst</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Type </span><span class=\"si\">{self._name}</span><span class=\"s2\"> cannot be instantiated; &quot;</span>\n                            <span class=\"sa\">f</span><span class=\"s2\">&quot;use {self._name.lower()}() instead&quot;</span><span class=\"p\">)</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">__orig_class__</span> <span class=\"o\">=</span> <span class=\"bp\">self</span>\n        <span class=\"k\">except</span> <span class=\"ne\">AttributeError</span><span class=\"p\">:</span>\n            <span class=\"k\">pass</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__mro_entries__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">bases</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">:</span>  <span class=\"c1\"># generic version of an ABC or built-in class</span>\n            <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">bases</span><span class=\"p\">:</span>\n                <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">)</span>\n            <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">bases</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"nb\">issubclass</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">Generic</span><span class=\"p\">)</span>\n                       <span class=\"k\">for</span> <span class=\"n\">b</span> <span class=\"ow\">in</span> <span class=\"n\">bases</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">:]):</span>\n                <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Generic</span><span class=\"p\">:</span>\n            <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">bases</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n            <span class=\"k\">for</span> <span class=\"n\">b</span> <span class=\"ow\">in</span> <span class=\"n\">bases</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">:]:</span>\n                <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">b</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"p\">:</span>\n                    <span class=\"k\">return</span> <span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__getattr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">):</span>\n        <span class=\"c1\"># We are careful for copy and pickle.</span>\n        <span class=\"c1\"># Also for simplicity we just don&#39;t relay all dunder names</span>\n        <span class=\"k\">if</span> <span class=\"s1\">&#39;__origin__&#39;</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"n\">_is_dunder</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">)</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">AttributeError</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__setattr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">_is_dunder</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"s1\">&#39;_name&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_inst&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_special&#39;</span><span class=\"p\">):</span>\n            <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__setattr__</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"nb\">setattr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__instancecheck__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"fm\">__subclasscheck__</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__subclasscheck__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">):</span>\n                <span class=\"k\">return</span> <span class=\"nb\">issubclass</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"nb\">issubclass</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">)</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Subscripted generics cannot be used with&quot;</span>\n                        <span class=\"s2\">&quot; class and instance checks&quot;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__reduce__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span>\n\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">:</span>\n            <span class=\"n\">origin</span> <span class=\"o\">=</span> <span class=\"nb\">globals</span><span class=\"p\">()[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">]</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">origin</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">origin</span> <span class=\"ow\">is</span> <span class=\"n\">Callable</span> <span class=\"ow\">and</span>\n            <span class=\"ow\">not</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"bp\">Ellipsis</span><span class=\"p\">)):</span>\n            <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]),</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n                <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">=</span> <span class=\"n\">args</span>\n        <span class=\"k\">return</span> <span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">getitem</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">origin</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_VariadicGenericAlias</span><span class=\"p\">(</span><span class=\"n\">_GenericAlias</span><span class=\"p\">,</span> <span class=\"n\">_root</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Same as _GenericAlias above but for variadic aliases. Currently,</span>\n<span class=\"sd\">    this is used only by special internal aliases: Tuple and Callable.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;Callable&#39;</span> <span class=\"ow\">or</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__getitem_inner__</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Callable must be used as &quot;</span>\n                            <span class=\"s2\">&quot;Callable[[arg, ...], result].&quot;</span><span class=\"p\">)</span>\n        <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">params</span>\n        <span class=\"k\">if</span> <span class=\"n\">args</span> <span class=\"ow\">is</span> <span class=\"bp\">Ellipsis</span><span class=\"p\">:</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"bp\">Ellipsis</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">):</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Callable[args, result]: args must be a list.&quot;</span>\n                                <span class=\"sa\">f</span><span class=\"s2\">&quot; Got </span><span class=\"si\">{args}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">),</span> <span class=\"n\">result</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__getitem_inner__</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@_tp_cache</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__getitem_inner__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"nb\">tuple</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">params</span> <span class=\"o\">==</span> <span class=\"p\">():</span>\n                <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">((</span><span class=\"n\">_TypingEmpty</span><span class=\"p\">,))</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n                <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span> <span class=\"ow\">and</span> <span class=\"n\">params</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n                <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;Tuple[t, ...]: t must be a type.&quot;</span>\n                <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">msg</span><span class=\"p\">)</span>\n                <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">_TypingEllipsis</span><span class=\"p\">))</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;Tuple[t0, t1, ...]: each t must be a type.&quot;</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Callable</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">params</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;Callable[args, result]: result must be a type.&quot;</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">args</span> <span class=\"ow\">is</span> <span class=\"bp\">Ellipsis</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">((</span><span class=\"n\">_TypingEllipsis</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"p\">))</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;Callable[[arg, ...], result]: each arg must be a type.&quot;</span>\n            <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"n\">args</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">,)</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Generic</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;Abstract base class for generic types.</span>\n\n<span class=\"sd\">    A generic type is typically declared by inheriting from</span>\n<span class=\"sd\">    this class parameterized with one or more type variables.</span>\n<span class=\"sd\">    For example, a generic mapping type might be defined as::</span>\n\n<span class=\"sd\">      class Mapping(Generic[KT, VT]):</span>\n<span class=\"sd\">          def __getitem__(self, key: KT) -&gt; VT:</span>\n<span class=\"sd\">              ...</span>\n<span class=\"sd\">          # Etc.</span>\n\n<span class=\"sd\">    This class can then be used as follows::</span>\n\n<span class=\"sd\">      def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:</span>\n<span class=\"sd\">          try:</span>\n<span class=\"sd\">              return mapping[key]</span>\n<span class=\"sd\">          except KeyError:</span>\n<span class=\"sd\">              return default</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">cls</span> <span class=\"ow\">is</span> <span class=\"n\">Generic</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Type Generic cannot be instantiated; &quot;</span>\n                            <span class=\"s2\">&quot;it can be used only as a base class&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__new__</span> <span class=\"ow\">is</span> <span class=\"nb\">object</span><span class=\"o\">.</span><span class=\"fm\">__new__</span> <span class=\"ow\">and</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"fm\">__init__</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"nb\">object</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">:</span>\n            <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">obj</span>\n\n    <span class=\"nd\">@_tp_cache</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__class_getitem__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">params</span> <span class=\"ow\">and</span> <span class=\"bp\">cls</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"n\">Tuple</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span>\n                <span class=\"sa\">f</span><span class=\"s2\">&quot;Parameter list to </span><span class=\"si\">{cls.__qualname__}</span><span class=\"s2\">[...] cannot be empty&quot;</span><span class=\"p\">)</span>\n        <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;Parameters to generic types must be types.&quot;</span>\n        <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">cls</span> <span class=\"ow\">is</span> <span class=\"n\">Generic</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Generic can only be subscripted with unique type variables.</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">all</span><span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">TypeVar</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span>\n                    <span class=\"s2\">&quot;Parameters to Generic[...] must all be type variables&quot;</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">))</span> <span class=\"o\">!=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">):</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span>\n                    <span class=\"s2\">&quot;Parameters to Generic[...] must all be unique&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"bp\">cls</span> <span class=\"ow\">is</span> <span class=\"n\">_Protocol</span><span class=\"p\">:</span>\n            <span class=\"c1\"># _Protocol is internal at the moment, just skip the check</span>\n            <span class=\"k\">pass</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Subscripting a regular Generic subclass.</span>\n            <span class=\"n\">_check_generic</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__init_subclass__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">__init_subclass__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"n\">tvars</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">if</span> <span class=\"s1\">&#39;__orig_bases__&#39;</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">:</span>\n            <span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">Generic</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__orig_bases__</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">Generic</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__bases__</span> <span class=\"ow\">and</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;_Protocol&#39;</span>\n        <span class=\"k\">if</span> <span class=\"n\">error</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Cannot inherit from plain Generic&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"s1\">&#39;__orig_bases__&#39;</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">:</span>\n            <span class=\"n\">tvars</span> <span class=\"o\">=</span> <span class=\"n\">_collect_type_vars</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__orig_bases__</span><span class=\"p\">)</span>\n            <span class=\"c1\"># Look for Generic[T1, ..., Tn].</span>\n            <span class=\"c1\"># If found, tvars must be a subset of it.</span>\n            <span class=\"c1\"># If not found, tvars is it.</span>\n            <span class=\"c1\"># Also check for and reject plain Generic,</span>\n            <span class=\"c1\"># and reject multiple Generic[...].</span>\n            <span class=\"n\">gvars</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n            <span class=\"k\">for</span> <span class=\"n\">base</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__orig_bases__</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n                        <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Generic</span><span class=\"p\">):</span>\n                    <span class=\"k\">if</span> <span class=\"n\">gvars</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span>\n                            <span class=\"s2\">&quot;Cannot inherit from Generic[...] multiple types.&quot;</span><span class=\"p\">)</span>\n                    <span class=\"n\">gvars</span> <span class=\"o\">=</span> <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span>\n            <span class=\"k\">if</span> <span class=\"n\">gvars</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">gvars</span> <span class=\"o\">=</span> <span class=\"n\">tvars</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">tvarset</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">tvars</span><span class=\"p\">)</span>\n                <span class=\"n\">gvarset</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">gvars</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">tvarset</span> <span class=\"o\">&lt;=</span> <span class=\"n\">gvarset</span><span class=\"p\">:</span>\n                    <span class=\"n\">s_vars</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;, &#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">tvars</span> <span class=\"k\">if</span> <span class=\"n\">t</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">gvarset</span><span class=\"p\">)</span>\n                    <span class=\"n\">s_args</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;, &#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">g</span> <span class=\"ow\">in</span> <span class=\"n\">gvars</span><span class=\"p\">)</span>\n                    <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Some type variables (</span><span class=\"si\">{s_vars}</span><span class=\"s2\">) are&quot;</span>\n                                    <span class=\"sa\">f</span><span class=\"s2\">&quot; not listed in Generic[</span><span class=\"si\">{s_args}</span><span class=\"s2\">]&quot;</span><span class=\"p\">)</span>\n                <span class=\"n\">tvars</span> <span class=\"o\">=</span> <span class=\"n\">gvars</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">tvars</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_TypingEmpty</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;Internal placeholder for () or []. Used by TupleMeta and CallableMeta</span>\n<span class=\"sd\">    to allow empty list/tuple in specific places, without allowing them</span>\n<span class=\"sd\">    to sneak in where prohibited.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_TypingEllipsis</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;Internal placeholder for ... (ellipsis).&quot;&quot;&quot;</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">cast</span><span class=\"p\">(</span><span class=\"n\">typ</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Cast a value to a type.</span>\n\n<span class=\"sd\">    This returns the value unchanged.  To the type checker this</span>\n<span class=\"sd\">    signals that the return value has the designated type, but at</span>\n<span class=\"sd\">    runtime we intentionally don&#39;t check anything (we want this</span>\n<span class=\"sd\">    to be as fast as possible).</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">return</span> <span class=\"n\">val</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_get_defaults</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Internal helper to extract the default arguments, by name.&quot;&quot;&quot;</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">code</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"o\">.</span><span class=\"vm\">__code__</span>\n    <span class=\"k\">except</span> <span class=\"ne\">AttributeError</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Some built-in functions don&#39;t have __code__, __defaults__, etc.</span>\n        <span class=\"k\">return</span> <span class=\"p\">{}</span>\n    <span class=\"n\">pos_count</span> <span class=\"o\">=</span> <span class=\"n\">code</span><span class=\"o\">.</span><span class=\"n\">co_argcount</span>\n    <span class=\"n\">arg_names</span> <span class=\"o\">=</span> <span class=\"n\">code</span><span class=\"o\">.</span><span class=\"n\">co_varnames</span>\n    <span class=\"n\">arg_names</span> <span class=\"o\">=</span> <span class=\"n\">arg_names</span><span class=\"p\">[:</span><span class=\"n\">pos_count</span><span class=\"p\">]</span>\n    <span class=\"n\">defaults</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"o\">.</span><span class=\"vm\">__defaults__</span> <span class=\"ow\">or</span> <span class=\"p\">()</span>\n    <span class=\"n\">kwdefaults</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"o\">.</span><span class=\"vm\">__kwdefaults__</span>\n    <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">kwdefaults</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">kwdefaults</span> <span class=\"k\">else</span> <span class=\"p\">{}</span>\n    <span class=\"n\">pos_offset</span> <span class=\"o\">=</span> <span class=\"n\">pos_count</span> <span class=\"o\">-</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">defaults</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">arg_names</span><span class=\"p\">[</span><span class=\"n\">pos_offset</span><span class=\"p\">:],</span> <span class=\"n\">defaults</span><span class=\"p\">):</span>\n        <span class=\"k\">assert</span> <span class=\"n\">name</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">res</span>\n        <span class=\"n\">res</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n    <span class=\"k\">return</span> <span class=\"n\">res</span>\n\n\n<span class=\"n\">_allowed_types</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">FunctionType</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">BuiltinFunctionType</span><span class=\"p\">,</span>\n                  <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">MethodType</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">ModuleType</span><span class=\"p\">,</span>\n                  <span class=\"n\">WrapperDescriptorType</span><span class=\"p\">,</span> <span class=\"n\">MethodWrapperType</span><span class=\"p\">,</span> <span class=\"n\">MethodDescriptorType</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">get_type_hints</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Return type hints for an object.</span>\n\n<span class=\"sd\">    This is often the same as obj.__annotations__, but it handles</span>\n<span class=\"sd\">    forward references encoded as string literals, and if necessary</span>\n<span class=\"sd\">    adds Optional[t] if a default value equal to None is set.</span>\n\n<span class=\"sd\">    The argument may be a module, class, method, or function. The annotations</span>\n<span class=\"sd\">    are returned as a dictionary. For classes, annotations include also</span>\n<span class=\"sd\">    inherited members.</span>\n\n<span class=\"sd\">    TypeError is raised if the argument is not of a type that can contain</span>\n<span class=\"sd\">    annotations, and an empty dictionary is returned if no annotations are</span>\n<span class=\"sd\">    present.</span>\n\n<span class=\"sd\">    BEWARE -- the behavior of globalns and localns is counterintuitive</span>\n<span class=\"sd\">    (unless you are familiar with how eval() and exec() work).  The</span>\n<span class=\"sd\">    search order is locals first, then globals.</span>\n\n<span class=\"sd\">    - If no dict arguments are passed, an attempt is made to use the</span>\n<span class=\"sd\">      globals from obj (or the respective module&#39;s globals for classes),</span>\n<span class=\"sd\">      and these are also used as the locals.  If the object does not appear</span>\n<span class=\"sd\">      to have globals, an empty dictionary is used.</span>\n\n<span class=\"sd\">    - If one dict argument is passed, it is used for both globals and</span>\n<span class=\"sd\">      locals.</span>\n\n<span class=\"sd\">    - If two dict arguments are passed, they specify globals and</span>\n<span class=\"sd\">      locals, respectively.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"k\">if</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__no_type_check__&#39;</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"p\">{}</span>\n    <span class=\"c1\"># Classes require a special treatment.</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">):</span>\n        <span class=\"n\">hints</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"k\">for</span> <span class=\"n\">base</span> <span class=\"ow\">in</span> <span class=\"nb\">reversed</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__mro__</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">globalns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">base_globals</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">modules</span><span class=\"p\">[</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__module__</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">base_globals</span> <span class=\"o\">=</span> <span class=\"n\">globalns</span>\n            <span class=\"n\">ann</span> <span class=\"o\">=</span> <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;__annotations__&#39;</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n            <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">ann</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n                <span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">):</span>\n                    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">ForwardRef</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">is_argument</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n                <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">_eval_type</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">base_globals</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">)</span>\n                <span class=\"n\">hints</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n        <span class=\"k\">return</span> <span class=\"n\">hints</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">globalns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">ModuleType</span><span class=\"p\">):</span>\n            <span class=\"n\">globalns</span> <span class=\"o\">=</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">globalns</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__globals__&#39;</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n        <span class=\"k\">if</span> <span class=\"n\">localns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">localns</span> <span class=\"o\">=</span> <span class=\"n\">globalns</span>\n    <span class=\"k\">elif</span> <span class=\"n\">localns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">localns</span> <span class=\"o\">=</span> <span class=\"n\">globalns</span>\n    <span class=\"n\">hints</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__annotations__&#39;</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">hints</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Return empty annotations for something that _could_ have them.</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">_allowed_types</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"p\">{}</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s1\">&#39;</span><span class=\"si\">{!r}</span><span class=\"s1\"> is not a module, class, method, &#39;</span>\n                            <span class=\"s1\">&#39;or function.&#39;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">))</span>\n    <span class=\"n\">defaults</span> <span class=\"o\">=</span> <span class=\"n\">_get_defaults</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n    <span class=\"n\">hints</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">hints</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">hints</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n        <span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">):</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">ForwardRef</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">_eval_type</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"n\">defaults</span> <span class=\"ow\">and</span> <span class=\"n\">defaults</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">value</span><span class=\"p\">]</span>\n        <span class=\"n\">hints</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n    <span class=\"k\">return</span> <span class=\"n\">hints</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">no_type_check</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Decorator to indicate that annotations are not type hints.</span>\n\n<span class=\"sd\">    The argument must be a class or function; if it is a class, it</span>\n<span class=\"sd\">    applies recursively to all methods and classes defined in that class</span>\n<span class=\"sd\">    (but not to methods defined in its superclasses or subclasses).</span>\n\n<span class=\"sd\">    This mutates the function(s) or class(es) in place.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">):</span>\n        <span class=\"n\">arg_attrs</span> <span class=\"o\">=</span> <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n        <span class=\"k\">for</span> <span class=\"n\">attr</span><span class=\"p\">,</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n            <span class=\"k\">if</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"vm\">__bases__</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,):</span>\n                <span class=\"n\">arg_attrs</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">obj</span> <span class=\"ow\">in</span> <span class=\"n\">arg_attrs</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">():</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">FunctionType</span><span class=\"p\">):</span>\n                <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">__no_type_check__</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">):</span>\n                <span class=\"n\">no_type_check</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"n\">__no_type_check__</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"k\">except</span> <span class=\"ne\">TypeError</span><span class=\"p\">:</span>  <span class=\"c1\"># built-in classes</span>\n        <span class=\"k\">pass</span>\n    <span class=\"k\">return</span> <span class=\"n\">arg</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">no_type_check_decorator</span><span class=\"p\">(</span><span class=\"n\">decorator</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Decorator to give another decorator the @no_type_check effect.</span>\n\n<span class=\"sd\">    This wraps the decorator with something that wraps the decorated</span>\n<span class=\"sd\">    function in @no_type_check.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@functools</span><span class=\"o\">.</span><span class=\"n\">wraps</span><span class=\"p\">(</span><span class=\"n\">decorator</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">wrapped_decorator</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"n\">decorator</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">)</span>\n        <span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"n\">no_type_check</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">func</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">wrapped_decorator</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_overload_dummy</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Helper for @overload to raise when called.&quot;&quot;&quot;</span>\n    <span class=\"k\">raise</span> <span class=\"ne\">NotImplementedError</span><span class=\"p\">(</span>\n        <span class=\"s2\">&quot;You should not call an overloaded function. &quot;</span>\n        <span class=\"s2\">&quot;A series of @overload-decorated functions &quot;</span>\n        <span class=\"s2\">&quot;outside a stub module should always be followed &quot;</span>\n        <span class=\"s2\">&quot;by an implementation that is not @overload-ed.&quot;</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">overload</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Decorator for overloaded functions/methods.</span>\n\n<span class=\"sd\">    In a stub file, place two or more stub definitions for the same</span>\n<span class=\"sd\">    function in a row, each decorated with @overload.  For example:</span>\n\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: None) -&gt; None: ...</span>\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: bytes) -&gt; bytes: ...</span>\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: str) -&gt; bytes: ...</span>\n\n<span class=\"sd\">    In a non-stub file (i.e. a regular .py file), do the same but</span>\n<span class=\"sd\">    follow it with an implementation.  The implementation should *not*</span>\n<span class=\"sd\">    be decorated with @overload.  For example:</span>\n\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: None) -&gt; None: ...</span>\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: bytes) -&gt; bytes: ...</span>\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: str) -&gt; bytes: ...</span>\n<span class=\"sd\">      def utf8(value):</span>\n<span class=\"sd\">          # implementation goes here</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">return</span> <span class=\"n\">_overload_dummy</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_ProtocolMeta</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Internal metaclass for _Protocol.</span>\n\n<span class=\"sd\">    This exists so _Protocol classes can be generic without deriving</span>\n<span class=\"sd\">    from Generic.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__instancecheck__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">_Protocol</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__bases__</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__instancecheck__</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Protocols cannot be used with isinstance().&quot;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__subclasscheck__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_is_protocol</span><span class=\"p\">:</span>\n            <span class=\"c1\"># No structural checks since this isn&#39;t a protocol.</span>\n            <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n\n        <span class=\"k\">if</span> <span class=\"bp\">self</span> <span class=\"ow\">is</span> <span class=\"n\">_Protocol</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Every class is a subclass of the empty protocol.</span>\n            <span class=\"k\">return</span> <span class=\"kc\">True</span>\n\n        <span class=\"c1\"># Find all attributes defined in the protocol.</span>\n        <span class=\"n\">attrs</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_get_protocol_attrs</span><span class=\"p\">()</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"n\">attrs</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"n\">d</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span> <span class=\"k\">for</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__mro__</span><span class=\"p\">):</span>\n                <span class=\"k\">return</span> <span class=\"kc\">False</span>\n        <span class=\"k\">return</span> <span class=\"kc\">True</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_get_protocol_attrs</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Get all Protocol base classes.</span>\n        <span class=\"n\">protocol_bases</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__mro__</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_is_protocol&#39;</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;_Protocol&#39;</span><span class=\"p\">:</span>\n                <span class=\"n\">protocol_bases</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Get attributes included in protocol.</span>\n        <span class=\"n\">attrs</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">()</span>\n        <span class=\"k\">for</span> <span class=\"n\">base</span> <span class=\"ow\">in</span> <span class=\"n\">protocol_bases</span><span class=\"p\">:</span>\n            <span class=\"k\">for</span> <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">():</span>\n                <span class=\"c1\"># Include attributes not defined in any non-protocol bases.</span>\n                <span class=\"k\">for</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__mro__</span><span class=\"p\">:</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">c</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"n\">base</span> <span class=\"ow\">and</span> <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span> <span class=\"ow\">and</span>\n                            <span class=\"ow\">not</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_is_protocol&#39;</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">)):</span>\n                        <span class=\"k\">break</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"ow\">not</span> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">startswith</span><span class=\"p\">(</span><span class=\"s1\">&#39;_abc_&#39;</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__abstractmethods__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__annotations__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__weakref__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;_is_protocol&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;_gorg&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__dict__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__args__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__slots__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;_get_protocol_attrs&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__next_in_mro__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__parameters__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__origin__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__orig_bases__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__extra__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__tree_hash__&#39;</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"o\">!=</span> <span class=\"s1\">&#39;__module__&#39;</span><span class=\"p\">):</span>\n                        <span class=\"n\">attrs</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">attrs</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_Protocol</span><span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">,</span> <span class=\"n\">metaclass</span><span class=\"o\">=</span><span class=\"n\">_ProtocolMeta</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Internal base class for protocol classes.</span>\n\n<span class=\"sd\">    This implements a simple-minded structural issubclass check</span>\n<span class=\"sd\">    (similar but more general than the one-offs in collections.abc</span>\n<span class=\"sd\">    such as Hashable).</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"n\">_is_protocol</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__class_getitem__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">__class_getitem__</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># Some unconstrained type variables.  These are used by the container types.</span>\n<span class=\"c1\"># (These are not for export.)</span>\n<span class=\"n\">T</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">&#39;T&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># Any type.</span>\n<span class=\"n\">KT</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">&#39;KT&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># Key type.</span>\n<span class=\"n\">VT</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">&#39;VT&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># Value type.</span>\n<span class=\"n\">T_co</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">&#39;T_co&#39;</span><span class=\"p\">,</span> <span class=\"n\">covariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># Any type covariant containers.</span>\n<span class=\"n\">V_co</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">&#39;V_co&#39;</span><span class=\"p\">,</span> <span class=\"n\">covariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># Any type covariant containers.</span>\n<span class=\"n\">VT_co</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">&#39;VT_co&#39;</span><span class=\"p\">,</span> <span class=\"n\">covariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># Value type covariant containers.</span>\n<span class=\"n\">T_contra</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">&#39;T_contra&#39;</span><span class=\"p\">,</span> <span class=\"n\">contravariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># Ditto contravariant.</span>\n<span class=\"c1\"># Internal type variable used for Type[].</span>\n<span class=\"n\">CT_co</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">&#39;CT_co&#39;</span><span class=\"p\">,</span> <span class=\"n\">covariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"nb\">type</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># A useful type variable with constraints.  This represents string types.</span>\n<span class=\"c1\"># (This one *is* for export!)</span>\n<span class=\"n\">AnyStr</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">&#39;AnyStr&#39;</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># Various ABCs mimicking those in collections.abc.</span>\n<span class=\"k\">def</span> <span class=\"nf\">_alias</span><span class=\"p\">(</span><span class=\"n\">origin</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"n\">origin</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">special</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"n\">inst</span><span class=\"p\">)</span>\n\n<span class=\"n\">Hashable</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Hashable</span><span class=\"p\">,</span> <span class=\"p\">())</span>  <span class=\"c1\"># Not generic.</span>\n<span class=\"n\">Awaitable</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Awaitable</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Coroutine</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Coroutine</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">T_co</span><span class=\"p\">,</span> <span class=\"n\">T_contra</span><span class=\"p\">,</span> <span class=\"n\">V_co</span><span class=\"p\">))</span>\n<span class=\"n\">AsyncIterable</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">AsyncIterable</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">AsyncIterator</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">AsyncIterator</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Iterable</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Iterable</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Iterator</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Iterator</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Reversible</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Reversible</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Sized</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Sized</span><span class=\"p\">,</span> <span class=\"p\">())</span>  <span class=\"c1\"># Not generic.</span>\n<span class=\"n\">Container</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Container</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Collection</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Collection</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"n\">_VariadicGenericAlias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"p\">(),</span> <span class=\"n\">special</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">Callable</span><span class=\"o\">.</span><span class=\"vm\">__doc__</span> <span class=\"o\">=</span> \\\n    <span class=\"sd\">&quot;&quot;&quot;Callable type; Callable[[int], str] is a function of (int) -&gt; str.</span>\n\n<span class=\"sd\">    The subscription syntax must always be used with exactly two</span>\n<span class=\"sd\">    values: the argument list and the return type.  The argument list</span>\n<span class=\"sd\">    must be a list of types or ellipsis; the return type must be a single type.</span>\n\n<span class=\"sd\">    There is no syntax to indicate optional or keyword arguments,</span>\n<span class=\"sd\">    such function types are rarely used as callback types.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n<span class=\"n\">AbstractSet</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Set</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">MutableSet</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">MutableSet</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"c1\"># NOTE: Mapping is only covariant in the value type.</span>\n<span class=\"n\">Mapping</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Mapping</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT_co</span><span class=\"p\">))</span>\n<span class=\"n\">MutableMapping</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">MutableMapping</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">))</span>\n<span class=\"n\">Sequence</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Sequence</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">MutableSequence</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">MutableSequence</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"n\">ByteString</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">ByteString</span><span class=\"p\">,</span> <span class=\"p\">())</span>  <span class=\"c1\"># Not generic</span>\n<span class=\"n\">Tuple</span> <span class=\"o\">=</span> <span class=\"n\">_VariadicGenericAlias</span><span class=\"p\">(</span><span class=\"nb\">tuple</span><span class=\"p\">,</span> <span class=\"p\">(),</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">special</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">Tuple</span><span class=\"o\">.</span><span class=\"vm\">__doc__</span> <span class=\"o\">=</span> \\\n    <span class=\"sd\">&quot;&quot;&quot;Tuple type; Tuple[X, Y] is the cross-product type of X and Y.</span>\n\n<span class=\"sd\">    Example: Tuple[T1, T2] is a tuple of two elements corresponding</span>\n<span class=\"sd\">    to type variables T1 and T2.  Tuple[int, float, str] is a tuple</span>\n<span class=\"sd\">    of an int, a float and a string.</span>\n\n<span class=\"sd\">    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n<span class=\"n\">List</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">Deque</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">deque</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"n\">Set</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">FrozenSet</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"nb\">frozenset</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">MappingView</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">MappingView</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">KeysView</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">KeysView</span><span class=\"p\">,</span> <span class=\"n\">KT</span><span class=\"p\">)</span>\n<span class=\"n\">ItemsView</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">ItemsView</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT_co</span><span class=\"p\">))</span>\n<span class=\"n\">ValuesView</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">ValuesView</span><span class=\"p\">,</span> <span class=\"n\">VT_co</span><span class=\"p\">)</span>\n<span class=\"n\">ContextManager</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">contextlib</span><span class=\"o\">.</span><span class=\"n\">AbstractContextManager</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">AsyncContextManager</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">contextlib</span><span class=\"o\">.</span><span class=\"n\">AbstractAsyncContextManager</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Dict</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">),</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">DefaultDict</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">defaultdict</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">))</span>\n<span class=\"n\">OrderedDict</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">OrderedDict</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">))</span>\n<span class=\"n\">Counter</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">Counter</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"n\">ChainMap</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">ChainMap</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">))</span>\n<span class=\"n\">Generator</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Generator</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">T_co</span><span class=\"p\">,</span> <span class=\"n\">T_contra</span><span class=\"p\">,</span> <span class=\"n\">V_co</span><span class=\"p\">))</span>\n<span class=\"n\">AsyncGenerator</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">AsyncGenerator</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">T_co</span><span class=\"p\">,</span> <span class=\"n\">T_contra</span><span class=\"p\">))</span>\n<span class=\"n\">Type</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">,</span> <span class=\"n\">CT_co</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">Type</span><span class=\"o\">.</span><span class=\"vm\">__doc__</span> <span class=\"o\">=</span> \\\n    <span class=\"sd\">&quot;&quot;&quot;A special construct usable to annotate class objects.</span>\n\n<span class=\"sd\">    For example, suppose we have the following classes::</span>\n\n<span class=\"sd\">      class User: ...  # Abstract base for User classes</span>\n<span class=\"sd\">      class BasicUser(User): ...</span>\n<span class=\"sd\">      class ProUser(User): ...</span>\n<span class=\"sd\">      class TeamUser(User): ...</span>\n\n<span class=\"sd\">    And a function that takes a class argument that&#39;s a subclass of</span>\n<span class=\"sd\">    User and returns an instance of the corresponding class::</span>\n\n<span class=\"sd\">      U = TypeVar(&#39;U&#39;, bound=User)</span>\n<span class=\"sd\">      def new_user(user_class: Type[U]) -&gt; U:</span>\n<span class=\"sd\">          user = user_class()</span>\n<span class=\"sd\">          # (Here we could write the user object to a database)</span>\n<span class=\"sd\">          return user</span>\n\n<span class=\"sd\">      joe = new_user(BasicUser)</span>\n\n<span class=\"sd\">    At this point the type checker knows that joe has type BasicUser.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">SupportsInt</span><span class=\"p\">(</span><span class=\"n\">_Protocol</span><span class=\"p\">):</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__int__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">SupportsFloat</span><span class=\"p\">(</span><span class=\"n\">_Protocol</span><span class=\"p\">):</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__float__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">float</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">SupportsComplex</span><span class=\"p\">(</span><span class=\"n\">_Protocol</span><span class=\"p\">):</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__complex__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">complex</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">SupportsBytes</span><span class=\"p\">(</span><span class=\"n\">_Protocol</span><span class=\"p\">):</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__bytes__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bytes</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">SupportsAbs</span><span class=\"p\">(</span><span class=\"n\">_Protocol</span><span class=\"p\">[</span><span class=\"n\">T_co</span><span class=\"p\">]):</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__abs__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">T_co</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">SupportsRound</span><span class=\"p\">(</span><span class=\"n\">_Protocol</span><span class=\"p\">[</span><span class=\"n\">T_co</span><span class=\"p\">]):</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__round__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">ndigits</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">T_co</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_make_nmtuple</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"p\">):</span>\n    <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;NamedTuple(&#39;Name&#39;, [(f0, t0), (f1, t1), ...]); each t must be a type&quot;</span>\n    <span class=\"n\">types</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">]</span>\n    <span class=\"n\">nm_tpl</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">namedtuple</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">n</span> <span class=\"k\">for</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">])</span>\n    <span class=\"c1\"># Prior to PEP 526, only _field_types attribute was assigned.</span>\n    <span class=\"c1\"># Now, both __annotations__ and _field_types are used to maintain compatibility.</span>\n    <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"vm\">__annotations__</span> <span class=\"o\">=</span> <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"n\">_field_types</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">OrderedDict</span><span class=\"p\">(</span><span class=\"n\">types</span><span class=\"p\">)</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"vm\">__module__</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">_getframe</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">f_globals</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;__name__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__main__&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">except</span> <span class=\"p\">(</span><span class=\"ne\">AttributeError</span><span class=\"p\">,</span> <span class=\"ne\">ValueError</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n    <span class=\"k\">return</span> <span class=\"n\">nm_tpl</span>\n\n\n<span class=\"c1\"># attributes prohibited to set in NamedTuple class syntax</span>\n<span class=\"n\">_prohibited</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;__new__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__init__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__slots__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__getnewargs__&#39;</span><span class=\"p\">,</span>\n               <span class=\"s1\">&#39;_fields&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_field_defaults&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_field_types&#39;</span><span class=\"p\">,</span>\n               <span class=\"s1\">&#39;_make&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_replace&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_asdict&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;_source&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">_special</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;__module__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__name__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__qualname__&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__annotations__&#39;</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">NamedTupleMeta</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"n\">bases</span><span class=\"p\">,</span> <span class=\"n\">ns</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">ns</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;_root&#39;</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"n\">bases</span><span class=\"p\">,</span> <span class=\"n\">ns</span><span class=\"p\">)</span>\n        <span class=\"n\">types</span> <span class=\"o\">=</span> <span class=\"n\">ns</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;__annotations__&#39;</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n        <span class=\"n\">nm_tpl</span> <span class=\"o\">=</span> <span class=\"n\">_make_nmtuple</span><span class=\"p\">(</span><span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">())</span>\n        <span class=\"n\">defaults</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"n\">defaults_dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"k\">for</span> <span class=\"n\">field_name</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">field_name</span> <span class=\"ow\">in</span> <span class=\"n\">ns</span><span class=\"p\">:</span>\n                <span class=\"n\">default_value</span> <span class=\"o\">=</span> <span class=\"n\">ns</span><span class=\"p\">[</span><span class=\"n\">field_name</span><span class=\"p\">]</span>\n                <span class=\"n\">defaults</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">default_value</span><span class=\"p\">)</span>\n                <span class=\"n\">defaults_dict</span><span class=\"p\">[</span><span class=\"n\">field_name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">default_value</span>\n            <span class=\"k\">elif</span> <span class=\"n\">defaults</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Non-default namedtuple field </span><span class=\"si\">{field_name}</span><span class=\"s2\"> cannot &quot;</span>\n                                <span class=\"s2\">&quot;follow default field(s) </span><span class=\"si\">{default_names}</span><span class=\"s2\">&quot;</span>\n                                <span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">field_name</span><span class=\"o\">=</span><span class=\"n\">field_name</span><span class=\"p\">,</span>\n                                        <span class=\"n\">default_names</span><span class=\"o\">=</span><span class=\"s1\">&#39;, &#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">defaults_dict</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())))</span>\n        <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"o\">.</span><span class=\"vm\">__annotations__</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">OrderedDict</span><span class=\"p\">(</span><span class=\"n\">types</span><span class=\"p\">)</span>\n        <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"o\">.</span><span class=\"vm\">__defaults__</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">defaults</span><span class=\"p\">)</span>\n        <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"n\">_field_defaults</span> <span class=\"o\">=</span> <span class=\"n\">defaults_dict</span>\n        <span class=\"c1\"># update from user namespace without overriding special namedtuple attributes</span>\n        <span class=\"k\">for</span> <span class=\"n\">key</span> <span class=\"ow\">in</span> <span class=\"n\">ns</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">key</span> <span class=\"ow\">in</span> <span class=\"n\">_prohibited</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">AttributeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Cannot overwrite NamedTuple attribute &quot;</span> <span class=\"o\">+</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n            <span class=\"k\">elif</span> <span class=\"n\">key</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">_special</span> <span class=\"ow\">and</span> <span class=\"n\">key</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"n\">_fields</span><span class=\"p\">:</span>\n                <span class=\"nb\">setattr</span><span class=\"p\">(</span><span class=\"n\">nm_tpl</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">ns</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">])</span>\n        <span class=\"k\">return</span> <span class=\"n\">nm_tpl</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">NamedTuple</span><span class=\"p\">(</span><span class=\"n\">metaclass</span><span class=\"o\">=</span><span class=\"n\">NamedTupleMeta</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Typed version of namedtuple.</span>\n\n<span class=\"sd\">    Usage in Python versions &gt;= 3.6::</span>\n\n<span class=\"sd\">        class Employee(NamedTuple):</span>\n<span class=\"sd\">            name: str</span>\n<span class=\"sd\">            id: int</span>\n\n<span class=\"sd\">    This is equivalent to::</span>\n\n<span class=\"sd\">        Employee = collections.namedtuple(&#39;Employee&#39;, [&#39;name&#39;, &#39;id&#39;])</span>\n\n<span class=\"sd\">    The resulting class has extra __annotations__ and _field_types</span>\n<span class=\"sd\">    attributes, giving an ordered dict mapping field names to types.</span>\n<span class=\"sd\">    __annotations__ should be preferred, while _field_types</span>\n<span class=\"sd\">    is kept to maintain pre PEP 526 compatibility. (The field names</span>\n<span class=\"sd\">    are in the _fields attribute, which is part of the namedtuple</span>\n<span class=\"sd\">    API.) Alternative equivalent keyword syntax is also accepted::</span>\n\n<span class=\"sd\">        Employee = NamedTuple(&#39;Employee&#39;, name=str, id=int)</span>\n\n<span class=\"sd\">    In Python versions &lt;= 3.5 use::</span>\n\n<span class=\"sd\">        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">_root</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">fields</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"n\">kwargs</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()</span>\n        <span class=\"k\">elif</span> <span class=\"n\">kwargs</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;Either list of fields or keywords&quot;</span>\n                            <span class=\"s2\">&quot; can be provided to NamedTuple, not both&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">_make_nmtuple</span><span class=\"p\">(</span><span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">NewType</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">tp</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;NewType creates simple unique types with almost zero</span>\n<span class=\"sd\">    runtime overhead. NewType(name, tp) is considered a subtype of tp</span>\n<span class=\"sd\">    by static type checkers. At runtime, NewType(name, tp) returns</span>\n<span class=\"sd\">    a dummy function that simply returns its argument. Usage::</span>\n\n<span class=\"sd\">        UserId = NewType(&#39;UserId&#39;, int)</span>\n\n<span class=\"sd\">        def name_by_id(user_id: UserId) -&gt; str:</span>\n<span class=\"sd\">            ...</span>\n\n<span class=\"sd\">        UserId(&#39;user&#39;)          # Fails type check</span>\n\n<span class=\"sd\">        name_by_id(42)          # Fails type check</span>\n<span class=\"sd\">        name_by_id(UserId(42))  # OK</span>\n\n<span class=\"sd\">        num = UserId(5) + 1     # type: int</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">new_type</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">x</span>\n\n    <span class=\"n\">new_type</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n    <span class=\"n\">new_type</span><span class=\"o\">.</span><span class=\"n\">__supertype__</span> <span class=\"o\">=</span> <span class=\"n\">tp</span>\n    <span class=\"k\">return</span> <span class=\"n\">new_type</span>\n\n\n<span class=\"c1\"># Python-version-specific alias (Python 2: unicode; Python 3: str)</span>\n<span class=\"n\">Text</span> <span class=\"o\">=</span> <span class=\"nb\">str</span>\n\n\n<span class=\"c1\"># Constant that&#39;s True when type checking, but False here.</span>\n<span class=\"n\">TYPE_CHECKING</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">IO</span><span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">[</span><span class=\"n\">AnyStr</span><span class=\"p\">]):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Generic base class for TextIO and BinaryIO.</span>\n\n<span class=\"sd\">    This is an abstract, generic version of the return of open().</span>\n\n<span class=\"sd\">    NOTE: This does not distinguish between the different possible</span>\n<span class=\"sd\">    classes (text vs. binary, read vs. write vs. read/write,</span>\n<span class=\"sd\">    append-only, unbuffered).  The TextIO and BinaryIO subclasses</span>\n<span class=\"sd\">    below capture the distinctions between text vs. binary, which is</span>\n<span class=\"sd\">    pervasive in the interface; however we currently do not offer a</span>\n<span class=\"sd\">    way to track the other distinctions in the type system.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractproperty</span>\n    <span class=\"k\">def</span> <span class=\"nf\">mode</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">str</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractproperty</span>\n    <span class=\"k\">def</span> <span class=\"nf\">name</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">str</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">close</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">closed</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fileno</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">flush</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isatty</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">AnyStr</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">readable</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">readline</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">AnyStr</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">readlines</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">hint</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">AnyStr</span><span class=\"p\">]:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">seek</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">whence</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">seekable</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">tell</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">truncate</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">writable</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">AnyStr</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">writelines</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lines</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">AnyStr</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__enter__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">&#39;IO[AnyStr]&#39;</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__exit__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">traceback</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">BinaryIO</span><span class=\"p\">(</span><span class=\"n\">IO</span><span class=\"p\">[</span><span class=\"nb\">bytes</span><span class=\"p\">]):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Typed version of the return of open() in binary mode.&quot;&quot;&quot;</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"nb\">bytearray</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__enter__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">&#39;BinaryIO&#39;</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">TextIO</span><span class=\"p\">(</span><span class=\"n\">IO</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Typed version of the return of open() in text mode.&quot;&quot;&quot;</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractproperty</span>\n    <span class=\"k\">def</span> <span class=\"nf\">buffer</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">BinaryIO</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractproperty</span>\n    <span class=\"k\">def</span> <span class=\"nf\">encoding</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">str</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractproperty</span>\n    <span class=\"k\">def</span> <span class=\"nf\">errors</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractproperty</span>\n    <span class=\"k\">def</span> <span class=\"nf\">line_buffering</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractproperty</span>\n    <span class=\"k\">def</span> <span class=\"nf\">newlines</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Any</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__enter__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">&#39;TextIO&#39;</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">io</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;Wrapper namespace for IO generic classes.&quot;&quot;&quot;</span>\n\n    <span class=\"n\">__all__</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;IO&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;TextIO&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;BinaryIO&#39;</span><span class=\"p\">]</span>\n    <span class=\"n\">IO</span> <span class=\"o\">=</span> <span class=\"n\">IO</span>\n    <span class=\"n\">TextIO</span> <span class=\"o\">=</span> <span class=\"n\">TextIO</span>\n    <span class=\"n\">BinaryIO</span> <span class=\"o\">=</span> <span class=\"n\">BinaryIO</span>\n\n\n<span class=\"n\">io</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">=</span> <span class=\"vm\">__name__</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;.io&#39;</span>\n<span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">modules</span><span class=\"p\">[</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">io</span>\n\n<span class=\"n\">Pattern</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">stdlib_re</span><span class=\"o\">.</span><span class=\"n\">Pattern</span><span class=\"p\">,</span> <span class=\"n\">AnyStr</span><span class=\"p\">)</span>\n<span class=\"n\">Match</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">stdlib_re</span><span class=\"o\">.</span><span class=\"n\">Match</span><span class=\"p\">,</span> <span class=\"n\">AnyStr</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">re</span><span class=\"p\">:</span>\n    <span class=\"sd\">&quot;&quot;&quot;Wrapper namespace for re type aliases.&quot;&quot;&quot;</span>\n\n    <span class=\"n\">__all__</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;Pattern&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Match&#39;</span><span class=\"p\">]</span>\n    <span class=\"n\">Pattern</span> <span class=\"o\">=</span> <span class=\"n\">Pattern</span>\n    <span class=\"n\">Match</span> <span class=\"o\">=</span> <span class=\"n\">Match</span>\n\n\n<span class=\"n\">re</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">=</span> <span class=\"vm\">__name__</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;.re&#39;</span>\n<span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">modules</span><span class=\"p\">[</span><span class=\"n\">re</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">re</span>\n</pre></div>",
  "current_page_name": "_modules/typing",
  "sidebars": ["globaltoc.html", "searchbox.html"],
  "customsidebar": null,
  "alabaster_version": "0.7.12"
}
