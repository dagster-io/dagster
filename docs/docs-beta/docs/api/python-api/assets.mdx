---
title: 'assets'
title_meta: 'assets API Documentation - Build Better Data Pipelines | Python Reference Documentation for Dagster'
description: 'assets Dagster API | Comprehensive Python API documentation for Dagster, the data orchestration platform. Learn how to build, test, and maintain data pipelines with our detailed guides and examples.'
last_update:
  date: '2025-01-23'
---

<div class="section" id="assets">


# Assets

An asset is an object in persistent storage, such as a table, file, or persisted machine learning model. An asset definition is a description, in code, of an asset that should exist and how to produce and update that asset.

<div class="section" id="asset-definitions">


## Asset definitions

Refer to the [Asset definitions](https://docs.dagster.io/concepts/assets/software-defined-assets) documentation for more information.

<dl>
    <dt><Link id='dagster.asset'>@dagster.asset</Link></dt>
    <dd>

    Create a definition for how to compute an asset.

    A software-defined asset is the combination of:
        1. An asset key, e.g. the name of a table.
        2. A function, which can be run to compute the contents of the asset.
        3. A set of upstream assets that are provided as inputs to the function when computing the asset.
    Unlike an op, whose dependencies are determined by the graph it lives inside, an asset knows
    about the upstream assets it depends on. The upstream assets are inferred from the arguments
    to the decorated function. The name of the argument designates the name of the upstream asset.

    An asset has an op inside it to represent the function that computes it. The name of the op
    will be the segments of the asset key, separated by double-underscores.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the asset.  If not provided, defaults to the name of the
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, the asset’s key is the
      - <strong>ins</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetIn*](#dagster.AssetIn)<em>]</em><em>]</em>) – A dictionary that maps input names to information
      - <strong>deps</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>Union</em><em>[</em>[*AssetDep*](#dagster.AssetDep)<em>, </em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*SourceAsset*](#dagster.SourceAsset)<em>, </em>[*AssetKey*](#dagster.AssetKey)<em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – The assets that are upstream dependencies, but do not correspond to a parameter of the
      - <strong>config_schema</strong> (<em>Optional</em><em>[</em>[*ConfigSchema*](config.mdx#dagster.ConfigSchema)) – The configuration schema for the asset’s underlying
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dict of metadata entries for the asset.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Tags for filtering and organizing. These tags are not
      - <strong>required_resource_keys</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – Set of resource handles required by the op.
      - <strong>io_manager_key</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The resource key of the IOManager used
      - <strong>io_manager_def</strong> (<em>Optional</em><em>[</em><em>object</em><em>]</em>) – <span className="flag flag-warning">experimental</span>
      - <strong>dagster_type</strong> (<em>Optional</em><em>[</em>[*DagsterType*](types.mdx#dagster.DagsterType)<em>]</em>) – Allows specifying type validation functions that
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that
      - <strong>op_tags</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dictionary of tags for the op that computes the asset.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. If not provided,
      - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – <span className="flag flag-warning">experimental</span>
      - <strong>output_required</strong> (<em>bool</em>) – Whether the decorated function will always materialize an asset.
      - <strong>automation_condition</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – A condition describing when Dagster should materialize this asset.
      - <strong>backfill_policy</strong> ([*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)) – <span className="flag flag-warning">experimental</span>
      - <strong>retry_policy</strong> (<em>Optional</em><em>[</em>[*RetryPolicy*](ops.mdx#dagster.RetryPolicy)<em>]</em>) – The retry policy for the op that computes the asset.
      - <strong>code_version</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Version of the code that generates this asset. In
      - <strong>check_specs</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetCheckSpec*](asset-checks.mdx#dagster.AssetCheckSpec)<em>]</em><em>]</em>) – Specs for asset checks that
      - <strong>key</strong> (<em>Optional</em><em>[</em><em>CoeercibleToAssetKey</em><em>]</em>) – The key for this asset. If provided, cannot specify key_prefix or name.
      - <strong>owners</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – <span className="flag flag-warning">experimental</span><cite>team:</cite>,
      - <strong>kinds</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A list of strings representing the kinds of the asset. These
      - <strong>pool</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string that identifies the concurrency pool that governs this asset’s execution.
      - <strong>non_argument_deps</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Set</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>, </em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – <span className="flag flag-danger">deprecated</span><cite>deps</cite> instead.) Deprecated, use deps instead.


    Examples:

        ```python
        @asset
        def my_upstream_asset() -> int:
            return 5

        @asset
        def my_asset(my_upstream_asset: int) -> int:
            return my_upstream_asset + 1

        should_materialize = True

        @asset(output_required=False)
        def conditional_asset():
            if should_materialize:
                yield Output(5)  # you must `yield`, not `return`, the result

        # Will also only materialize if `should_materialize` is `True`
        @asset
        def downstream_asset(conditional_asset):
            return conditional_asset + 1
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.MaterializeResult'>class dagster.MaterializeResult</Link></dt>
    <dd>

    An object representing a successful materialization of an asset. These can be returned from
    @asset and @multi_asset decorated functions to pass metadata or specify specific assets were
    materialized.

    <dl>
        <dt><Link id='dagster.MaterializeResult.asset_key'>asset_key</Link></dt>
        <dd>

        Optional in @asset, required in @multi_asset to discern which asset this refers to.

        Type: Optional[[AssetKey](#dagster.AssetKey)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.MaterializeResult.metadata'>metadata</Link></dt>
        <dd>

        Metadata to record with the corresponding AssetMaterialization event.

        Type: Optional[RawMetadataMapping]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.MaterializeResult.check_results'>check_results</Link></dt>
        <dd>

        Check results to record with the
        corresponding AssetMaterialization event.

        Type: Optional[Sequence[[AssetCheckResult](asset-checks.mdx#dagster.AssetCheckResult)]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.MaterializeResult.data_version'>data_version</Link></dt>
        <dd>

        The data version of the asset that was observed.

        Type: Optional[DataVersion]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.MaterializeResult.tags'>tags</Link></dt>
        <dd>

        Tags to record with the corresponding
        AssetMaterialization event.

        Type: Optional[Mapping[str, str]]

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetSpec'>class dagster.AssetSpec</Link></dt>
    <dd>

    Specifies the core attributes of an asset, except for the function that materializes or
    observes it.

    An asset spec plus any materialization or observation function for the asset constitutes an
    “asset definition”.

    <dl>
        <dt><Link id='dagster.AssetSpec.key'>key</Link></dt>
        <dd>

        The unique identifier for this asset.

        Type: [AssetKey](#dagster.AssetKey)

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.deps'>deps</Link></dt>
        <dd>

        The asset keys for the upstream assets that
        materializing this asset depends on.

        Type: Optional[AbstractSet[[AssetKey](#dagster.AssetKey)]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.description'>description</Link></dt>
        <dd>

        Human-readable description of this asset.

        Type: Optional[str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.metadata'>metadata</Link></dt>
        <dd>

        A dict of static metadata for this asset.
        For example, users can provide information about the database table this
        asset corresponds to.

        Type: Optional[Dict[str, Any]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.skippable'>skippable</Link></dt>
        <dd>

        Whether this asset can be omitted during materialization, causing downstream
        dependencies to skip.

        Type: bool

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.group_name'>group_name</Link></dt>
        <dd>

        A string name used to organize multiple assets into groups. If
        not provided, the name “default” is used.

        Type: Optional[str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.code_version'>code_version</Link></dt>
        <dd>

        The version of the code for this specific asset,
        overriding the code version of the materialization function

        Type: Optional[str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.backfill_policy'>backfill_policy</Link></dt>
        <dd>

        BackfillPolicy to apply to the specified asset.

        Type: Optional[[BackfillPolicy](partitions.mdx#dagster.BackfillPolicy)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.owners'>owners</Link></dt>
        <dd>

        A list of strings representing owners of the asset. Each
        string can be a user’s email address, or a team name prefixed with <cite>team:</cite>,
        e.g. <cite>team:finops</cite>.

        Type: Optional[Sequence[str]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.tags'>tags</Link></dt>
        <dd>

        Tags for filtering and organizing. These tags are not
        attached to runs of the asset.

        Type: Optional[Mapping[str, str]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.kinds'>kinds</Link></dt>
        <dd>
        (Optional[Set[str]]): A list of strings representing the kinds of the asset. These
        will be made visible in the Dagster UI.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.partitions_def'>partitions_def</Link></dt>
        <dd>

        Defines the set of partition keys that
        compose the asset.

        Type: Optional[[PartitionsDefinition](partitions.mdx#dagster.PartitionsDefinition)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.merge_attributes'>merge_attributes</Link></dt>
        <dd>

        Returns a new AssetSpec with the specified attributes merged with the current attributes.

        Parameters: 
          - <strong>deps</strong> (<em>Optional</em><em>[</em><em>Iterable</em><em>[</em><em>CoercibleToAssetDep</em><em>]</em><em>]</em>) – A set of asset dependencies to add to
          - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A set of metadata to add to the asset self.
          - <strong>owners</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A set of owners to add to the asset self.
          - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – A set of tags to add to the asset self.
          - <strong>kinds</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A set of kinds to add to the asset self.


        Returns: AssetSpec

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.replace_attributes'>replace_attributes</Link></dt>
        <dd>
        Returns a new AssetSpec with the specified attributes replaced.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSpec.with_io_manager_key'>with_io_manager_key</Link></dt>
        <dd>

        Returns a copy of this AssetSpec with an extra metadata value that dictates which I/O
        manager to use to load the contents of this asset in downstream computations.

        Parameters: <strong>io_manager_key</strong> (<em>str</em>) – The I/O manager key. This will be used as the value for the
        “dagster/io_manager_key” metadata key.Returns: AssetSpec

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetsDefinition'>class dagster.AssetsDefinition</Link></dt>
    <dd>

    Defines a set of assets that are produced by the same op or graph.

    AssetsDefinitions are typically not instantiated directly, but rather produced using the
    [`@asset`](#dagster.asset) or [`@multi_asset`](#dagster.multi_asset) decorators.

    <dl>
        <dt><Link id='dagster.AssetsDefinition.from_graph'>static from_graph</Link></dt>
        <dd>

        Constructs an AssetsDefinition from a GraphDefinition.

        Parameters: 
          - <strong>graph_def</strong> ([*GraphDefinition*](graphs.mdx#dagster.GraphDefinition)) – The GraphDefinition that is an asset.
          - <strong>keys_by_input_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – A mapping of the input
          - <strong>keys_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – A mapping of the output
          - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, key_prefix will be prepended
          - <strong>internal_asset_deps</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Set</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em><em>]</em>) – By default, it is assumed
          - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that
          - <strong>partition_mappings</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*PartitionMapping*](partitions.mdx#dagster.PartitionMapping)<em>]</em><em>]</em>) – Defines how to map partition
          - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*ResourceDefinition*](resources.mdx#dagster.ResourceDefinition)<em>]</em><em>]</em>) – <span className="flag flag-warning">experimental</span>
          - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A group name for the constructed asset. Assets without a
          - <strong>group_names_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Defines a group name to be
          - <strong>descriptions_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Defines a description to be
          - <strong>metadata_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>RawMetadataMapping</em><em>]</em><em>]</em><em>]</em>) – Defines metadata to
          - <strong>tags_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em><em>]</em>) – Defines
          - <strong>freshness_policies_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em><em>]</em><em>]</em>) – Defines a
          - <strong>automation_conditions_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em><em>]</em><em>]</em>) – Defines an
          - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – Defines this asset’s BackfillPolicy
          - <strong>owners_by_key</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Defines



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.from_op'>static from_op</Link></dt>
        <dd>

        Constructs an AssetsDefinition from an OpDefinition.

        Parameters: 
          - <strong>op_def</strong> ([*OpDefinition*](ops.mdx#dagster.OpDefinition)) – The OpDefinition that is an asset.
          - <strong>keys_by_input_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – A mapping of the input
          - <strong>keys_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em>) – A mapping of the output
          - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, key_prefix will be prepended
          - <strong>internal_asset_deps</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Set</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em><em>]</em>) – By default, it is assumed
          - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that
          - <strong>partition_mappings</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*PartitionMapping*](partitions.mdx#dagster.PartitionMapping)<em>]</em><em>]</em>) – Defines how to map partition
          - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A group name for the constructed asset. Assets without a
          - <strong>group_names_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Defines a group name to be
          - <strong>descriptions_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Defines a description to be
          - <strong>metadata_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>RawMetadataMapping</em><em>]</em><em>]</em><em>]</em>) – Defines metadata to
          - <strong>tags_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em><em>]</em><em>]</em>) – Defines
          - <strong>freshness_policies_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em><em>]</em><em>]</em>) – Defines a
          - <strong>automation_conditions_by_output_name</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em><em>]</em><em>]</em>) – Defines an
          - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – Defines this asset’s BackfillPolicy



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.get_asset_spec'>get_asset_spec</Link></dt>
        <dd>

        Returns a representation of this asset as an [`AssetSpec`](#dagster.AssetSpec).

        If this is a multi-asset, the “key” argument allows selecting which asset to return the
        spec for.

        Parameters: <strong>key</strong> (<em>Optional</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em>) – If this is a multi-asset, select which asset to return its
        AssetSpec. If not a multi-asset, this can be left as None.Returns: AssetSpec

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.get_partition_mapping'>get_partition_mapping</Link></dt>
        <dd>
        Returns the partition mapping between keys in this AssetsDefinition and a given input
        asset key (if any).
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.to_source_asset'>to_source_asset</Link></dt>
        <dd>

        Returns a representation of this asset as a [`SourceAsset`](#dagster.SourceAsset).

        If this is a multi-asset, the “key” argument allows selecting which asset to return a
        SourceAsset representation of.

        Parameters: <strong>key</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em><em>]</em>) – If this is a multi-asset, select
        which asset to return a SourceAsset representation of. If not a multi-asset, this
        can be left as None.Returns: SourceAsset

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.to_source_assets'>to_source_assets</Link></dt>
        <dd>

        Returns a SourceAsset for each asset in this definition.

        Each produced SourceAsset will have the same key, metadata, io_manager_key, etc. as the
        corresponding asset


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.asset_deps'>property asset_deps</Link></dt>
        <dd>
        Maps assets that are produced by this definition to assets that they depend on. The
        dependencies can be either “internal”, meaning that they refer to other assets that are
        produced by this definition, or “external”, meaning that they refer to assets that aren’t
        produced by this definition.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.can_subset'>property can_subset</Link></dt>
        <dd>

        If True, indicates that this AssetsDefinition may materialize any subset of its
        asset keys in a given computation (as opposed to being required to materialize all asset
        keys).

        Type: bool

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.check_specs'>property check_specs</Link></dt>
        <dd>

        Returns the asset check specs defined on this AssetsDefinition, i.e. the checks that can
        be executed while materializing the assets.

        Return type: Iterable[AssetsCheckSpec]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.dependency_keys'>property dependency_keys</Link></dt>
        <dd>

        The asset keys which are upstream of any asset included in this
        AssetsDefinition.

        Type: Iterable[[AssetKey](#dagster.AssetKey)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.descriptions_by_key'>property descriptions_by_key</Link></dt>
        <dd>

        Returns a mapping from the asset keys in this AssetsDefinition
        to the descriptions assigned to them. If there is no assigned description for a given AssetKey,
        it will not be present in this dictionary.

        Type: Mapping[[AssetKey](#dagster.AssetKey), str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.group_names_by_key'>property group_names_by_key</Link></dt>
        <dd>

        Returns a mapping from the asset keys in this AssetsDefinition
        to the group names assigned to them. If there is no assigned group name for a given AssetKey,
        it will not be present in this dictionary.

        Type: Mapping[[AssetKey](#dagster.AssetKey), str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.key'>property key</Link></dt>
        <dd>

        The asset key associated with this AssetsDefinition. If this AssetsDefinition
        has more than one asset key, this will produce an error.

        Type: [AssetKey](#dagster.AssetKey)

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.keys'>property keys</Link></dt>
        <dd>

        The asset keys associated with this AssetsDefinition.

        Type: AbstractSet[[AssetKey](#dagster.AssetKey)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.node_def'>property node_def</Link></dt>
        <dd>

        Returns the OpDefinition or GraphDefinition that is used to materialize
        the assets in this AssetsDefinition.

        Type: NodeDefinition

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.op'>property op</Link></dt>
        <dd>

        Returns the OpDefinition that is used to materialize the assets in this
        AssetsDefinition.

        Type: [OpDefinition](ops.mdx#dagster.OpDefinition)

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.partitions_def'>property partitions_def</Link></dt>
        <dd>

        The PartitionsDefinition for this AssetsDefinition (if any).

        Type: Optional[[PartitionsDefinition](partitions.mdx#dagster.PartitionsDefinition)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.required_resource_keys'>property required_resource_keys</Link></dt>
        <dd>

        The set of keys for resources that must be provided to this AssetsDefinition.

        Type: Set[str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetsDefinition.resource_defs'>property resource_defs</Link></dt>
        <dd>

        A mapping from resource name to ResourceDefinition for
        the resources bound to this AssetsDefinition.

        Type: Mapping[str, [ResourceDefinition](resources.mdx#dagster.ResourceDefinition)]

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetKey'>class dagster.AssetKey</Link></dt>
    <dd>

    Object representing the structure of an asset key.  Takes in a sanitized string, list of
    strings, or tuple of strings.

    Example usage:

        ```python
        from dagster import AssetKey

        AssetKey("asset1")
        AssetKey(["asset1"]) # same as the above
        AssetKey(["prefix", "asset1"])
        AssetKey(["prefix", "subprefix", "asset1"])
        ```
    Parameters: <strong>path</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – String, list of strings, or tuple of strings.  A list of
    strings represent the hierarchical structure of the asset_key.
    <dl>
        <dt><Link id='dagster.AssetKey.path'>property path</Link></dt>
        <dd>

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.map_asset_specs'>dagster.map_asset_specs</Link></dt>
    <dd>

    Map a function over a sequence of AssetSpecs or AssetsDefinitions, replacing specs in the sequence
    or specs in an AssetsDefinitions with the result of the function.

    Parameters: 
      - <strong>func</strong> (<em>Callable</em><em>[</em><em>[</em>[*AssetSpec*](#dagster.AssetSpec)<em>]</em><em>, </em>[*AssetSpec*](#dagster.AssetSpec)<em>]</em>) – The function to apply to each AssetSpec.
      - <strong>iterable</strong> (<em>Iterable</em><em>[</em><em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*AssetSpec*](#dagster.AssetSpec)<em>]</em><em>]</em>) – The sequence of AssetSpecs or AssetsDefinitions.


    Returns: 
    A sequence of AssetSpecs or AssetsDefinitions with the function applied
        to each spec.

    Return type: Sequence[Union[[AssetsDefinition](#dagster.AssetsDefinition), [AssetSpec](#dagster.AssetSpec)]]
    Examples:

        ```python
        from dagster import AssetSpec, map_asset_specs

        asset_specs = [
            AssetSpec(key="my_asset"),
            AssetSpec(key="my_asset_2"),
        ]

        mapped_specs = map_asset_specs(lambda spec: spec.replace_attributes(owners=["nelson@hooli.com"]), asset_specs)
        ```

    </dd>

</dl>
</div>


<div class="section" id="graph-backed-asset-definitions">


## Graph-backed asset definitions

Refer to the [Graph-backed asset](https://docs.dagster.io/concepts/assets/graph-backed-assets) documentation for more information.

<dl>
    <dt><Link id='dagster.graph_asset'>@dagster.graph_asset</Link></dt>
    <dd>

    Creates a software-defined asset that’s computed using a graph of ops.

    This decorator is meant to decorate a function that composes a set of ops or graphs to define
    the dependencies between them.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the asset.  If not provided, defaults to the name of the
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A human-readable description of the asset.
      - <strong>ins</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetIn*](#dagster.AssetIn)<em>]</em><em>]</em>) – A dictionary that maps input names to information
      - <strong>config</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em>[*ConfigMapping*](config.mdx#dagster.ConfigMapping)<em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – 

        Describes how the graph underlying the asset is configured at runtime.

        If a [`ConfigMapping`](config.mdx#dagster.ConfigMapping) object is provided, then the graph takes on the config
        schema of this object. The mapping will be applied at runtime to generate the config for
        the graph’s constituent nodes.

        If a dictionary is provided, then it will be used as the default run config for the
        graph. This means it must conform to the config schema of the underlying nodes. Note
        that the values provided will be viewable and editable in the Dagster UI, so be careful
        with secrets.

      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, the asset’s key is the
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. If
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>RawMetadataMapping</em><em>]</em>) – Dictionary of metadata to be associated with
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – (Experimental) Tags for filtering and organizing. These tags are not
      - <strong>owners</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em>) – <span className="flag flag-warning">experimental</span><cite>team:</cite>,
      - <strong>kinds</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – A list of strings representing the kinds of the asset. These
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – The AutomationCondition to use
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – The BackfillPolicy to use for this asset.
      - <strong>code_version</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Version of the code that generates this asset. In
      - <strong>key</strong> (<em>Optional</em><em>[</em><em>CoeercibleToAssetKey</em><em>]</em>) – The key for this asset. If provided, cannot specify key_prefix or name.


    Examples:

        ```python
        @op
        def fetch_files_from_slack(context) -> pd.DataFrame:
            ...

        @op
        def store_files(files) -> None:
            files.to_sql(name="slack_files", con=create_db_connection())

        @graph_asset
        def slack_files_table():
            return store_files(fetch_files_from_slack())
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.graph_multi_asset'>@dagster.graph_multi_asset</Link></dt>
    <dd>

    Create a combined definition of multiple assets that are computed using the same graph of
    ops, and the same upstream assets.

    Each argument to the decorated function references an upstream asset that this asset depends on.
    The name of the argument designates the name of the upstream asset.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the graph.
      - <strong>outs</strong> – (Optional[Dict[str, AssetOut]]): The AssetOuts representing the produced assets.
      - <strong>ins</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetIn*](#dagster.AssetIn)<em>]</em><em>]</em>) – A dictionary that maps input names to information
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – The backfill policy for the asset.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. This
      - <strong>can_subset</strong> (<em>bool</em>) – Whether this asset’s computation can emit a subset of the asset
      - <strong>config</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em>[*ConfigMapping*](config.mdx#dagster.ConfigMapping)<em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – 

        Describes how the graph underlying the asset is configured at runtime.

        If a [`ConfigMapping`](config.mdx#dagster.ConfigMapping) object is provided, then the graph takes on the config
        schema of this object. The mapping will be applied at runtime to generate the config for
        the graph’s constituent nodes.

        If a dictionary is provided, then it will be used as the default run config for the
        graph. This means it must conform to the config schema of the underlying nodes. Note
        that the values provided will be viewable and editable in the Dagster UI, so be careful
        with secrets.

        If no value is provided, then the config schema for the graph is the default (derived



    </dd>

</dl>
</div>


<div class="section" id="multi-asset-definitions">


## Multi-asset definitions

Refer to the [Multi-asset](https://docs.dagster.io/concepts/assets/multi-assets) documentation for more information.

<dl>
    <dt><Link id='dagster.multi_asset'>@dagster.multi_asset</Link></dt>
    <dd>

    Create a combined definition of multiple assets that are computed using the same op and same
    upstream assets.

    Each argument to the decorated function references an upstream asset that this asset depends on.
    The name of the argument designates the name of the upstream asset.

    You can set I/O managers keys, auto-materialize policies, freshness policies, group names, etc.
    on an individual asset within the multi-asset by attaching them to the [`AssetOut`](#dagster.AssetOut)
    corresponding to that asset in the <cite>outs</cite> parameter.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the op.
      - <strong>outs</strong> – (Optional[Dict[str, AssetOut]]): The AssetOuts representing the assets materialized by
      - <strong>ins</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*AssetIn*](#dagster.AssetIn)<em>]</em><em>]</em>) – A dictionary that maps input names to information
      - <strong>deps</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em><em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*SourceAsset*](#dagster.SourceAsset)<em>, </em>[*AssetKey*](#dagster.AssetKey)<em>, </em><em>str</em><em>]</em><em>]</em><em>]</em>) – The assets that are upstream dependencies, but do not correspond to a parameter of the
      - <strong>config_schema</strong> (<em>Optional</em><em>[</em>[*ConfigSchema*](config.mdx#dagster.ConfigSchema)) – The configuration schema for the asset’s underlying
      - <strong>required_resource_keys</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – Set of resource handles required by the underlying op.
      - <strong>internal_asset_deps</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Set</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>]</em><em>]</em>) – By default, it is assumed
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – The backfill policy for the op that computes the asset.
      - <strong>op_tags</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dictionary of tags for the op that computes the asset.
      - <strong>can_subset</strong> (<em>bool</em>) – If this asset’s computation can emit a subset of the asset
      - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – <span className="flag flag-warning">experimental</span>
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. This
      - <strong>retry_policy</strong> (<em>Optional</em><em>[</em>[*RetryPolicy*](ops.mdx#dagster.RetryPolicy)<em>]</em>) – The retry policy for the op that computes the asset.
      - <strong>code_version</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Version of the code encapsulated by the multi-asset. If set,
      - <strong>specs</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetSpec*](#dagster.AssetSpec)<em>]</em><em>]</em>) – The specifications for the assets materialized
      - <strong>check_specs</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetCheckSpec*](asset-checks.mdx#dagster.AssetCheckSpec)<em>]</em><em>]</em>) – Specs for asset checks that
      - <strong>pool</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string that identifies the concurrency pool that governs this
      - <strong>non_argument_deps</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Set</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>, </em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – <span className="flag flag-danger">deprecated</span><cite>deps</cite> instead.) Deprecated, use deps instead.


    Examples:

        ```python
        @multi_asset(
            specs=[
                AssetSpec("asset1", deps=["asset0"]),
                AssetSpec("asset2", deps=["asset0"]),
            ]
        )
        def my_function():
            asset0_value = load(path="asset0")
            asset1_result, asset2_result = do_some_transformation(asset0_value)
            write(asset1_result, path="asset1")
            write(asset2_result, path="asset2")

        # Or use IO managers to handle I/O:
        @multi_asset(
            outs=\{
                "asset1": AssetOut(),
                "asset2": AssetOut(),
            }
        )
        def my_function(asset0):
            asset1_value = do_some_transformation(asset0)
            asset2_value = do_some_other_transformation(asset0)
            return asset1_value, asset2_value
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.multi_observable_source_asset'>@dagster.multi_observable_source_asset</Link></dt>
    <dd>

        :::warning[experimental]
        This API may break in future versions, even between dot releases.


        :::

    Defines a set of assets that can be observed together with the same function.

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the op.
      - <strong>required_resource_keys</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – Set of resource handles required by the
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that
      - <strong>can_subset</strong> (<em>bool</em>) – If this asset’s computation can emit a subset of the asset
      - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – (Experimental) A mapping of resource keys to resources. These resources
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. This
      - <strong>specs</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetSpec*](#dagster.AssetSpec)<em>]</em><em>]</em>) – (Experimental) The specifications for the assets
      - <strong>check_specs</strong> (<em>Optional</em><em>[</em><em>Sequence</em><em>[</em>[*AssetCheckSpec*](asset-checks.mdx#dagster.AssetCheckSpec)<em>]</em><em>]</em>) – (Experimental) Specs for asset checks that


    Examples:

        ```python
        @multi_observable_source_asset(
            specs=[AssetSpec("asset1"), AssetSpec("asset2")],
        )
        def my_function():
            yield ObserveResult(asset_key="asset1", metadata=\{"foo": "bar"})
            yield ObserveResult(asset_key="asset2", metadata=\{"baz": "qux"})
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetOut'>class dagster.AssetOut</Link></dt>
    <dd>

    Defines one of the assets produced by a [`@multi_asset`](#dagster.multi_asset).

    <dl>
        <dt><Link id='dagster.AssetOut.from_spec'>static from_spec</Link></dt>
        <dd>

        Builds an AssetOut from the passed spec.

        Parameters: 
          - <strong>spec</strong> ([*AssetSpec*](#dagster.AssetSpec)) – The spec to build the AssetOut from.
          - <strong>dagster_type</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Type</em><em>, </em>[*DagsterType*](types.mdx#dagster.DagsterType)<em>]</em><em>]</em>) – The type of this output. Should only
          - <strong>is_required</strong> (<em>bool</em>) – Whether the presence of this field is required. (default: True)
          - <strong>io_manager_key</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The resource key of the IO manager used for this output.
          - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em>[*BackfillPolicy*](partitions.mdx#dagster.BackfillPolicy)<em>]</em>) – BackfillPolicy to apply to the specified


        Returns: The AssetOut built from the spec.Return type: [AssetOut](#dagster.AssetOut)

        </dd>

    </dl>

    </dd>

</dl>
</div>


<div class="section" id="source-assets">


## Source assets

Refer to the [External asset dependencies](https://docs.dagster.io/concepts/assets/software-defined-assets#defining-external-asset-dependencies) documentation for more information.

<dl>
    <dt><Link id='dagster.SourceAsset'>class dagster.SourceAsset</Link></dt>
    <dd>

        :::danger[deprecated]
        This API will be removed in version 2.0.0.
         Use AssetSpec instead. If using the SourceAsset io_manager_key property, use AssetSpec(...).with_io_manager_key(...)..

        :::

    A SourceAsset represents an asset that will be loaded by (but not updated by) Dagster.

    <dl>
        <dt><Link id='dagster.SourceAsset.key'>key</Link></dt>
        <dd>

        The key of the asset.

        Type: Union[[AssetKey](#dagster.AssetKey), Sequence[str], str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.metadata'>metadata</Link></dt>
        <dd>

        Metadata associated with the asset.

        Type: Mapping[str, [MetadataValue](metadata.mdx#dagster.MetadataValue)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.io_manager_key'>io_manager_key</Link></dt>
        <dd>

        The key for the IOManager that will be used to load the contents of
        the asset when it’s used as an input to other assets inside a job.

        Type: Optional[str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.io_manager_def'>io_manager_def</Link></dt>
        <dd>

        (Experimental) The definition of the IOManager that will be used to load the contents of
        the asset when it’s used as an input to other assets inside a job.

        Type: Optional[[IOManagerDefinition](io-managers.mdx#dagster.IOManagerDefinition)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.resource_defs'>resource_defs</Link></dt>
        <dd>

        (Experimental) resource definitions that may be required by the [`dagster.IOManagerDefinition`](io-managers.mdx#dagster.IOManagerDefinition) provided in the <cite>io_manager_def</cite> argument.

        Type: Optional[Mapping[str, [ResourceDefinition](resources.mdx#dagster.ResourceDefinition)]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.description'>description</Link></dt>
        <dd>

        The description of the asset.

        Type: Optional[str]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.partitions_def'>partitions_def</Link></dt>
        <dd>

        Defines the set of partition keys that
        compose the asset.

        Type: Optional[[PartitionsDefinition](partitions.mdx#dagster.PartitionsDefinition)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.observe_fn'>observe_fn</Link></dt>
        <dd>

        Type: Optional[SourceAssetObserveFunction]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.op_tags'>op_tags</Link></dt>
        <dd>

        A dictionary of tags for the op that computes the asset.
        Frameworks may expect and require certain metadata to be attached to a op. Values that
        are not strings will be json encoded and must meet the criteria that
        <cite>json.loads(json.dumps(value)) == value</cite>.

        Type: Optional[Dict[str, Any]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.auto_observe_interval_minutes'>auto_observe_interval_minutes</Link></dt>
        <dd>

        While the asset daemon is turned on, a run
        of the observation function for this asset will be launched at this interval. <cite>observe_fn</cite>
        must be provided.

        Type: Optional[float]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.freshness_policy'>freshness_policy</Link></dt>
        <dd>

        A constraint telling Dagster how often this asset is intended to be updated
        with respect to its root data.

        Type: FreshnessPolicy

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.tags'>tags</Link></dt>
        <dd>

        Tags for filtering and organizing. These tags are not
        attached to runs of the asset.

        Type: Optional[Mapping[str, str]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.is_observable'>property is_observable</Link></dt>
        <dd>

        Whether the asset is observable.

        Type: bool

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.SourceAsset.op'>property op</Link></dt>
        <dd>

        The OpDefinition associated with the observation function of an observable
        source asset.

        Throws an error if the asset is not observable.

        Type: [OpDefinition](ops.mdx#dagster.OpDefinition)

        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.observable_source_asset'>@dagster.observable_source_asset</Link></dt>
    <dd>

        :::warning[experimental]
        This API may break in future versions, even between dot releases.


        :::

    Create a <cite>SourceAsset</cite> with an associated observation function.

    The observation function of a source asset is wrapped inside of an op and can be executed as
    part of a job. Each execution generates an <cite>AssetObservation</cite> event associated with the source
    asset. The source asset observation function should return a `DataVersion`,
    a <cite>~dagster.DataVersionsByPartition</cite>, or an [`ObserveResult`](#dagster.ObserveResult).

    Parameters: 
      - <strong>name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of the source asset.  If not provided, defaults to the name of the
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – If provided, the source asset’s key is the
      - <strong>metadata</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>RawMetadataValue</em><em>]</em>) – Metadata associated with the asset.
      - <strong>io_manager_key</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The key for the IOManager that will be used to load the contents of
      - <strong>io_manager_def</strong> (<em>Optional</em><em>[</em>[*IOManagerDefinition*](io-managers.mdx#dagster.IOManagerDefinition)<em>]</em>) – (Experimental) The definition of the IOManager that will be used to load the contents of
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The description of the asset.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string name used to organize multiple assets into groups. If not provided,
      - <strong>required_resource_keys</strong> (<em>Optional</em><em>[</em><em>Set</em><em>[</em><em>str</em><em>]</em><em>]</em>) – Set of resource keys required by the observe op.
      - <strong>resource_defs</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em>[*ResourceDefinition*](resources.mdx#dagster.ResourceDefinition)<em>]</em><em>]</em>) – (Experimental) resource
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – Defines the set of partition keys that
      - <strong>op_tags</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – A dictionary of tags for the op that computes the asset.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – Tags for filtering and organizing. These tags are not
      - <strong>observe_fn</strong> (<em>Optional</em><em>[</em><em>SourceAssetObserveFunction</em><em>]</em>) – Observation function for the source asset.
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – A condition describing when Dagster



    </dd>

</dl>
<dl>
    <dt><Link id='dagster.ObserveResult'>class dagster.ObserveResult</Link></dt>
    <dd>

        :::warning[experimental]
        This API may break in future versions, even between dot releases.


        :::

    An object representing a successful observation of an asset. These can be returned from an
    @observable_source_asset decorated function to pass metadata.

    <dl>
        <dt><Link id='dagster.ObserveResult.asset_key'>asset_key</Link></dt>
        <dd>

        The asset key. Optional to include.

        Type: Optional[[AssetKey](#dagster.AssetKey)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.ObserveResult.metadata'>metadata</Link></dt>
        <dd>

        Metadata to record with the corresponding
        AssetObservation event.

        Type: Optional[RawMetadataMapping]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.ObserveResult.check_results'>check_results</Link></dt>
        <dd>

        Check results to record with the
        corresponding AssetObservation event.

        Type: Optional[Sequence[[AssetCheckResult](asset-checks.mdx#dagster.AssetCheckResult)]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.ObserveResult.data_version'>data_version</Link></dt>
        <dd>

        The data version of the asset that was observed.

        Type: Optional[DataVersion]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.ObserveResult.tags'>tags</Link></dt>
        <dd>

        Tags to record with the corresponding AssetObservation
        event.

        Type: Optional[Mapping[str, str]]

        </dd>

    </dl>

    </dd>

</dl>
</div>


<div class="section" id="dependencies">


## Dependencies

<dl>
    <dt><Link id='dagster.AssetDep'>class dagster.AssetDep</Link></dt>
    <dd>

    Specifies a dependency on an upstream asset.

    <dl>
        <dt><Link id='dagster.AssetDep.asset'>asset</Link></dt>
        <dd>

        The upstream asset to depend on.

        Type: Union[[AssetKey](#dagster.AssetKey), str, [AssetSpec](#dagster.AssetSpec), [AssetsDefinition](#dagster.AssetsDefinition), [SourceAsset](#dagster.SourceAsset)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetDep.partition_mapping'>partition_mapping</Link></dt>
        <dd>

        Defines what partitions to depend on in
        the upstream asset. If not provided and the upstream asset is partitioned, defaults to
        the default partition mapping for the partitions definition, which is typically maps
        partition keys to the same partition keys in upstream assets.

        Type: Optional[[PartitionMapping](partitions.mdx#dagster.PartitionMapping)]

        </dd>

    </dl>
    Examples:

        ```python
        upstream_asset = AssetSpec("upstream_asset")
        downstream_asset = AssetSpec(
            "downstream_asset",
            deps=[
                AssetDep(
                    upstream_asset,
                    partition_mapping=TimeWindowPartitionMapping(start_offset=-1, end_offset=-1)
                )
            ]
        )
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetIn'>class dagster.AssetIn</Link></dt>
    <dd>

    Defines an asset dependency.

    <dl>
        <dt><Link id='dagster.AssetIn.key_prefix'>key_prefix</Link></dt>
        <dd>

        If provided, the asset’s key is the
        concatenation of the key_prefix and the input name. Only one of the “key_prefix” and
        “key” arguments should be provided.

        Type: Optional[Union[str, Sequence[str]]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetIn.key'>key</Link></dt>
        <dd>

        The asset’s key. Only one of the
        “key_prefix” and “key” arguments should be provided.

        Type: Optional[Union[str, Sequence[str], [AssetKey](#dagster.AssetKey)]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetIn.metadata'>metadata</Link></dt>
        <dd>

        A dict of the metadata for the input.
        For example, if you only need a subset of columns from an upstream table, you could
        include that in metadata and the IO manager that loads the upstream table could use the
        metadata to determine which columns to load.

        Type: Optional[Dict[str, Any]]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetIn.partition_mapping'>partition_mapping</Link></dt>
        <dd>

        Defines what partitions to depend on in
        the upstream asset. If not provided, defaults to the default partition mapping for the
        partitions definition, which is typically maps partition keys to the same partition keys
        in upstream assets.

        Type: Optional[[PartitionMapping](partitions.mdx#dagster.PartitionMapping)]

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetIn.dagster_type'>dagster_type</Link></dt>
        <dd>

        Allows specifying type validation functions that
        will be executed on the input of the decorated function before it runs.

        Type: [DagsterType](types.mdx#dagster.DagsterType)

        </dd>

    </dl>

    </dd>

</dl>
</div>


<div class="section" id="asset-jobs">


## Asset jobs

[Asset jobs](https://docs.dagster.io/concepts/assets/asset-jobs) enable the automation of asset materializations.  Dagster’s [asset selection syntax](https://docs.dagster.io/concepts/assets/asset-selection-syntax) can be used to select assets and assign them to a job.

<dl>
    <dt><Link id='dagster.define_asset_job'>dagster.define_asset_job</Link></dt>
    <dd>

    Creates a definition of a job which will either materialize a selection of assets or observe
    a selection of source assets. This will only be resolved to a JobDefinition once placed in a
    code location.

    Parameters: 
      - <strong>name</strong> (<em>str</em>) – The name for the job.
      - <strong>selection</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Sequence</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>, </em><em>Sequence</em><em>[</em><em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*SourceAsset*](#dagster.SourceAsset)<em>]</em><em>]</em><em>, </em>[*AssetSelection*](#dagster.AssetSelection)<em>]</em>) – 

        The assets that will be materialized or observed when the job is run.

        The selected assets must all be included in the assets that are passed to the assets
        argument of the Definitions object that this job is included on.

        The string “my_asset*” selects my_asset and all downstream assets within the code
        location. A list of strings represents the union of all assets selected by strings
        within the list.

      - <strong>config</strong> – 

        Describes how the Job is parameterized at runtime.

        If no value is provided, then the schema for the job’s run config is a standard
        format based on its ops and resources.

        If a dictionary is provided, then it must conform to the standard config schema, and
        it will be used as the job’s run config for the job whenever the job is executed.
        The values provided will be viewable and editable in the Dagster UI, so be
        careful with secrets.

      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – A set of key-value tags that annotate the job and can
      - <strong>run_tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – A set of key-value tags that will be automatically attached to runs launched by this
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>RawMetadataValue</em><em>]</em><em>]</em>) – Arbitrary metadata about the job.
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A description for the Job.
      - <strong>executor_def</strong> (<em>Optional</em><em>[</em>[*ExecutorDefinition*](internals.mdx#dagster.ExecutorDefinition)<em>]</em>) – How this Job will be executed. Defaults to [`multi_or_in_process_executor`](execution.mdx#dagster.multi_or_in_process_executor),
      - <strong>op_retry_policy</strong> (<em>Optional</em><em>[</em>[*RetryPolicy*](ops.mdx#dagster.RetryPolicy)<em>]</em>) – The default retry policy for all ops that compute assets in this job.
      - <strong>partitions_def</strong> (<em>Optional</em><em>[</em>[*PartitionsDefinition*](partitions.mdx#dagster.PartitionsDefinition)<em>]</em>) – <span className="flag flag-danger">deprecated</span>


    Returns: The job, which can be placed inside a code location.Return type: UnresolvedAssetJobDefinition
    Examples:

        ```python
        # A job that targets all assets in the code location:
        @asset
        def asset1():
            ...

        defs = Definitions(
            assets=[asset1],
            jobs=[define_asset_job("all_assets")],
        )

        # A job that targets a single asset
        @asset
        def asset1():
            ...

        defs = Definitions(
            assets=[asset1],
            jobs=[define_asset_job("all_assets", selection=[asset1])],
        )

        # A job that targets all the assets in a group:
        defs = Definitions(
            assets=assets,
            jobs=[define_asset_job("marketing_job", selection=AssetSelection.groups("marketing"))],
        )

        @observable_source_asset
        def source_asset():
            ...

        # A job that observes a source asset:
        defs = Definitions(
            assets=assets,
            jobs=[define_asset_job("observation_job", selection=[source_asset])],
        )

        # Resources are supplied to the assets, not the job:
        @asset(required_resource_keys=\{"slack_client"})
        def asset1():
            ...

        defs = Definitions(
            assets=[asset1],
            jobs=[define_asset_job("all_assets")],
            resources=\{"slack_client": prod_slack_client},
        )
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AssetSelection'>class dagster.AssetSelection</Link></dt>
    <dd>

    An AssetSelection defines a query over a set of assets and asset checks, normally all that are defined in a code location.

    You can use the “|”, “&”, and “-” operators to create unions, intersections, and differences of selections, respectively.

    AssetSelections are typically used with [`define_asset_job()`](#dagster.define_asset_job).

    By default, selecting assets will also select all of the asset checks that target those assets.

    Examples:

        ```python
        # Select all assets in group "marketing":
        AssetSelection.groups("marketing")

        # Select all assets in group "marketing", as well as the asset with key "promotion":
        AssetSelection.groups("marketing") | AssetSelection.assets("promotion")

        # Select all assets in group "marketing" that are downstream of asset "leads":
        AssetSelection.groups("marketing") & AssetSelection.assets("leads").downstream()

        # Select a list of assets:
        AssetSelection.assets(*my_assets_list)

        # Select all assets except for those in group "marketing"
        AssetSelection.all() - AssetSelection.groups("marketing")

        # Select all assets which are materialized by the same op as "projections":
        AssetSelection.assets("projections").required_multi_asset_neighbors()

        # Select all assets in group "marketing" and exclude their asset checks:
        AssetSelection.groups("marketing") - AssetSelection.all_asset_checks()

        # Select all asset checks that target a list of assets:
        AssetSelection.checks_for_assets(*my_assets_list)

        # Select a specific asset check:
        AssetSelection.checks(my_asset_check)
        ```
    <dl>
        <dt><Link id='dagster.AssetSelection.all'>static all</Link></dt>
        <dd>

        Returns a selection that includes all assets and their asset checks.

        Parameters: <strong>include_sources</strong> (<em>bool</em>) – <span className="flag flag-warning">experimental</span>

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.all_asset_checks'>static all_asset_checks</Link></dt>
        <dd>
        Returns a selection that includes all asset checks.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.assets'>static assets</Link></dt>
        <dd>

        Returns a selection that includes all of the provided assets and asset checks that target
        them.

        Parameters: <strong>*assets_defs</strong> (<em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em>) – The assets to
        select.
        Examples:

            ```python
            AssetSelection.assets(AssetKey(["a"]))

            AssetSelection.assets("a")

            AssetSelection.assets(AssetKey(["a"]), AssetKey(["b"]))

            AssetSelection.assets("a", "b")

            @asset
            def asset1():
                ...

            AssetSelection.assets(asset1)

            asset_key_list = [AssetKey(["a"]), AssetKey(["b"])]
            AssetSelection.assets(*asset_key_list)
            ```

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.checks'>static checks</Link></dt>
        <dd>
        Returns a selection that includes all of the provided asset checks or check keys.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.checks_for_assets'>static checks_for_assets</Link></dt>
        <dd>

        Returns a selection with the asset checks that target the provided assets.

        Parameters: <strong>*assets_defs</strong> (<em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em>) – The assets to
        select checks for.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.downstream'>downstream</Link></dt>
        <dd>

        Returns a selection that includes all assets that are downstream of any of the assets in
        this selection, selecting the assets in this selection by default. Includes the asset checks targeting the returned assets. Iterates through each
        asset in this selection and returns the union of all downstream assets.

        depth (Optional[int]): If provided, then only include assets to the given depth. A depth
            of 2 means all assets that are children or grandchildren of the assets in this
            selection.

        include_self (bool): If True, then include the assets in this selection in the result.
            If the include_self flag is False, return each downstream asset that is not part of the
            original selection. By default, set to True.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.groups'>static groups</Link></dt>
        <dd>

        Returns a selection that includes materializable assets that belong to any of the
        provided groups and all the asset checks that target them.

        Parameters: <strong>include_sources</strong> (<em>bool</em>) – If True, then include source assets matching the group in the
        selection.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.key_prefixes'>static key_prefixes</Link></dt>
        <dd>

        Returns a selection that includes assets that match any of the provided key prefixes and all the asset checks that target them.

        Parameters: <strong>include_sources</strong> (<em>bool</em>) – If True, then include source assets matching the key prefix(es)
        in the selection.
        Examples:

            ```python
            # match any asset key where the first segment is equal to "a" or "b"
            # e.g. AssetKey(["a", "b", "c"]) would match, but AssetKey(["abc"]) would not.
            AssetSelection.key_prefixes("a", "b")

            # match any asset key where the first two segments are ["a", "b"] or ["a", "c"]
            AssetSelection.key_prefixes(["a", "b"], ["a", "c"])
            ```

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.keys'>static keys</Link></dt>
        <dd>

            :::danger[deprecated]
            This API will be removed in version 2.0.
             Use AssetSelection.assets instead..

            :::

        Returns a selection that includes assets with any of the provided keys and all asset
        checks that target them.

        Deprecated: use AssetSelection.assets instead.

        Examples:

            ```python
            AssetSelection.keys(AssetKey(["a"]))

            AssetSelection.keys("a")

            AssetSelection.keys(AssetKey(["a"]), AssetKey(["b"]))

            AssetSelection.keys("a", "b")

            asset_key_list = [AssetKey(["a"]), AssetKey(["b"])]
            AssetSelection.keys(*asset_key_list)
            ```

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.materializable'>materializable</Link></dt>
        <dd>
        Given an asset selection, returns a new asset selection that contains all of the assets
        that are materializable. Removes any assets which are not materializable.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.required_multi_asset_neighbors'>required_multi_asset_neighbors</Link></dt>
        <dd>
        Given an asset selection in which some assets are output from a multi-asset compute op
        which cannot be subset, returns a new asset selection that contains all of the assets
        required to execute the original asset selection. Includes the asset checks targeting the returned assets.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.roots'>roots</Link></dt>
        <dd>

        Given an asset selection, returns a new asset selection that contains all of the root
        assets within the original asset selection. Includes the asset checks targeting the returned assets.

        A root asset is an asset that has no upstream dependencies within the asset selection.
        The root asset can have downstream dependencies outside of the asset selection.

        Because mixed selections of source and materializable assets are currently not supported,
        keys corresponding to <cite>SourceAssets</cite> will not be included as roots. To select source assets,
        use the <cite>upstream_source_assets</cite> method.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.sinks'>sinks</Link></dt>
        <dd>

        Given an asset selection, returns a new asset selection that contains all of the sink
        assets within the original asset selection. Includes the asset checks targeting the returned assets.

        A sink asset is an asset that has no downstream dependencies within the asset selection.
        The sink asset can have downstream dependencies outside of the asset selection.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.sources'>sources</Link></dt>
        <dd>

            :::danger[deprecated]
            This API will be removed in version 2.0.
             Use AssetSelection.roots instead..

            :::

        Given an asset selection, returns a new asset selection that contains all of the root
        assets within the original asset selection. Includes the asset checks targeting the returned assets.

        A root asset is a materializable asset that has no upstream dependencies within the asset
        selection. The root asset can have downstream dependencies outside of the asset selection.

        Because mixed selections of source and materializable assets are currently not supported,
        keys corresponding to <cite>SourceAssets</cite> will not be included as roots. To select source assets,
        use the <cite>upstream_source_assets</cite> method.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.tag'>static tag</Link></dt>
        <dd>

            :::warning[experimental]
            This API may break in future versions, even between dot releases.


            :::

        Returns a selection that includes materializable assets that have the provided tag, and
        all the asset checks that target them.

        Parameters: <strong>include_sources</strong> (<em>bool</em>) – If True, then include source assets matching the group in the
        selection.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.upstream'>upstream</Link></dt>
        <dd>

        Returns a selection that includes all materializable assets that are upstream of any of
        the assets in this selection, selecting the assets in this selection by default. Includes
        the asset checks targeting the returned assets. Iterates through each asset in this
        selection and returns the union of all upstream assets.

        Because mixed selections of source and materializable assets are currently not supported,
        keys corresponding to <cite>SourceAssets</cite> will not be included as upstream of regular assets.

        Parameters: 
          - <strong>depth</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – If provided, then only include assets to the given depth. A depth
          - <strong>include_self</strong> (<em>bool</em>) – If True, then include the assets in this selection in the result.



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.upstream_source_assets'>upstream_source_assets</Link></dt>
        <dd>
        Given an asset selection, returns a new asset selection that contains all of the source
        assets that are parents of assets in the original selection. Includes the asset checks
        targeting the returned assets.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AssetSelection.without_checks'>without_checks</Link></dt>
        <dd>
        Removes all asset checks in the selection.
        </dd>

    </dl>

    </dd>

</dl>
</div>


<div class="section" id="code-locations">


## Code locations

Loading assets and asset jobs into a [code location](https://docs.dagster.io/concepts/code-locations) makes them available to Dagster tools like the UI, CLI, and GraphQL API.

<dl>
    <dt><Link id='dagster.load_assets_from_modules'>dagster.load_assets_from_modules</Link></dt>
    <dd>

    Constructs a list of assets and source assets from the given modules.

    Parameters: 
      - <strong>modules</strong> (<em>Iterable</em><em>[</em><em>ModuleType</em><em>]</em>) – The Python modules to look for assets inside.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Group name to apply to the loaded assets. The returned assets will be copies of the
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Prefix to prepend to the keys of the loaded assets. The returned assets will be copies
      - <strong>freshness_policy</strong> (<em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em>) – FreshnessPolicy to apply to all the loaded
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – AutomationCondition to apply
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em><em>AutoMaterializePolicy</em><em>]</em>) – BackfillPolicy to apply to all the loaded assets.
      - <strong>source_key_prefix</strong> (<em>bool</em>) – Prefix to prepend to the keys of loaded SourceAssets. The returned


    Returns: A list containing assets and source assets defined in the given modules.Return type: Sequence[Union[[AssetsDefinition](#dagster.AssetsDefinition), [SourceAsset](#dagster.SourceAsset)]]

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.load_assets_from_current_module'>dagster.load_assets_from_current_module</Link></dt>
    <dd>

    Constructs a list of assets, source assets, and cacheable assets from the module where
    this function is called.

    Parameters: 
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Group name to apply to the loaded assets. The returned assets will be copies of the
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Prefix to prepend to the keys of the loaded assets. The returned assets will be copies
      - <strong>freshness_policy</strong> (<em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em>) – FreshnessPolicy to apply to all the loaded
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – AutomationCondition to apply
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em><em>AutoMaterializePolicy</em><em>]</em>) – BackfillPolicy to apply to all the loaded assets.
      - <strong>source_key_prefix</strong> (<em>bool</em>) – Prefix to prepend to the keys of loaded SourceAssets. The returned


    Returns: A list containing assets, source assets, and cacheable assets defined in the module.Return type: Sequence[Union[[AssetsDefinition](#dagster.AssetsDefinition), [SourceAsset](#dagster.SourceAsset), CachableAssetsDefinition]]

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.load_assets_from_package_module'>dagster.load_assets_from_package_module</Link></dt>
    <dd>

    Constructs a list of assets and source assets that includes all asset
    definitions, source assets, and cacheable assets in all sub-modules of the given package module.

    A package module is the result of importing a package.

    Parameters: 
      - <strong>package_module</strong> (<em>ModuleType</em>) – The package module to looks for assets inside.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Group name to apply to the loaded assets. The returned assets will be copies of the
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Prefix to prepend to the keys of the loaded assets. The returned assets will be copies
      - <strong>freshness_policy</strong> (<em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em>) – FreshnessPolicy to apply to all the loaded
      - <strong>automation_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – AutomationCondition to apply
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em><em>AutoMaterializePolicy</em><em>]</em>) – BackfillPolicy to apply to all the loaded assets.
      - <strong>source_key_prefix</strong> (<em>bool</em>) – Prefix to prepend to the keys of loaded SourceAssets. The returned


    Returns: A list containing assets, source assets, and cacheable assets defined in the module.Return type: Sequence[Union[[AssetsDefinition](#dagster.AssetsDefinition), [SourceAsset](#dagster.SourceAsset), CacheableAssetsDefinition]]

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.load_assets_from_package_name'>dagster.load_assets_from_package_name</Link></dt>
    <dd>

    Constructs a list of assets, source assets, and cacheable assets that includes all asset
    definitions and source assets in all sub-modules of the given package.

    Parameters: 
      - <strong>package_name</strong> (<em>str</em>) – The name of a Python package to look for assets inside.
      - <strong>group_name</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – Group name to apply to the loaded assets. The returned assets will be copies of the
      - <strong>key_prefix</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>]</em><em>]</em>) – Prefix to prepend to the keys of the loaded assets. The returned assets will be copies
      - <strong>freshness_policy</strong> (<em>Optional</em><em>[</em><em>FreshnessPolicy</em><em>]</em>) – FreshnessPolicy to apply to all the loaded
      - <strong>auto_materialize_policy</strong> (<em>Optional</em><em>[</em><em>AutoMaterializePolicy</em><em>]</em>) – AutoMaterializePolicy to apply
      - <strong>backfill_policy</strong> (<em>Optional</em><em>[</em><em>AutoMaterializePolicy</em><em>]</em>) – BackfillPolicy to apply to all the loaded assets.
      - <strong>source_key_prefix</strong> (<em>bool</em>) – Prefix to prepend to the keys of loaded SourceAssets. The returned


    Returns: A list containing assets, source assets, and cacheable assets defined in the module.Return type: Sequence[Union[[AssetsDefinition](#dagster.AssetsDefinition), [SourceAsset](#dagster.SourceAsset), CacheableAssetsDefinition]]

    </dd>

</dl>
</div>


<div class="section" id="observations">


## Observations

Refer to the [Asset observation](https://docs.dagster.io/concepts/assets/asset-observations) documentation for more information.

<dl>
    <dt><Link id='dagster.AssetObservation'>class dagster.AssetObservation</Link></dt>
    <dd>

    Event that captures metadata about an asset at a point in time.

    Parameters: 
      - <strong>asset_key</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>List</em><em>[</em><em>str</em><em>]</em><em>, </em>[*AssetKey*](#dagster.AssetKey)<em>]</em>) – A key to identify the asset.
      - <strong>partition</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The name of a partition of the asset that the metadata
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – A mapping containing tags for the observation.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Union</em><em>[</em><em>str</em><em>, </em><em>float</em><em>, </em><em>int</em><em>, </em>[*MetadataValue*](metadata.mdx#dagster.MetadataValue)<em>]</em><em>]</em><em>]</em>) – Arbitrary metadata about the asset.  Keys are displayed string labels, and values are



    </dd>

</dl>
</div>


<div class="section" id="declarative-automation">


## Declarative Automation

Refer to the [Declarative Automation](https://docs.dagster.io/concepts/automation/declarative-automation) documentation for more information.

<dl>
    <dt><Link id='dagster.AutomationCondition'>class dagster.AutomationCondition</Link></dt>
    <dd>

    An AutomationCondition represents a condition of an asset that impacts whether it should be
    automatically executed. For example, you can have a condition which becomes true whenever the
    code version of the asset is changed, or whenever an upstream dependency is updated.

        ```python
        from dagster import AutomationCondition, asset

        @asset(automation_condition=AutomationCondition.on_cron("0 0 * * *"))
        def my_asset(): ...
        ```
    AutomationConditions may be combined together into expressions using a variety of operators.

        ```python
        from dagster import AssetSelection, AutomationCondition, asset

        # any dependencies from the "important" group are missing
        any_important_deps_missing = AutomationCondition.any_deps_match(
            AutomationCondition.missing(),
        ).allow(AssetSelection.groups("important"))

        # there is a new code version for this asset since the last time it was requested
        new_code_version = AutomationCondition.code_version_changed().since(
            AutomationCondition.newly_requested()
        )

        # there is a new code version and no important dependencies are missing
        my_condition = new_code_version & ~any_important_deps_missing

        @asset(automation_condition=my_condition)
        def my_asset(): ...
        ```
    <dl>
        <dt><Link id='dagster.AutomationCondition.all_checks_match'>static all_checks_match</Link></dt>
        <dd>

        Returns an AutomationCondition that is true for an asset partition if all of its checks
        evaluate to True for the given condition.

        Parameters: 
          - <strong>condition</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – The AutomationCondition that will be evaluated against
          - <strong>blocking_only</strong> (<em>bool</em>) – Determines if this condition will only be evaluated against blocking



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.all_deps_blocking_checks_passed'>static all_deps_blocking_checks_passed</Link></dt>
        <dd>

        Returns an AutomationCondition that is true for any partition where all upstream
        blocking checks have passed, or will be requested on this tick.

        In-tick requests are allowed to enable creating runs that target both a parent with
        blocking checks and a child. Even though the checks have not currently passed, if
        they fail within the run, the run machinery will prevent the child from being
        materialized.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.all_deps_match'>static all_deps_match</Link></dt>
        <dd>

        Returns an AutomationCondition that is true for a if at least one partition
        of the all of the target’s dependencies evaluate to True for the given condition.

        Parameters: <strong>condition</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – The AutomationCondition that will be evaluated against
        this target’s dependencies.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.all_deps_updated_since_cron'>static all_deps_updated_since_cron</Link></dt>
        <dd>
        Returns an AutomatonCondition that is true if all of the target’s dependencies have
        updated since the latest tick of the provided cron schedule.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_checks_match'>static any_checks_match</Link></dt>
        <dd>

        Returns an AutomationCondition that is true for if at least one of the target’s
        checks evaluate to True for the given condition.

        Parameters: 
          - <strong>condition</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – The AutomationCondition that will be evaluated against
          - <strong>blocking_only</strong> (<em>bool</em>) – Determines if this condition will only be evaluated against blocking



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_deps_in_progress'>static any_deps_in_progress</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target has at least one dependency
        that is in progress.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_deps_match'>static any_deps_match</Link></dt>
        <dd>

        Returns an AutomationCondition that is true for a if at least one partition
        of the any of the target’s dependencies evaluate to True for the given condition.

        Parameters: <strong>condition</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – The AutomationCondition that will be evaluated against
        this target’s dependencies.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_deps_missing'>static any_deps_missing</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target has at least one dependency
        that is missing, and will not be requested on this tick.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_deps_updated'>static any_deps_updated</Link></dt>
        <dd>

        Returns an AutomationCondition that is true if the target has at least one dependency
        that has updated since the previous tick, or will be requested on this tick.

        Will ignore parent updates if the run that updated the parent also plans to update
        the asset or check that this condition is applied to.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.any_downstream_conditions'>static any_downstream_conditions</Link></dt>
        <dd>

            :::warning[experimental]
            This API may break in future versions, even between dot releases.


            :::

        Returns an AutomationCondition which represents the union of all distinct downstream conditions.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.asset_matches'>static asset_matches</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if this condition is true for the given key.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.backfill_in_progress'>static backfill_in_progress</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target is part of an in-progress backfill.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.check_failed'>static check_failed</Link></dt>
        <dd>
        Returns an AutomationCondition that is true for an asset check if it has evaluated against
        the latest materialization of an asset and failed.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.check_passed'>static check_passed</Link></dt>
        <dd>
        Returns an AutomationCondition that is true for an asset check if it has evaluated against
        the latest materialization of an asset and passed.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.code_version_changed'>static code_version_changed</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target’s code version has been changed
        since the previous tick.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.cron_tick_passed'>static cron_tick_passed</Link></dt>
        <dd>
        Returns an AutomationCondition that is whenever a cron tick of the provided schedule is passed.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.eager'>static eager</Link></dt>
        <dd>

        Returns an AutomationCondition which will cause a target to be executed if any of
        its dependencies update, and will execute missing partitions if they become missing
        after this condition is applied to the target.

        This will not execute targets that have any missing or in progress dependencies, or
        are currently in progress.

        For time partitioned assets, only the latest time partition will be considered.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.execution_failed'>static execution_failed</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the latest execution of the target failed.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.in_latest_time_window'>static in_latest_time_window</Link></dt>
        <dd>

        Returns an AutomationCondition that is true when the target it is within the latest
        time window.

        Parameters: <strong>lookback_delta</strong> (<em>Optional</em><em>, </em><em>datetime.timedelta</em>) – If provided, the condition will
        return all partitions within the provided delta of the end of the latest time window.
        For example, if this is used on a daily-partitioned asset with a lookback_delta of
        48 hours, this will return the latest two partitions.

        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.in_progress'>static in_progress</Link></dt>
        <dd>
        Returns an AutomationCondition that is true for an asset partition if it is part of an
        in-progress run or backfill.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.initial_evaluation'>static initial_evaluation</Link></dt>
        <dd>
        Returns an AutomationCondition that is true on the first evaluation of the expression.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.missing'>static missing</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target has not been executed.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.newly_missing'>static newly_missing</Link></dt>
        <dd>
        Returns an AutomationCondition that is true on the tick that the target becomes missing.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.newly_requested'>static newly_requested</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target was requested on the previous tick.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.newly_updated'>static newly_updated</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target has been updated since the previous tick.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.on_cron'>static on_cron</Link></dt>
        <dd>

        Returns an AutomationCondition which will cause a target to be executed on a given
        cron schedule, after all of its dependencies have been updated since the latest
        tick of that cron schedule.

        For time partitioned assets, only the latest time partition will be considered.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.on_missing'>static on_missing</Link></dt>
        <dd>

        Returns an AutomationCondition which will execute partitions of the target that
        are added after this condition is applied to the asset.

        This will not execute targets that have any missing dependencies.

        For time partitioned assets, only the latest time partition will be considered.


        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.replace'>replace</Link></dt>
        <dd>

        Replaces all instances of `old` across any sub-conditions with `new`.

        If `old` is a string, then conditions with a label matching
        that string will be replaced.

        Parameters: 
          - <strong>old</strong> (<em>Union</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>, </em><em>str</em><em>]</em>) – The condition to replace.
          - <strong>new</strong> ([*AutomationCondition*](#dagster.AutomationCondition)) – The condition to replace with.



        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.run_in_progress'>static run_in_progress</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target is part of an in-progress run.
        </dd>

    </dl>
    <dl>
        <dt><Link id='dagster.AutomationCondition.will_be_requested'>static will_be_requested</Link></dt>
        <dd>
        Returns an AutomationCondition that is true if the target will be requested this tick.
        </dd>

    </dl>

    </dd>

</dl>
<dl>
    <dt><Link id='dagster.AutomationConditionSensorDefinition'>class dagster.AutomationConditionSensorDefinition</Link></dt>
    <dd>

        :::warning[experimental]
        This API may break in future versions, even between dot releases.


        :::

    Targets a set of assets and repeatedly evaluates all the AutomationConditions on all of
    those assets to determine which to request runs for.

    Parameters: 
      - <strong>name</strong> – The name of the sensor.
      - <strong>target</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Sequence</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>]</em><em>, </em><em>Sequence</em><em>[</em><em>Union</em><em>[</em>[*AssetsDefinition*](#dagster.AssetsDefinition)<em>, </em>[*SourceAsset*](#dagster.SourceAsset)<em>]</em><em>]</em><em>, </em>[*AssetSelection*](#dagster.AssetSelection)<em>]</em>) – A selection of assets to evaluate AutomationConditions of and request runs for.
      - <strong>tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>str</em><em>]</em><em>]</em>) – A set of key-value tags that annotate the sensor and can
      - <strong>run_tags</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – Tags that will be automatically attached to runs launched by this sensor.
      - <strong>metadata</strong> (<em>Optional</em><em>[</em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>object</em><em>]</em><em>]</em>) – A set of metadata entries that annotate the
      - <strong>default_status</strong> (<em>DefaultSensorStatus</em>) – Whether the sensor starts as running or not. The default
      - <strong>minimum_interval_seconds</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The frequency at which to try to evaluate the
      - <strong>description</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A human-readable description of the sensor.
      - <strong>emit_backfills</strong> (<em>bool</em>) – If set to True, will emit a backfill on any tick where more than one partition
      - <strong>use_user_code_server</strong> (<em>bool</em>) – (experimental) If set to True, this sensor will be evaluated in the user
      - <strong>default_condition</strong> (<em>Optional</em><em>[</em>[*AutomationCondition*](#dagster.AutomationCondition)<em>]</em>) – (experimental) If provided, this condition will


    Examples:

        ```python
        import dagster as dg

        # automation condition sensor that defaults to running
        defs1 = dg.Definitions(
            assets=...,
            sensors=[
                dg.AutomationConditionSensorDefinition(
                    name="automation_condition_sensor",
                    target=dg.AssetSelection.all(),
                    default_status=dg.DefaultSensorStatus.RUNNING,
                ),
            ]
        )

        # one automation condition sensor per group
        defs2 = dg.Definitions(
            assets=...,
            sensors=[
                dg.AutomationConditionSensorDefinition(
                    name="raw_data_automation_condition_sensor",
                    target=dg.AssetSelection.groups("raw_data"),
                ),
                dg.AutomationConditionSensorDefinition(
                    name="ml_automation_condition_sensor",
                    target=dg.AssetSelection.groups("machine_learning"),
                ),
            ]
        )
        ```

    </dd>

</dl>
</div>


<div class="section" id="asset-values">

## Asset values

<dl>
    <dt><Link id='dagster.AssetValueLoader'>class dagster.AssetValueLoader</Link></dt>
    <dd>

    Caches resource definitions that are used to load asset values across multiple load
    invocations.

    Should not be instantiated directly. Instead, use
    [`get_asset_value_loader()`](repositories.mdx#dagster.RepositoryDefinition.get_asset_value_loader).

    <dl>
        <dt><Link id='dagster.AssetValueLoader.load_asset_value'>load_asset_value</Link></dt>
        <dd>

        Loads the contents of an asset as a Python object.

        Invokes <cite>load_input</cite> on the [`IOManager`](io-managers.mdx#dagster.IOManager) associated with the asset.

        Parameters: 
          - <strong>asset_key</strong> (<em>Union</em><em>[</em>[*AssetKey*](#dagster.AssetKey)<em>, </em><em>Sequence</em><em>[</em><em>str</em><em>]</em><em>, </em><em>str</em><em>]</em>) – The key of the asset to load.
          - <strong>python_type</strong> (<em>Optional</em><em>[</em><em>Type</em><em>]</em>) – The python type to load the asset as. This is what will
          - <strong>partition_key</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The partition of the asset to load.
          - <strong>input_definition_metadata</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – Input metadata to pass to the [`IOManager`](io-managers.mdx#dagster.IOManager)
          - <strong>resource_config</strong> (<em>Optional</em><em>[</em><em>Any</em><em>]</em>) – A dictionary of resource configurations to be passed


        Returns: The contents of an asset as a Python object.

        </dd>

    </dl>

    </dd>

</dl>
</div></div>
