---
title: 'datahub (dagster-datahub)'
title_meta: 'datahub (dagster-datahub) API Documentation - Build Better Data Pipelines | Python Reference Documentation for Dagster'
description: 'datahub (dagster-datahub) Dagster API | Comprehensive Python API documentation for Dagster, the data orchestration platform. Learn how to build, test, and maintain data pipelines with our detailed guides and examples.'
last_update:
  date: '2025-02-03'
---

<div class="section" id="datahub-dagster-datahub">


# Datahub (dagster-datahub)

This library provides an integration with Datahub, to support pushing metadata to Datahub from
within Dagster ops.

    <div className='lineblock'> </div>

We use the [Datahub Python Library](https://github.com/datahub-project/datahub). To use it, youâ€™ll
first need to start up a Datahub Instance. [Datahub Quickstart Guide](https://datahubproject.io/docs/quickstart).

    <div className='lineblock'> </div>

<dl>
    <dt><Link id='dagster_datahub.DatahubRESTEmitterResource'>dagster_datahub.DatahubRESTEmitterResource ResourceDefinition</Link></dt>
    <dd>

        <div className='lineblock'> </div>

    Base class for Dagster resources that utilize structured config.

    This class is a subclass of both `ResourceDefinition` and `Config`.

    Example definition:

        ```python
        class WriterResource(ConfigurableResource):
            prefix: str

            def output(self, text: str) -> None:
                print(f"{self.prefix}{text}")
        ```
    Example usage:

        ```python
        @asset
        def asset_that_uses_writer(writer: WriterResource):
            writer.output("text")

        defs = Definitions(
            assets=[asset_that_uses_writer],
            resources={"writer": WriterResource(prefix="a_prefix")},
        )
        ```
    You can optionally use this class to model configuration only and vend an object
    of a different type for use at runtime. This is useful for those who wish to
    have a separate object that manages configuration and a separate object at runtime. Or
    where you want to directly use a third-party class that you do not control.

    To do this you override the <cite>create_resource</cite> methods to return a different object.

        ```python
        class WriterResource(ConfigurableResource):
            str: prefix

            def create_resource(self, context: InitResourceContext) -> Writer:
                # Writer is pre-existing class defined else
                return Writer(self.prefix)
        ```
    Example usage:

        ```python
        @asset
        def use_preexisting_writer_as_resource(writer: ResourceParam[Writer]):
            writer.output("text")

        defs = Definitions(
            assets=[use_preexisting_writer_as_resource],
            resources={"writer": WriterResource(prefix="a_prefix")},
        )
        ```

    </dd>

</dl>
<dl>
    <dt><Link id='dagster_datahub.DatahubKafkaEmitterResource'>dagster_datahub.DatahubKafkaEmitterResource ResourceDefinition</Link></dt>
    <dd>

        <div className='lineblock'> </div>

    Base class for Dagster resources that utilize structured config.

    This class is a subclass of both `ResourceDefinition` and `Config`.

    Example definition:

        ```python
        class WriterResource(ConfigurableResource):
            prefix: str

            def output(self, text: str) -> None:
                print(f"{self.prefix}{text}")
        ```
    Example usage:

        ```python
        @asset
        def asset_that_uses_writer(writer: WriterResource):
            writer.output("text")

        defs = Definitions(
            assets=[asset_that_uses_writer],
            resources={"writer": WriterResource(prefix="a_prefix")},
        )
        ```
    You can optionally use this class to model configuration only and vend an object
    of a different type for use at runtime. This is useful for those who wish to
    have a separate object that manages configuration and a separate object at runtime. Or
    where you want to directly use a third-party class that you do not control.

    To do this you override the <cite>create_resource</cite> methods to return a different object.

        ```python
        class WriterResource(ConfigurableResource):
            str: prefix

            def create_resource(self, context: InitResourceContext) -> Writer:
                # Writer is pre-existing class defined else
                return Writer(self.prefix)
        ```
    Example usage:

        ```python
        @asset
        def use_preexisting_writer_as_resource(writer: ResourceParam[Writer]):
            writer.output("text")

        defs = Definitions(
            assets=[use_preexisting_writer_as_resource],
            resources={"writer": WriterResource(prefix="a_prefix")},
        )
        ```

    </dd>

</dl>
<div class="section" id="legacy">

## Legacy

<dl>
    <dt><Link id='dagster_datahub.datahub_rest_emitter'>dagster_datahub.datahub_rest_emitter ResourceDefinition</Link></dt>
    <dd>

        <div className='lineblock'> </div>


    </dd>

</dl>
<dl>
    <dt><Link id='dagster_datahub.datahub_kafka_emitter'>dagster_datahub.datahub_kafka_emitter ResourceDefinition</Link></dt>
    <dd>

        <div className='lineblock'> </div>


    </dd>

</dl>
</div></div>
