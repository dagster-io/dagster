---
title: "Components"
sidebar_position: 80
unlisted: true
displayed_sidebar: 'components'
---
{/* The snippets in this guide are generated by running `make regenerate_cli_snippets` in the root `docs` folder, generated from
    `/examples/docs_beta_snippets/docs_beta_snippets_tests/snippet_checks/guides/components/test_components_docs.py` */}
Welcome to Dagster Components.

Dagster Components is a new way to structure your Dagster projects. It aims to provide:

- An opinionated project layout that supports ongoing scaffolding from "Hello world" to the most advanced projects.
- A class-based interface (`Component`) for dynamically constructing Dagster definitions from arbitrary data (such as third-party integration configuration files).
- A toolkit for buildng YAML DSLs for `Components`, allowing instances of components to be defined with little to no Python code.
- A Dagster-provided set of component types that provide a simplified user experience for common integrations.

## Project Setup

First let's install some tools. The centerpiece of this tutorial is the `dg` command line tool, which lives in the published Python package `dagster-dg`. `dg` is designed to be globally installed and has no dependency on `dagster` itself. `dg` allows us to quickly scaffold Dagster code locations and populate them with components. We will use Python package manager [`uv`](https://docs.astral.sh/uv/) to install a globally available `dg`.

We'll install [`uv`](https://docs.astral.sh/uv/getting-started/installation/) and install two other tools used in this tutorial: [`duckdb`](https://duckdb.org/docs/installation/?version=stable&environment=cli&platform=macos&download_method=package_manager) for a local database, and [`tree`](https://oldmanprogrammer.net/source.php?dir=projects/tree/INSTALL) for visualizing project structure. We will assume we are on a Mac and install using `brew`-- if you are on another platform, follow the preceding links to see the installation instructions. Note that `tree` is strictly optional and is only used to produce an easily understandable representation of the project structure on the CLI. `find`, `ls` or any other directory listing command will also work.

```bash
$ brew install uv duckdb tree
```

Now that we have `uv`, we can install `dg`:

```bash
$ uv tool install dagster-dg
```

`uv tool install` installs python packages from PyPI into isolated environments and exposes their executables on your shell path. This means the `dg` command should now be available. It will always execute in an isolated environment separate from any project environment.

:::note
If you have a local clone of the `dagster` repo, you can install a local version of `dg` with `uv tool install -e $DAGSTER_GIT_REPO_DIR/python_modules/libraries/dagster-dg`. This will create an isolated environment for `dg` just like the standard `uv tool install`, but the environment will contain an editable install of `dagster-dg`.
:::

Let's take a look at the help message for `dg`:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/1-help.txt" language="Bash" />

We want to scaffold a new code location:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/2-scaffold.txt" language="Bash" />


This built a code location at `jaffle-platform` and initialized a new Python
virtual environment inside of it. When using `dg`'s default environment
management behavior, you won't need to worry about activating this virtual environment yourself.

Let's have a look at the scaffolded files:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/3-tree.txt" language="Bash" />


You can see that we have a fairly standard Python project structure. There is a
python package `jaffle_platform`-- the name is an underscored inflection of the
project root directory (`jaffle_platform`). There is also an (empty)
`jaffle_platform_tests` test package, a `pyproject.toml`, and a `uv.lock`. The
`pyproject.toml` contains a `tool.dagster` and `tool.dg` section that look like
this:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/4-pyproject.toml" language="TOML" />


The `tool.dagster` section is not `dg`-specific, it specifies that a set of definitions can be loaded from the `jaffle_platform.definitions` module. The `tool.dg` section contains two settings requiring more explanation.

`is_code_location = true` specifies that this project is a `dg`-managed code location. This is just a regular Dagster code location that has been structured in a particular way. Let's look at the content of `jaffle_platform/definitions.py`:


<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/5-definitions.py" language="Python" />

This call to `build_component_defs` will:

- discover the set of components defined in the project
- compute a set of `Definitions` from each component
- merge the component-specific definitions into a single `Definitions` object

`is_code_location` is telling `dg` that the project is structured in this way and therefore contains component instances. In the current project, component instances will be placed in the default location at `jaffle_platform/components`.

`is_component_lib = true` specifies that the project is a component library.
This means that the project may contain component types that can be referenced
when generating component instances. In a typical code location most components
are likely to be instances of types defined in external libraries (e.g.
`dagster-components`), but it can also be useful to define custom component
types scoped to the project. That is why `is_component_lib` is set to `true` by
default. Any scaffolded component types in `jaffle_platform` will be placed in
the default location at `jaffle_platform/lib`. You can also see that this
module is registered under the `dagster.components` entry point in
`pyproject.toml`. This is what makes the components discoverable to `dg`:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/6-pyproject.toml" language="TOML" />


Now that we've got a basic scaffold, we're ready to start building components. We are going to set up a data platform using Sling to ingest data and DBT to process the data. We'll then automate the daily execution of our pipeline using Dagster automation conditions.

## Ingest

First let's set up Sling. If we query the available component types in our environment, we don't see anything Sling-related:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/7-dg-list-component-types.txt" language="Bash" />

This is because the basic `dagster-components` package (which was installed when we scaffolded our code location) is lightweight and doesn't include components for specific integrations (like Sling). We can get access to a Sling component by installing the `sling` extra of `dagster-components`:

:::note
Recall that `dg` always operates in an isolated environment-- so how is it able to access the set of components types available in our project environment? Under the hood, `dg` attempts to resolve a project root whenever it is run. If it finds a `pyproject.toml` file with a `tool.dg.is_code_location = true` setting, then it will by default expect a `uv`-managed virtual environment to be present in the same directory (this can be confirmed by the presence of a `uv.lock` file). When you run commands like `dg component-type list`, `dg` obtains the results by identifying the in-scope project environment and querying it. In this case, the project environment was set up for us as part of the `dg code-location scaffold` command.
:::

```bash
$ uv add 'dagster-components[sling]'
```

Now let's see what component types are available:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/8-dg-list-component-types.txt" language="Bash" />


Great-- now we can see the `dagster_components.sling_replication` component type. Let's create a new instance of this component:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/9-dg-scaffold-sling-replication.txt" language="Bash" />


This adds a component instance to the project at `jaffle_platform/components/ingest_files`:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/10-tree-jaffle-platform.txt" language="Bash" />


A single file, `component.yaml`, was created in the component folder. The `component.yaml` file is common to all Dagster components, and specifies the component type and any parameters used to scaffold definitions from the component at runtime.

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/11-component.yaml" language="YAML" name="jaffle_platform/components/ingest_files/component.yaml"/>


Right now the parameters define a single "replication"-- this is a sling concept that specifies how data should be replicated from a source to a target. The details are specified in a `replication.yaml` file that is read by Sling. This file does not yet exist-- we are going to create it shortly.

:::note
The `path` parameter for a replication is relative to the same folder containing component.yaml. This is a convention for components.
:::

But first, let's set up DuckDB:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/12-sling-setup-duckdb.txt" language="Bash" />


<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/13-sling-test-duckdb.txt" language="Bash" />


Now let's download some files locally to use our Sling source (Sling doesn't support reading from the public internet):

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/14-curl.txt" language="Bash" />

And finally create `replication.yaml` referencing the downloaded files:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/15-replication.yaml" language="YAML" />

Let's load up our code location in the Dagster UI to see what we've got:

```bash
uv run dagster dev # will be dg dev in the future
```

![](/images/guides/build/projects-and-components/components/sling.png)

Click "Materialize All", and we should now have tables in the DuckDB instance. Let's verify on the command line:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/16-duckdb-select.txt" language="Bash" />


## Transform

We'll now download a pre-existing sample DBT project from github. We're going to use the data we are ingesting with Sling as an input for the DBT project. Clone the project (and delete the embedded git repo):

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/17-jaffle-clone.txt" language="Bash" />

We'll need to create a Dagster DBT project component to interface with the dbt project. We can access the DBT project component by installing `dagster-components[dbt]` and `dbt-duckdb`:

```bash
$ uv add "dagster-components[dbt]" dbt-duckdb
```

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/18-dg-list-component-types.txt" language="Bash" />


There it is: `dagster_components.dbt_project`. We can access detailed info about a component type using the `dg component-type info` command. Let's have a look at the `dagster_components.dbt_project` component type:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/19-dg-component-type-info.txt" language="Bash" />


The output of the above command shows the parameters (in JSON schema format) for both component generation and runtime loading of the component (the runtime parameters have been truncated here due to length).

Let's scaffold a new instance of the `dagster_components.dbt_project` component, providing the path to the dbt project we cloned earlier as the `project_path` scaffold paramater. We can pass this on the command line:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/20-dg-scaffold-jdbt.txt" language="Bash" />

This creates a new component instance in the project at `jaffle_platform/components/jdbt`. Open `component.yaml` and you'll see:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/21-component-jdbt.yaml" language="YAML" />

Let’s see the project in the Dagster UI:

```bash
uv run dagster dev
```

![](/images/guides/build/projects-and-components/components/dbt-1.png)

You can see at first glance that there appear to be two copies of the `raw_customers`, `raw_orders`, and `raw_payments` tables. This isn't right-- if you click on the assets you can see their full asset keys. The keys generated by the DBT component are of the form `main/*` where the keys generated by the Sling component are of the form `target/main/*`. We need to update the configuration of the `dagster_components.dbt_project` component to match the keys generated by the Sling component. Update `components/jdbt/component.yaml` with the below:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/22-project-jdbt.yaml" language="YAML" />


Reload the code location in Dagster UI and now the keys will connect properly:

![](/images/guides/build/projects-and-components/components/dbt-2.png)

Now the keys generated by the Sling and DBT project components match, and our
asset graph is correct. Click "Materialize All" to materialize the new assets
defined via the DBT project component. We can verify that this worked by
viewing a sample of the newly materialized assets from the command line:

<CodeExample path="docs_beta_snippets/docs_beta_snippets/guides/components/index/23-duckdb-select-orders.txt" language="Bash" />


## Automation

Now that we've defined some assets, let automate them to keep them up to date. We can do this via declarative automation directly in our yaml DSL. Navigate to `components/ingest_files/component.yaml` and update with the below:

```yaml create=jaffle_platform/components/ingest_files/component.yaml
type: dagster_components.sling_replication_collection

params:
  replications:
    - path: replication.yaml
  asset_attributes:
    - target: "*"
	    attributes:
        automation_condition: "{{ automation_condition.on_cron('@daily') }}"
        metadata:
          automation_condition: "on_cron(@daily)"
```

This will automatically pull in data with sling each day. Now we want to make
the dbt project execute after our sling replication runs. Update
`components/jdbt/component.yaml` with the below:

```yaml create=jaffle_platform/components/jdbt/component.yaml
type: dagster_components.dbt_project

params:
  dbt:
    project_dir: ../../../dbt/jdbt
  asset_attributes:
    key: "target/main/{{ node.name }}"
  transforms:
    - target: "*"
      attributes:
        automation_condition: "{{ automation_condition.eager() }}"
      metadata:
        automation_condition: "eager"
```

Now the DBT project will update automatically after the Sling replication runs.

---

This concludes the Components tutorial. Components is under heavy development and more documentation is coming soon.
