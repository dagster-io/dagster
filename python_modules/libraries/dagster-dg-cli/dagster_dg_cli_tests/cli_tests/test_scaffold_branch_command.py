import subprocess
from tempfile import TemporaryDirectory
from unittest.mock import Mock, patch

import click
import pytest
from dagster_dg_core.utils import activate_venv
from dagster_dg_core_tests.utils import (
    ProxyRunner,
    assert_runner_result,
    isolated_example_project_foo_bar,
)
from dagster_shared.utils import environ


def test_scaffold_branch_command_success():
    """Test successful branch creation with all steps."""
    with (
        ProxyRunner.test() as runner,
        isolated_example_project_foo_bar(
            runner,
            in_workspace=False,
        ),
        TemporaryDirectory() as temp_dir,
        environ({"DAGSTER_GIT_REPO_DIR": ""}),
    ):
        # Mock the subprocess calls to simulate git and gh commands
        with (
            patch("dagster_dg_cli.cli.scaffold.branch._run_git_command") as mock_git,
            patch("dagster_dg_cli.cli.scaffold.branch._run_gh_command") as mock_gh,
        ):
            # Mock git checkout -b command
            mock_git.return_value = Mock(returncode=0, stdout="", stderr="")

            # Mock gh pr create command
            mock_gh.return_value = Mock(
                returncode=0,
                stdout="https://github.com/user/repo/pull/123",
                stderr="",
            )

            result = runner.invoke("scaffold", "branch", "my-feature-branch", "--record", temp_dir)
            assert_runner_result(result)

            # Verify git commands were called in correct order
            expected_git_calls = [
                (["checkout", "-b", "my-feature-branch"],),
                (["rev-parse", "HEAD"],),
                (["commit", "--allow-empty", "-m", "Initial commit for my-feature-branch branch"],),
                (["push", "-u", "origin", "my-feature-branch"],),
            ]

            actual_git_calls = [call[0] for call in mock_git.call_args_list]
            assert actual_git_calls == expected_git_calls

            # Verify gh command was called correctly
            mock_gh.assert_called_once_with(
                [
                    "pr",
                    "create",
                    "--title",
                    "my-feature-branch",
                    "--body",
                    "This pull request was generated by the Dagster `dg` CLI for branch 'my-feature-branch'.",
                ]
            )

            # Check output messages
            assert "Creating new branch: my-feature-branch" in result.output
            assert "Created and checked out new branch: my-feature-branch" in result.output
            assert (
                "Created empty commit: Initial commit for my-feature-branch branch" in result.output
            )
            assert "Pushed branch my-feature-branch to remote" in result.output
            assert "Created pull request: https://github.com/user/repo/pull/123" in result.output
            assert (
                "‚úÖ Successfully created branch and pull request: https://github.com/user/repo/pull/123"
                in result.output
            )
            assert "üìù Session recorded:" in result.output


def test_scaffold_branch_command_whitespace_branch_name():
    """Test that branch name is properly stripped of whitespace."""
    with (
        ProxyRunner.test() as runner,
        isolated_example_project_foo_bar(
            runner,
            in_workspace=False,
        ),
    ):
        with (
            patch("dagster_dg_cli.cli.scaffold.branch._run_git_command") as mock_git,
            patch("dagster_dg_cli.cli.scaffold.branch._run_gh_command") as mock_gh,
        ):
            mock_git.return_value = Mock(returncode=0, stdout="", stderr="")
            mock_gh.return_value = Mock(
                returncode=0,
                stdout="https://github.com/user/repo/pull/123",
                stderr="",
            )

            result = runner.invoke("scaffold", "branch", "  my-branch  ")
            assert_runner_result(result)

            # Verify the stripped branch name was used
            first_git_call = mock_git.call_args_list[0][0][0]
            assert first_git_call == ["checkout", "-b", "my-branch"]


def test_run_git_command_git_not_found():
    """Test _run_git_command when git is not installed."""
    from dagster_dg_cli.cli.scaffold.branch import _run_git_command

    with patch("subprocess.run", side_effect=FileNotFoundError):
        with pytest.raises(click.ClickException, match="git command not found"):
            _run_git_command(["status"])


def test_run_gh_command_gh_not_found():
    """Test _run_gh_command when gh is not installed."""
    from dagster_dg_cli.cli.scaffold.branch import _run_gh_command

    with patch("subprocess.run", side_effect=FileNotFoundError):
        with pytest.raises(click.ClickException, match="gh command not found"):
            _run_gh_command(["pr", "list"])


def test_run_gh_command_command_fails():
    """Test _run_gh_command when gh command fails."""
    from dagster_dg_cli.cli.scaffold.branch import _run_gh_command

    with patch("subprocess.run") as mock_run:
        error = subprocess.CalledProcessError(1, "gh pr create")
        error.stderr = "error: not authenticated with GitHub"
        error.stdout = ""
        mock_run.side_effect = error

        with pytest.raises(
            click.ClickException, match="gh command failed: error: not authenticated with GitHub"
        ):
            _run_gh_command(["pr", "create"])


def test_scaffold_branch_command_ai_inference_success():
    """Test successful AI inference path when no branch name is provided."""
    with (
        ProxyRunner.test() as runner,
        isolated_example_project_foo_bar(
            runner,
            in_workspace=False,
        ),
    ):
        with (
            patch("dagster_dg_cli.cli.scaffold.branch._run_git_command") as mock_git,
            patch("dagster_dg_cli.cli.scaffold.branch._run_gh_command") as mock_gh,
            patch("click.prompt") as mock_prompt,
            patch("dagster_dg_cli.cli.scaffold.branch.run_claude") as mock_run_claude,
            patch("dagster_dg_cli.cli.scaffold.branch.run_claude_stream"),
            patch("uuid.uuid4") as mock_uuid,
        ):
            # Mock UUID to make branch names predictable
            mock_uuid.return_value = type("MockUUID", (), {"__str__": lambda _: "abcd1234"})()

            mock_prompt.return_value = "Add authentication feature"

            mock_run_claude.return_value = '{"branch-name": "add-authentication-feature", "pr-title": "Add authentication feature"}'

            mock_git.return_value = Mock(returncode=0, stdout="", stderr="")
            mock_gh.return_value = Mock(
                returncode=0, stdout="https://github.com/user/repo/pull/123", stderr=""
            )

            result = runner.invoke("scaffold", "branch")
            assert_runner_result(result)

            mock_prompt.assert_called_once_with("What would you like to accomplish?")
            mock_run_claude.assert_called_once()
            call_args = mock_run_claude.call_args
            prompt_arg = call_args[0][1]
            assert "Add authentication feature" in prompt_arg

            # With AI scaffolding enabled, additional git calls are made
            # Branch name gets UUID suffix: add-authentication-feature-abcd1234
            expected_git_calls = [
                (["checkout", "-b", "add-authentication-feature-abcd1234"],),
                (["rev-parse", "HEAD"],),
                (
                    [
                        "commit",
                        "--allow-empty",
                        "-m",
                        "Initial commit for add-authentication-feature-abcd1234 branch",
                    ],
                ),
                (["push", "-u", "origin", "add-authentication-feature-abcd1234"],),
                (["add", "-A"],),
                (["commit", "-m", "First pass at add-authentication-feature-abcd1234"],),
                (["push"],),
                (["rev-parse", "HEAD"],),
            ]
            actual_git_calls = [call[0] for call in mock_git.call_args_list]
            assert actual_git_calls == expected_git_calls
            mock_gh.assert_called_once_with(
                [
                    "pr",
                    "create",
                    "--title",
                    "Add authentication feature",
                    "--body",
                    "This pull request was generated by the Dagster `dg` CLI for branch 'add-authentication-feature-abcd1234'.",
                ]
            )

            assert "Creating new branch: add-authentication-feature" in result.output
            assert "Created and checked out new branch: add-authentication-feature" in result.output


@pytest.mark.parametrize(
    "github_url",
    [
        "https://github.com/dagster-io/dagster/issues/123",
        "https://github.com/user/repo/issues/456",
        "https://github.com/some-org/some-project/issues/789",
    ],
)
def test_scaffold_branch_command_github_issue_url(github_url):
    """Test scaffold branch command with GitHub issue URLs."""
    with (
        ProxyRunner.test() as runner,
        isolated_example_project_foo_bar(
            runner,
            in_workspace=False,
            uv_sync=True,
        ) as project_dir,
        activate_venv(project_dir / ".venv"),
    ):
        with (
            patch("dagster_dg_cli.cli.scaffold.branch._run_git_command") as mock_git,
            patch("dagster_dg_cli.cli.scaffold.branch._run_gh_command") as mock_gh,
            patch("dagster_dg_cli.cli.scaffold.branch.run_claude") as mock_run_claude,
            patch("dagster_dg_cli.cli.scaffold.branch.run_claude_stream"),
            patch("uuid.uuid4") as mock_uuid,
        ):
            # Mock UUID to make branch names predictable
            mock_uuid.return_value = type("MockUUID", (), {"__str__": lambda _: "abcd1234"})()

            # Mock Claude to return predictable JSON response
            mock_run_claude.return_value = (
                '{"branch-name": "fix-issue-123", "pr-title": "Fix issue #123"}'
            )

            mock_git.return_value = Mock(returncode=0, stdout="", stderr="")
            mock_gh.return_value = Mock(
                returncode=0, stdout="https://github.com/user/repo/pull/456", stderr=""
            )

            result = runner.invoke("scaffold", "branch", github_url)
            assert_runner_result(result)

            mock_run_claude.assert_called_once()
            call_args = mock_run_claude.call_args
            prompt_arg = call_args[0][1]
            allowed_tools_arg = call_args[0][2]
            assert github_url in prompt_arg
            assert "GitHub issue" in prompt_arg
            assert "gh issue view --repo OWNER/REPO" in prompt_arg
            assert "Bash(gh issue view:*)" in allowed_tools_arg

            # With AI scaffolding enabled, additional git calls are made
            # Branch name gets UUID suffix: fix-issue-123-abcd1234
            expected_git_calls = [
                (["checkout", "-b", "fix-issue-123-abcd1234"],),
                (["rev-parse", "HEAD"],),
                (
                    [
                        "commit",
                        "--allow-empty",
                        "-m",
                        "Initial commit for fix-issue-123-abcd1234 branch",
                    ],
                ),
                (["push", "-u", "origin", "fix-issue-123-abcd1234"],),
                (["add", "-A"],),
                (["commit", "-m", "First pass at fix-issue-123-abcd1234"],),
                (["push"],),
                (["rev-parse", "HEAD"],),
            ]
            actual_git_calls = [call[0] for call in mock_git.call_args_list]
            assert actual_git_calls == expected_git_calls

            mock_gh.assert_called_once_with(
                [
                    "pr",
                    "create",
                    "--title",
                    "Fix issue #123",
                    "--body",
                    "This pull request was generated by the Dagster `dg` CLI for branch 'fix-issue-123-abcd1234'.",
                ]
            )

            assert "Creating new branch: fix-issue-123" in result.output
            assert "Created and checked out new branch: fix-issue-123" in result.output
