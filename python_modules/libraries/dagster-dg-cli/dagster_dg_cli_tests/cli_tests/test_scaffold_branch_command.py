import subprocess
from pathlib import Path
from tempfile import TemporaryDirectory
from unittest.mock import Mock, patch

import click
import pytest
from automation.eval.cli import main as eval_cli
from click.testing import CliRunner
from dagster_dg_core.utils import activate_venv
from dagster_dg_core_tests.utils import (
    ProxyRunner,
    assert_runner_result,
    isolated_example_project_foo_bar,
)
from dagster_shared.utils import environ
from deepeval.evaluate.types import EvaluationResult, TestResult
from deepeval.test_run import MetricData


def test_scaffold_branch_command_success():
    """Test successful branch creation with all steps."""
    with (
        ProxyRunner.test() as runner,
        isolated_example_project_foo_bar(
            runner,
            in_workspace=False,
        ),
    ):
        # Mock the subprocess calls to simulate git and gh commands
        with (
            patch("dagster_dg_cli.cli.scaffold.branch._run_git_command") as mock_git,
            patch("dagster_dg_cli.cli.scaffold.branch._run_gh_command") as mock_gh,
            patch("dagster_dg_cli.cli.scaffold.branch.has_remote_origin", return_value=True),
        ):
            # Mock git checkout -b command
            mock_git.return_value = Mock(returncode=0, stdout="", stderr="")

            # Mock gh pr create command
            mock_gh.return_value = Mock(
                returncode=0,
                stdout="https://github.com/user/repo/pull/123",
                stderr="",
            )

            result = runner.invoke("scaffold", "branch", "my-feature-branch")
            assert_runner_result(result)

            # Verify git commands were called in correct order
            expected_git_calls = [
                (["rev-parse", "--git-dir"],),  # Git repository check
                (["checkout", "-b", "my-feature-branch"],),
                (["rev-parse", "HEAD"],),
                (["commit", "--allow-empty", "-m", "Initial commit for my-feature-branch branch"],),
                (["push", "-u", "origin", "my-feature-branch"],),
            ]

            actual_git_calls = [call[0] for call in mock_git.call_args_list]
            assert actual_git_calls == expected_git_calls

            # Verify gh command was called correctly
            mock_gh.assert_called_once_with(
                [
                    "pr",
                    "create",
                    "--title",
                    "my-feature-branch",
                    "--body",
                    "This pull request was generated by the Dagster `dg` CLI for branch 'my-feature-branch'.",
                ]
            )

            # Check output messages
            assert "Creating new branch: my-feature-branch" in result.output
            assert "Created and checked out new branch: my-feature-branch" in result.output
            assert (
                "Created empty commit: Initial commit for my-feature-branch branch" in result.output
            )
            assert "Pushed branch my-feature-branch to remote" in result.output
            assert "Created pull request: https://github.com/user/repo/pull/123" in result.output
            assert (
                "‚úÖ Successfully created branch and pull request: https://github.com/user/repo/pull/123"
                in result.output
            )


def test_scaffold_branch_command_whitespace_branch_name():
    """Test that branch name is properly stripped of whitespace."""
    with (
        ProxyRunner.test() as runner,
        isolated_example_project_foo_bar(
            runner,
            in_workspace=False,
        ),
    ):
        with (
            patch("dagster_dg_cli.cli.scaffold.branch._run_git_command") as mock_git,
            patch("dagster_dg_cli.cli.scaffold.branch._run_gh_command") as mock_gh,
        ):
            mock_git.return_value = Mock(returncode=0, stdout="", stderr="")
            mock_gh.return_value = Mock(
                returncode=0,
                stdout="https://github.com/user/repo/pull/123",
                stderr="",
            )

            result = runner.invoke("scaffold", "branch", "  my-branch  ")
            assert_runner_result(result)

            # Verify the stripped branch name was used
            # The second git call (after the repo check) should be the checkout with stripped name
            checkout_git_call = mock_git.call_args_list[1][0][0]
            assert checkout_git_call == ["checkout", "-b", "my-branch"]


def test_run_git_command_git_not_found():
    """Test _run_git_command when git is not installed."""
    from dagster_dg_cli.cli.scaffold.branch import _run_git_command

    with patch("subprocess.run", side_effect=FileNotFoundError):
        with pytest.raises(click.ClickException, match="git command not found"):
            _run_git_command(["status"])


def test_run_gh_command_gh_not_found():
    """Test _run_gh_command when gh is not installed."""
    from dagster_dg_cli.cli.scaffold.branch import _run_gh_command

    with patch("subprocess.run", side_effect=FileNotFoundError):
        with pytest.raises(click.ClickException, match="gh command not found"):
            _run_gh_command(["pr", "list"])


def test_run_gh_command_command_fails():
    """Test _run_gh_command when gh command fails."""
    from dagster_dg_cli.cli.scaffold.branch import _run_gh_command

    with patch("subprocess.run") as mock_run:
        error = subprocess.CalledProcessError(1, "gh pr create")
        error.stderr = "error: not authenticated with GitHub"
        error.stdout = ""
        mock_run.side_effect = error

        with pytest.raises(
            click.ClickException, match="gh command failed: error: not authenticated with GitHub"
        ):
            _run_gh_command(["pr", "create"])


def test_check_git_repository_success():
    """Test _check_git_repository when in a valid git repository."""
    from dagster_dg_cli.cli.scaffold.branch import _check_git_repository

    with patch("subprocess.run") as mock_run:
        mock_run.return_value = Mock(returncode=0, stdout=".git", stderr="")
        # Should not raise an exception when git rev-parse --git-dir succeeds
        _check_git_repository()
        mock_run.assert_called_once_with(
            ["git", "rev-parse", "--git-dir"], capture_output=True, text=True, check=True, cwd=None
        )


def test_check_git_repository_not_a_repo():
    """Test _check_git_repository when not in a git repository."""
    from dagster_dg_cli.cli.scaffold.branch import _check_git_repository

    with patch("subprocess.run") as mock_run:
        error = subprocess.CalledProcessError(128, "git rev-parse --git-dir")
        error.stderr = "fatal: not a git repository (or any of the parent directories): .git"
        error.stdout = ""
        mock_run.side_effect = error

        with pytest.raises(
            click.ClickException,
            match="This command must be run within a git repository.\nTo initialize a new git repository, run:\n  git init",
        ):
            _check_git_repository()


def test_scaffold_branch_command_not_in_git_repo():
    """Test scaffold branch command fails when not in a git repository."""
    with (
        ProxyRunner.test() as runner,
        isolated_example_project_foo_bar(
            runner,
            in_workspace=False,
        ),
    ):
        with patch("dagster_dg_cli.cli.scaffold.branch._run_git_command") as mock_git:
            # Mock git rev-parse to fail as if not in a git repository
            error = subprocess.CalledProcessError(128, "git rev-parse --git-dir")
            error.stderr = "fatal: not a git repository (or any of the parent directories): .git"
            error.stdout = ""
            mock_git.side_effect = click.ClickException(
                f"git command failed: {error.stderr.strip()}"
            )

            result = runner.invoke("scaffold", "branch", "test-branch")

            # Should fail with git repository check
            assert result.exit_code != 0
            assert "This command must be run within a git repository" in result.output
            assert "git init" in result.output


def test_scaffold_branch_command_ai_inference_success():
    """Test successful AI inference path when no branch name is provided."""
    with (
        ProxyRunner.test() as runner,
        isolated_example_project_foo_bar(
            runner,
            in_workspace=False,
        ),
    ):
        with (
            patch("dagster_dg_cli.cli.scaffold.branch._run_git_command") as mock_git,
            patch("dagster_dg_cli.cli.scaffold.branch._run_gh_command") as mock_gh,
            patch("click.prompt") as mock_prompt,
            patch("dagster_dg_cli.cli.scaffold.branch.run_claude") as mock_run_claude,
            patch("dagster_dg_cli.cli.scaffold.branch.run_claude_stream"),
            patch("dagster_dg_cli.cli.scaffold.branch.has_remote_origin", return_value=True),
            patch("uuid.uuid4") as mock_uuid,
        ):
            # Mock UUID to make branch names predictable
            mock_uuid.return_value = type("MockUUID", (), {"__str__": lambda _: "abcd1234"})()

            mock_prompt.return_value = "Add authentication feature"

            mock_run_claude.return_value = '{"branch-name": "add-authentication-feature", "pr-title": "Add authentication feature"}'

            mock_git.return_value = Mock(returncode=0, stdout="", stderr="")
            mock_gh.return_value = Mock(
                returncode=0, stdout="https://github.com/user/repo/pull/123", stderr=""
            )

            result = runner.invoke("scaffold", "branch")
            assert_runner_result(result)

            mock_prompt.assert_called_once_with("What would you like to accomplish?")
            mock_run_claude.assert_called_once()
            call_args = mock_run_claude.call_args
            prompt_arg = call_args[0][1]
            assert "Add authentication feature" in prompt_arg

            # With AI scaffolding enabled, additional git calls are made
            # Branch name gets UUID suffix: add-authentication-feature-abcd1234
            expected_git_calls = [
                (["rev-parse", "--git-dir"],),  # Git repository check
                (["checkout", "-b", "add-authentication-feature-abcd1234"],),
                (["rev-parse", "HEAD"],),
                (
                    [
                        "commit",
                        "--allow-empty",
                        "-m",
                        "Initial commit for add-authentication-feature-abcd1234 branch",
                    ],
                ),
                (["push", "-u", "origin", "add-authentication-feature-abcd1234"],),
                (["add", "-A"],),
                (["commit", "-m", "First pass at add-authentication-feature-abcd1234"],),
                (["push"],),
                (["rev-parse", "HEAD"],),
            ]
            actual_git_calls = [call[0] for call in mock_git.call_args_list]
            assert actual_git_calls == expected_git_calls
            mock_gh.assert_called_once_with(
                [
                    "pr",
                    "create",
                    "--title",
                    "Add authentication feature",
                    "--body",
                    "This pull request was generated by the Dagster `dg` CLI for branch 'add-authentication-feature-abcd1234'.",
                ]
            )

            assert "Creating new branch: add-authentication-feature" in result.output
            assert "Created and checked out new branch: add-authentication-feature" in result.output


@pytest.mark.parametrize(
    "github_url",
    [
        "https://github.com/dagster-io/dagster/issues/123",
        "https://github.com/user/repo/issues/456",
        "https://github.com/some-org/some-project/issues/789",
    ],
)
def test_scaffold_branch_command_github_issue_url(github_url):
    """Test scaffold branch command with GitHub issue URLs."""
    with (
        ProxyRunner.test() as runner,
        isolated_example_project_foo_bar(
            runner,
            in_workspace=False,
            uv_sync=True,
        ) as project_dir,
        activate_venv(project_dir / ".venv"),
    ):
        with (
            patch("dagster_dg_cli.cli.scaffold.branch._run_git_command") as mock_git,
            patch("dagster_dg_cli.cli.scaffold.branch._run_gh_command") as mock_gh,
            patch("dagster_dg_cli.cli.scaffold.branch.run_claude") as mock_run_claude,
            patch("dagster_dg_cli.cli.scaffold.branch.run_claude_stream"),
            patch("dagster_dg_cli.cli.scaffold.branch.has_remote_origin", return_value=True),
            patch("uuid.uuid4") as mock_uuid,
        ):
            # Mock UUID to make branch names predictable
            mock_uuid.return_value = type("MockUUID", (), {"__str__": lambda _: "abcd1234"})()

            # Mock Claude to return predictable JSON response
            mock_run_claude.return_value = (
                '{"branch-name": "fix-issue-123", "pr-title": "Fix issue #123"}'
            )

            mock_git.return_value = Mock(returncode=0, stdout="", stderr="")
            mock_gh.return_value = Mock(
                returncode=0, stdout="https://github.com/user/repo/pull/456", stderr=""
            )

            result = runner.invoke("scaffold", "branch", github_url)
            assert_runner_result(result)

            mock_run_claude.assert_called_once()
            call_args = mock_run_claude.call_args
            prompt_arg = call_args[0][1]
            allowed_tools_arg = call_args[0][2]
            assert github_url in prompt_arg
            assert "GitHub issue" in prompt_arg
            assert "gh issue view --repo OWNER/REPO" in prompt_arg
            assert "Bash(gh issue view:*)" in allowed_tools_arg

            # With AI scaffolding enabled, additional git calls are made
            # Branch name gets UUID suffix: fix-issue-123-abcd1234
            expected_git_calls = [
                (["rev-parse", "--git-dir"],),  # Git repository check
                (["checkout", "-b", "fix-issue-123-abcd1234"],),
                (["rev-parse", "HEAD"],),
                (
                    [
                        "commit",
                        "--allow-empty",
                        "-m",
                        "Initial commit for fix-issue-123-abcd1234 branch",
                    ],
                ),
                (["push", "-u", "origin", "fix-issue-123-abcd1234"],),
                (["add", "-A"],),
                (["commit", "-m", "First pass at fix-issue-123-abcd1234"],),
                (["push"],),
                (["rev-parse", "HEAD"],),
            ]
            actual_git_calls = [call[0] for call in mock_git.call_args_list]
            assert actual_git_calls == expected_git_calls

            mock_gh.assert_called_once_with(
                [
                    "pr",
                    "create",
                    "--title",
                    "Fix issue #123",
                    "--body",
                    "This pull request was generated by the Dagster `dg` CLI for branch 'fix-issue-123-abcd1234'.",
                ]
            )

            assert "Creating new branch: fix-issue-123" in result.output
            assert "Created and checked out new branch: fix-issue-123" in result.output


def test_record_and_eval_command():
    # ensure --record output aligned with eval tool expectations
    with (
        ProxyRunner.test() as runner,
        isolated_example_project_foo_bar(
            runner,
            in_workspace=False,
        ),
        TemporaryDirectory() as temp_dir,
        environ(
            {
                "DAGSTER_GIT_REPO_DIR": "",
                "OPENAI_API_KEY": "...",
            }
        ),
        patch("dagster_dg_cli.cli.scaffold.branch._run_git_command") as mock_git,
        patch("dagster_dg_cli.cli.scaffold.branch._run_gh_command") as mock_gh,
        patch("dagster_dg_cli.cli.scaffold.branch.has_remote_origin", return_value=True),
        patch("automation.eval.cli.evaluate") as mock_evaluate,
    ):
        # Mock the subprocess calls to simulate git and gh commands

        # Mock git checkout -b command
        mock_git.return_value = Mock(returncode=0, stdout="", stderr="")

        # Mock gh pr create command
        mock_gh.return_value = Mock(
            returncode=0,
            stdout="https://github.com/user/repo/pull/123",
            stderr="",
        )

        mock_evaluate.return_value = EvaluationResult(
            test_results=[
                TestResult(
                    name="Test",
                    success=True,
                    conversational=False,
                    metrics_data=[
                        MetricData(
                            name="Test",
                            threshold=0.5,
                            score=1.0,
                            success=True,
                            strictMode=False,
                            evaluationModel="testbot",
                            verboseLogs="test",
                            evaluationCost=0,
                        )
                    ],
                )
            ],
            confident_link=None,
        )

        result = runner.invoke("scaffold", "branch", "my-feature-branch", "--record", str(temp_dir))
        assert_runner_result(result)
        assert "üìù Session recorded:" in result.output

        Path(temp_dir).joinpath("eval.yaml").write_text("""
metrics:
  - name: Test
    criteria: test test
        """)

        result = CliRunner().invoke(eval_cli, [str(temp_dir)])
        assert result.exit_code == 0, result.output
