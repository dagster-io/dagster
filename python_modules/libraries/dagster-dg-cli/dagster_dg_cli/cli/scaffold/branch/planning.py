"""Dynamic planning system for scaffold branch command.

This module implements the Dynamic Planning System that generates human-readable
implementation plans before code execution, enables plan review and refinement,
and provides bidirectional communication with Claude for interactive sessions.
"""

import asyncio
from typing import Any

from claude_code_sdk.types import AssistantMessage, TextBlock
from dagster_dg_core.context import DgContext
from dagster_shared.record import record

from dagster_dg_cli.cli.scaffold.branch.ai import PrintOutputChannel
from dagster_dg_cli.cli.scaffold.branch.claude.diagnostics import ClaudeDiagnostics
from dagster_dg_cli.cli.scaffold.branch.claude.sdk_client import ClaudeSDKClient
from dagster_dg_cli.cli.scaffold.branch.constants import ALLOWED_COMMANDS_PLANNING


@record
class GeneratedPlan:
    """Container for a prompt-generated implementation plan.

    Attributes:
        markdown_content: The complete plan as markdown text generated by Claude
        metadata: Additional metadata about plan generation
    """

    markdown_content: str
    metadata: dict[str, Any]


@record
class PlanningContext:
    """Context information for plan generation.

    Attributes:
        user_input: Original user request
        dg_context: Dagster project context
        codebase_patterns: Detected patterns from codebase analysis
        existing_components: List of available components
        project_structure: Overview of project file structure
    """

    user_input: str
    dg_context: DgContext
    codebase_patterns: dict[str, Any]
    existing_components: list[str]
    project_structure: dict[str, Any]


class PlanGenerator:
    """Main orchestrator for plan generation and refinement."""

    def __init__(self, claude_client: ClaudeSDKClient, diagnostics: ClaudeDiagnostics, state_manager):
        """Initialize the plan generator.

        Args:
            claude_client: Client for AI interactions
            diagnostics: Diagnostics service for logging
            state_manager: State manager for UI events
        """
        self.claude_client = claude_client
        self.diagnostics = diagnostics
        self.state_manager = state_manager

    def generate_initial_plan(self, context: PlanningContext) -> GeneratedPlan:
        """Generate initial implementation plan from user input.

        Args:
            context: Planning context with user input and project information

        Returns:
            Generated implementation plan as markdown content

        Raises:
            Exception: If plan generation fails
        """
        self.diagnostics.info(
            "planning_generation_start",
            "Starting initial plan generation",
            {
                "user_input_length": len(context.user_input),
                "available_components": len(context.existing_components),
            },
        )

        prompt = self._create_initial_plan_prompt(context)

        allowed_tools = ALLOWED_COMMANDS_PLANNING.copy()

        # Use Claude to generate structured plan as markdown
        messages = asyncio.run(
            self.claude_client.scaffold_with_streaming(
                prompt=prompt,
                allowed_tools=allowed_tools,
                output_channel=PrintOutputChannel(),
                disallowed_tools=["Bash(python:*)", "WebSearch", "WebFetch"],
                verbose=False,
            )
        )

        # Extract the plan content from Claude's response
        plan_content = self._extract_plan_from_messages(messages)

        plan = GeneratedPlan(
            markdown_content=plan_content,
            metadata={
                "generation_method": "prompt_driven_claude_generation",
                "messages_count": len(messages),
                "user_input": context.user_input,
            },
        )

        self.diagnostics.info(
            "planning_generation_completed",
            "Initial plan generation completed",
            {
                "plan_content_length": len(plan_content),
                "messages_count": len(messages),
            },
        )

        return plan

    def refine_plan(self, current_plan: GeneratedPlan, user_feedback: str) -> GeneratedPlan:
        """Refine existing plan based on user feedback.

        Args:
            current_plan: The current plan to refine
            user_feedback: User feedback for plan improvements

        Returns:
            Refined implementation plan
        """
        self.diagnostics.info(
            "planning_refinement_start",
            "Starting plan refinement",
            {
                "current_plan_length": len(current_plan.markdown_content),
                "feedback_length": len(user_feedback),
            },
        )

        prompt = self._create_refinement_prompt(current_plan, user_feedback)

        allowed_tools = ALLOWED_COMMANDS_PLANNING.copy()

        messages = asyncio.run(
            self.claude_client.scaffold_with_streaming(
                prompt=prompt,
                allowed_tools=allowed_tools,
                output_channel=PrintOutputChannel(),
                disallowed_tools=["Bash(python:*)", "WebSearch", "WebFetch"],
                verbose=False,
            )
        )

        # Extract refined plan content from Claude's response
        refined_content = self._extract_plan_from_messages(messages)

        refined_plan = GeneratedPlan(
            markdown_content=refined_content,
            metadata={
                **current_plan.metadata,
                "refinement_method": "prompt_driven_claude_refinement",
                "refinement_messages": len(messages),
                "user_feedback": user_feedback,
            },
        )

        self.diagnostics.info(
            "planning_refinement_completed",
            "Plan refinement completed",
            {
                "refined_content_length": len(refined_content),
            },
        )

        return refined_plan

    def _create_initial_plan_prompt(self, context: PlanningContext) -> str:
        """Create a natural prompt for initial plan generation by loading from template file.

        Args:
            context: Planning context with user input and project information

        Returns:
            Natural language prompt for Claude to generate a plan
        """
        from pathlib import Path

        # Load prompt template from external file
        prompt_path = Path(__file__).parent / "prompts" / "planning_prompt.md"
        template = prompt_path.read_text()

        # Prepare template variables
        available_components_text = (
            ", ".join(context.existing_components)
            if context.existing_components
            else "None detected"
        )

        codebase_info = ""
        if context.codebase_patterns:
            pattern_summary = [f"- {k}: {v}" for k, v in context.codebase_patterns.items()][
                :5
            ]  # Limit to top 5
            if pattern_summary:
                codebase_info = "\n\nCodebase Patterns:\n" + "\n".join(pattern_summary)

        project_info = ""
        if context.project_structure:
            project_info = f"\n\nProject Structure Overview: {context.project_structure}"

        # Format template with actual values
        return template.format(
            user_input=context.user_input,
            available_components=available_components_text,
            codebase_info=codebase_info,
            project_info=project_info,
        )

    def _create_refinement_prompt(self, current_plan: GeneratedPlan, user_feedback: str) -> str:
        """Create a natural prompt for plan refinement.

        Args:
            current_plan: The current plan to refine
            user_feedback: User's feedback for improvements

        Returns:
            Natural language prompt for Claude to refine the plan
        """
        return f"""You are refining an implementation plan based on user feedback.

Here is the current plan:

{current_plan.markdown_content}

---

User Feedback: {user_feedback}

---

Please generate an improved version of the implementation plan that addresses the user's feedback. Keep the same markdown structure and format, but incorporate the requested changes. Be specific about what you're modifying and why.

Provide the complete updated plan in the same markdown format as before."""

    def _extract_plan_from_messages(self, messages: list) -> str:
        """Extract plan content from Claude's response messages.

        Args:
            messages: List of message objects from Claude client

        Returns:
            The plan content as markdown text
        """
        self.diagnostics.debug(
            "plan_extraction_start",
            "Extracting plan from Claude messages",
            {"message_count": len(messages)},
        )

        # Look specifically for AssistantMessage and extract the text content
        plan_content = None
        success_result_found = False
        success_message = None

        for i, message in enumerate(messages):
            self.diagnostics.debug(
                "plan_message_processing",
                f"Processing message {i}",
                {
                    "message_type": str(type(message)),
                    "message_class": type(message).__name__,
                },
            )

            if isinstance(message, AssistantMessage):
                success_result_found = True
                success_message = message  # Store for metadata display
                # Extract text from TextBlock content
                text_content = ""
                for block in message.content:
                    if isinstance(block, TextBlock):
                        text_content += block.text

                if text_content and text_content.strip():
                    plan_content = text_content.strip()
                    self.diagnostics.info(
                        "plan_success_result_found",
                        f"Found AssistantMessage with {len(plan_content)} chars of content",
                        {
                            "message_index": i,
                            "content_blocks": len(message.content),
                        },
                    )
                    break  # Found what we need, stop processing
                else:
                    self.diagnostics.error(
                        "plan_success_result_empty",
                        "Found AssistantMessage but text content is empty",
                        {"message_index": i},
                    )

        # If we didn't find AssistantMessage, error and exit
        if not success_result_found:
            message_types = [type(msg).__name__ for msg in messages]
            self.diagnostics.error(
                "plan_no_success_result",
                "No AssistantMessage found in Claude response",
                {
                    "message_count": len(messages),
                    "message_types": message_types,
                },
            )
            raise Exception(
                f"Expected AssistantMessage from Claude SDK but got {len(messages)} message(s) "
                f"of types: {message_types}. This indicates a problem with Claude SDK communication "
                f"or model response. Check your Claude SDK installation and try again."
            )

        # If we found AssistantMessage but no content, error and exit
        if not plan_content:
            raise Exception(
                "Found AssistantMessage but the text content was empty. "
                "Claude generated a response but provided no plan content."
            )

        combined_content = plan_content

        # Display success summary to user
        if success_message:
            from dagster_dg_cli.cli.scaffold.branch.ui import create_status_message
            self.state_manager.emit_event(create_status_message(
                "success", "‚úÖ Plan generated successfully!"
            ))
            self.state_manager.emit_event(create_status_message(
                "info", f"üìä Response: {len(plan_content):,} characters"
            ))
            self.state_manager.emit_event(create_status_message(
                "info", "‚è±Ô∏è  Plan generation completed via Claude SDK"
            ))

        self.diagnostics.debug(
            "plan_extraction_result",
            "Plan extraction completed",
            {
                "content_length": len(combined_content),
                "has_implementation_plan": "# Implementation Plan" in combined_content,
            },
        )

        # Final validation - this should not happen since we validated above, but just in case
        if not combined_content or len(combined_content) < 100:
            raise Exception(
                f"AssistantMessage contained only {len(combined_content)} characters of content, "
                f"which is too short for a meaningful plan. Expected at least 100 characters."
            )

        return combined_content


