"""Main scaffold branch command implementation."""

import json
import re
import uuid
from contextlib import nullcontext
from datetime import datetime
from pathlib import Path
from typing import Optional

import click
from dagster_dg_core.config import normalize_cli_config
from dagster_dg_core.context import DgContext
from dagster_dg_core.shared_options import dg_global_options, dg_path_options
from dagster_dg_core.utils import DgClickCommand
from dagster_dg_core.utils.telemetry import cli_telemetry_wrapper
from dagster_shared.record import as_dict

from dagster_dg_cli.cli.scaffold.branch.ai import (
    INPUT_TYPES,
    TextInputType,
    get_branch_name_and_pr_title_from_prompt,
    scaffold_content_for_prompt,
)
from dagster_dg_cli.cli.scaffold.branch.git import (
    check_git_repository,
    create_branch_and_pr,
    create_content_commit_and_push,
    create_empty_commit,
    create_git_branch,
    get_dg_version,
    has_remote_origin,
    run_git_command,
)
from dagster_dg_cli.cli.scaffold.branch.models import Session
from dagster_dg_cli.utils.ui import daggy_spinner_context


def is_prompt_valid_git_branch_name(prompt: str) -> bool:
    """Whether the prompt is a valid git branch name."""
    return re.match(r"^[a-zA-Z0-9_.-]+$", prompt) is not None


@click.command(name="branch", cls=DgClickCommand, unlaunched=True)
@click.argument("prompt", type=str, nargs=-1)
@click.option("--disable-progress", is_flag=True, help="Disable progress spinner")
@click.option(
    "--local-only",
    is_flag=True,
    help="Create branch locally without pushing to remote or creating PR",
)
@click.option(
    "--record",
    type=Path,
    help="Directory to write out session information for later analysis.",
)
@dg_path_options
@dg_global_options
@cli_telemetry_wrapper
def scaffold_branch_command(
    prompt: tuple[str, ...],
    target_path: Path,
    disable_progress: bool,
    local_only: bool,
    record: Optional[Path],
    **other_options: object,
) -> None:
    """Scaffold a new branch."""
    # Check if we're in a git repository before proceeding
    check_git_repository()

    cli_config = normalize_cli_config(other_options, click.get_current_context())
    dg_context = DgContext.for_workspace_or_project_environment(target_path, cli_config)

    ai_scaffolding = False
    input_type = None

    if record and (not record.exists() or not record.is_dir()):
        raise click.UsageError(f"{record} is not an existing directory")

    prompt_text = " ".join(prompt)
    generated_outputs = {}
    # If the user input a valid git branch name, bypass AI inference and create the branch directly.
    if prompt_text and is_prompt_valid_git_branch_name(prompt_text.strip()):
        branch_name = prompt_text.strip()
        pr_title = branch_name
    else:
        # Otherwise, use AI to infer the branch name and PR title. Try to match the input to a known
        # input type so we can gather more context.
        if not prompt_text:
            prompt_text = click.prompt("What would you like to accomplish?")
        assert prompt_text
        input_type = next(
            (input_type for input_type in INPUT_TYPES if input_type.matches(prompt_text)),
            TextInputType,
        )

        spinner_ctx = (
            daggy_spinner_context("Generating branch name and PR title")
            if not disable_progress
            else nullcontext()
        )
        with spinner_ctx:
            branch_name, pr_title = get_branch_name_and_pr_title_from_prompt(
                dg_context, prompt_text, input_type
            )
        generated_outputs["branch_name"] = branch_name
        generated_outputs["pr_title"] = pr_title
        # For generated branch names, add a random suffix to avoid conflicts
        branch_name = branch_name + "-" + str(uuid.uuid4())[:8]
        ai_scaffolding = True

    click.echo(f"Creating new branch: {branch_name}")

    # Create and checkout the new branch
    branch_base_sha = create_git_branch(branch_name)

    # Create an empty commit to enable PR creation
    commit_message = f"Initial commit for {branch_name} branch"
    create_empty_commit(commit_message)

    # Determine if we should work locally only
    effective_local_only = local_only or not has_remote_origin()

    if effective_local_only:
        click.echo(f"‚úÖ Successfully created branch: {branch_name}")
        pr_url = ""
    else:
        # Create PR with branch name as title and standard body
        pr_body = (
            f"This pull request was generated by the Dagster `dg` CLI for branch '{branch_name}'."
        )

        # Push branch and create PR
        pr_url = create_branch_and_pr(branch_name, pr_title, pr_body, effective_local_only)

        click.echo(f"‚úÖ Successfully created branch and pull request: {pr_url}")

    first_pass_sha = None
    if ai_scaffolding and input_type:
        scaffold_content_for_prompt(
            dg_context, prompt_text, input_type, use_spinner=not disable_progress
        )
        first_pass_sha = create_content_commit_and_push(
            f"First pass at {branch_name}", effective_local_only
        )

    if record:
        if first_pass_sha:
            generated_outputs["first_pass_commit"] = run_git_command(
                ["show", first_pass_sha]
            ).stdout.strip()

        session_data = Session(
            timestamp=datetime.now().isoformat(),
            dg_version=get_dg_version(),
            branch_name=branch_name,
            pr_title=pr_title,
            pr_url=pr_url,
            branch_base_sha=branch_base_sha,
            first_pass_sha=first_pass_sha,
            input={
                "prompt": prompt_text,
            },
            output=generated_outputs,
        )
        record_path = record / f"{uuid.uuid4()}.json"
        record_path.write_text(json.dumps(as_dict(session_data), indent=2))
        click.echo(f"üìù Session recorded: {record_path}")
